---
title: 一些方法
date: 2017-05-23 21:23:26
tags:
  - javaScript
---
再不努力就完蛋惹。
<!--more-->

### JavaScript
#### 数组去重
  ```js
  // 有数组
  var arr = ['a', 'b', 'c', '1', 0, 'c', 1, '', 1, 0];
  let unique = function(){};
  unique(arr);
  // ['a', 'b', 'c', '1', 0, 1, '']
  ```

方法一 将原数组中的元素和结果数组中的元素一一比较。
```js
function unique(arr){
  let isUnique = [];
  arr.map(val => {
    if (isUnique.indexOf(val) === -1) {
      isUnique.push(val);
    }
  })
  return isUnique;
}; 
// filter
function unique(arr) {
  var res = arr.filter( (item, index, array) => {
    return array.indexOf(item) === index;   
  })
  return res;
}
```

然而 `indexOf` 不支持 IE6-8.

```js
// 多用一层循环兼容
var indexOf = [].indexOf ?
  function (arr, item) {
    return arr.indexOf(item);
  } :
  function (arr, item) {
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] === item) {
        return i;
      }
      else {
        return -1;
      }
    };
  };
function unique(arr) {
  var isUnique = [];
  arr.map(function (val) {
    if (indexOf(isUnique, val) === -1) {
      isUnique.push(val);
    }
  });
  return isUnique;
}
```

方法二 将原数组中重复元素的最后一个元素放入结果数组中。
```js
function unique(arr) {
  var res = [];

  for (var i = 0; i < arr.length; i++) {
    for (var j = i + 1; j < arr.length; j++) {
      // 如果发现相同元素 则i自身进入下一个循环比较
      if (arr[i] === arr[j]) {
        j = ++i;
      }
    }
    res.push(arr[i]);
  }
  return res;
}
```

方法三 ES6
```js
var unique = arr => [...new Set(arr)];
```

#### 类继承与原型继承
[类继承与原型继承原文](http://www.zcfy.cc/article/master-the-javascript-interview-what-s-the-difference-between-class-amp-prototypal-inheritance-2185.html)
es6中的`class`是建立在构造函数之上的一种封装，本质依旧是函数。

类继承：使用原型链连接子类与父类的`Prototype`,形成层级划分的代理模式。会产生父—子对象分类的副作用。
- 紧耦合，脆弱基类
- 层级僵化 （新用例的出现，最终会使所有涉及到的继承层次上都出现问题）
- 必然重复性
原型继承：原型是工作对象的实例，对象直接从其他对象继承属性，因此，对象实例可以由多个对象源所组成。


#### new出一个实例  [原文](https://rockjins.js.org/2017/01/18/2017-01-18-new-object/)

```js
var createObject = function () {
  // 创建一个空对象
  console.log(arguments);
  var obj = new Object(),
  // 取到构造函数，赋值给Constructor
    Constructor = [].shift.call(arguments);
  console.log(Constructor);
  // 把引用的Constructor的prototype 赋值给obj原型链
  obj.__proto__ = Constructor.prototype;
  console.log(obj);
  // 用apply改变this的指向，用obj代替Constructor构造函数内部的this，并把arguments作为参数传入
  var ret = Constructor.apply(obj, arguments);
  
  return typeof ret === 'object' ? ret : obj;
};

function People(name) {
  this.name = name;
};
People.prototype.getName = function() {
  return this.name;
};

// 生成实例
var Sam = createObject(People, 'Sam');
var Lary = new People('Lary');
console.log(Lary);
```

### 深拷贝&浅拷贝
仅针对`Object`/`Array`这样的复杂对象
- 浅拷贝
  浅拷贝只会将对象的各个属性依次复制，而不进行递归复制，
  又因为Js存储对象存储地址，
  因此浅拷贝仅拷贝了地址，原对象与浅拷贝对象的属性还是指向同一块内存地址
  结果就造成了修改原对象或拷贝对象都会修改内存地址的数据
```js
  var info = {usr: {name: 'name'}, arr: [1, 2, 3]};
  function shallowCopy(obj) {
    let _newObj = {};
    for (let prop in obj) {
      if(obj.hasOwnProperty(prop)) {
        _newObj[prop] = obj[prop];
      }
    }
    return _newObj;
  }
  let shallowObj = shallowCopy(info);
```
- 深拷贝
  深拷贝将原对象的所有属性递归复制
  因此不会出现指向同一地址的问题
```js
function deepCopy(p,c){
    var i;
    c = c||{};
    for(i in p){
        if(p.hasOwnProperty(i)){
            if(typeof(p[i])==="object"){
                c[i] = Array.isArray(p[i])?[]:{};
                deepCopy(p[i],c[i]);
            }else{
                c[i] = p[i];
           }
        }
    }
    return c;
}
```

#### XMLHttpRequest&AJAX
为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户
| 继承`XMLHttpRequestEventTarget`&`EventTarget`

- `readyState`
  - 0 `UNSENT`
    XMLHttpRequest 代理已被创建， 但尚未调用 open() 方法
  - 1 `OPENED` 
    open() 方法已经被触发。
    可以通过  setRequestHeader() 方法来设置请求的头部
    可以调用 send() 方法来发起请求
  - 2 `HEADERS_RECEIVED` 
    send() 方法已经被调用，响应头也已经被接收
  - 3 `LOADING` 
    应体部分正在被接收。
    如果 responseType 属性是“text”或空字符串， responseText 将会在载入的过程中拥有部分响应数据。
  - 4 `DONE`
    请求操作已经完成。这意味着数据传输已经彻底完成或失败
- `status` 响应状态
- `statusText` 响应说明
- `onreadystatechange`
当 `readyState` 的值改变的时候，`callback` 函数会被调用
- `timeout`
  超时时间，单位为毫秒，超时后触发`ontimeout`事件
- `withCredentials` 
默认false，跨域请求不能设置cookie
为true时可以跨域设置cookie
- `abort()` 终止
- `getAllResponseHeaders()`
返回所有响应头信息(响应头名和值), 如果响应头还没接受,则返回null
- `getResponseHeader(DOMString header)`
返回指定的响应头的值, 如果响应头还没被接受,或该响应头不存在,则返回null.
- `open(method, url, async, user, password)`
  - `method` 请求方法 (GET, POST, PUT, DELETE)
  - `url` 请求的url
  - `async` 默认为true
    如果值为false,则send()方法不会返回任何东西，直到接受到了服务器的返回数据
    如果为值为true，一个对开发者透明的通知会发送到相关的事件监听者
- `send()`
  发送请求.
  如果该请求是异步模式(默认),该方法会立刻返回.
  如果请求是同步模式,则直到请求的响应完全接受以后,该方法才会返回.
- `setRequestHeader(headerName, value)`
给指定的HTTP请求头赋值.在这之前,你必须确认已经调用 open() 方法打开了一个url.

```js
var xmlHttp;  
  
function AjaxFunction(){  
        createXMLHttpRequest();  
        if(xmlHttp!=null){  
    xmlHttp.onreadystatechange = callBack;  
    xmlHttp.open("get/Post","URL",true/false);  
    xmlHttp.send(null);  
        }     
}     
  
//实例化XMLHttpRequest对象  
function createXMLHttpRequest(){  
        if(window.XMLHttpRequest){  
    xmlHttp = new XMLHttpRequest();   
        }else if(window.ActiveXObject){  
    xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");  
        }  
}  
  
//指定响应函数  
function callBack(){  
        if(xmlHttp.readyState==4){  
                if(xmlHttp.status==200){  
            //do something with xmlHttp.responseText;  
            xmlHttp.responseText;  
                }     
        }  
}  
```
#### 并发模型

#### 跨域问题
- `JSONP`
原理：动态插入`script`标签，通过script标签引入一个js文件，这个文件载入成功后会执行我们在url参数中指定的函数，并把我们需要的就送数据作为参数传入。
```js
function Jsonp(src) {
  function getData(data) {
    return data;
  }
  _src = src + '?callback=getData';
  var _script = document.createElement("script");
  _script.src = _src;
  document.body.appendChild(script);
}
```
- CORS
服务端设置`Access-Control-Allow-Origin`
- document.domain跨子域
- window.name
- window.postMessage

#### web安全
### CSS

#### 优先级
- 通用选择器，组合子，否定伪类对特异性没有影响 (*, +/>/~, :not())
- 0级 类型选择器，伪元素 (a, h1, ::be  fore)
- 1级 类选择器，属性选择器, 伪类3 (.example, [type="radio"], :hover)
- 2级 ID选择器 (#example)
- 内联样式
- !important

#### 外边距合并
块的顶部外边距和底部外边距又是被折叠为单个外边距
其大小事组合到其中的最大外边距
只有普通文档流中块框的垂直外边距才会发生外边距合并
- 相邻的兄弟姐妹元素
- 块级父元素与其第一个/最后一个子元素
- 空块元素
解决方法：padding，overflow，clear
#### position 指定一个元素在文档中的定位方式
- `static`
  正常布局行为，top，right，bottom，left，z-index无效
- `relative`
  元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置
- `absolute`
  不为元素预留空间
  通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置
  可以设置外边距，且不会与其他边距合并
- `fixed`
  不为元素预留空间
  过指定元素相对于屏幕视口（viewport）的位置来指定元素位置
- `sticky`
粘性定位是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位

#### BFC 块格式化上下文
- 一个BFC：创建的元素 + 内部的所有子元素 - BFC子元素的内部元素
- 作用：对定位，清除浮动有影响
- 创建方法
  - 根元素或其它包含它的元素
  - 浮动元素 (元素的 `float` 不是 `none`)
  - 绝对定位元素 (元素的 `position` 为 `absolute` 或 `fixed`)
  - 内联块 (元素具有 d`isplay: inline-block`)
  - 表格单元格 (元素具有 `display: table-cell`，HTML表格单元格默认属性)
  - 表格标题 (元素具有 `display: table-caption`, HTML表格标题默认属性)
  - `具有overflow` 且值不是 `visible` 的块元素，
  - `display: flow-root`
  - `column-span: all` 应当总是会创建一个新的格式化上下文，即便具有`column-span: all` 的元素并不被包裹在一个多列容器中