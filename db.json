{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/varaint/source/favicon.svg","path":"favicon.svg","modified":0,"renderable":1},{"_id":"themes/varaint/source/favicon1.png","path":"favicon1.png","modified":0,"renderable":1},{"_id":"themes/varaint/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/varaint/source/js/module.js","path":"js/module.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/fonts/din.otf","path":"css/fonts/din.otf","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-Splus.js","path":"js/google-code-prettify/lang-Splus.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-aea.js","path":"js/google-code-prettify/lang-aea.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-basic.js","path":"js/google-code-prettify/lang-basic.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-agc.js","path":"js/google-code-prettify/lang-agc.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-apollo.js","path":"js/google-code-prettify/lang-apollo.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-cl.js","path":"js/google-code-prettify/lang-cl.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-clj.js","path":"js/google-code-prettify/lang-clj.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-cbm.js","path":"js/google-code-prettify/lang-cbm.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-css.js","path":"js/google-code-prettify/lang-css.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-dart.js","path":"js/google-code-prettify/lang-dart.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-el.js","path":"js/google-code-prettify/lang-el.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-erl.js","path":"js/google-code-prettify/lang-erl.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-erlang.js","path":"js/google-code-prettify/lang-erlang.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lasso.js","path":"js/google-code-prettify/lang-lasso.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-fs.js","path":"js/google-code-prettify/lang-fs.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lassoscript.js","path":"js/google-code-prettify/lang-lassoscript.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-go.js","path":"js/google-code-prettify/lang-go.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-hs.js","path":"js/google-code-prettify/lang-hs.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-latex.js","path":"js/google-code-prettify/lang-latex.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lgt.js","path":"js/google-code-prettify/lang-lgt.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lisp.js","path":"js/google-code-prettify/lang-lisp.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-llvm.js","path":"js/google-code-prettify/lang-llvm.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ll.js","path":"js/google-code-prettify/lang-ll.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lua.js","path":"js/google-code-prettify/lang-lua.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-matlab.js","path":"js/google-code-prettify/lang-matlab.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-logtalk.js","path":"js/google-code-prettify/lang-logtalk.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ls.js","path":"js/google-code-prettify/lang-ls.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lsp.js","path":"js/google-code-prettify/lang-lsp.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-n.js","path":"js/google-code-prettify/lang-n.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ml.js","path":"js/google-code-prettify/lang-ml.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-mumps.js","path":"js/google-code-prettify/lang-mumps.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-nemerle.js","path":"js/google-code-prettify/lang-nemerle.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-proto.js","path":"js/google-code-prettify/lang-proto.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-pascal.js","path":"js/google-code-prettify/lang-pascal.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-r.js","path":"js/google-code-prettify/lang-r.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rd.js","path":"js/google-code-prettify/lang-rd.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rkt.js","path":"js/google-code-prettify/lang-rkt.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rust.js","path":"js/google-code-prettify/lang-rust.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-s.js","path":"js/google-code-prettify/lang-s.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-scala.js","path":"js/google-code-prettify/lang-scala.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-sql.js","path":"js/google-code-prettify/lang-sql.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-scm.js","path":"js/google-code-prettify/lang-scm.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ss.js","path":"js/google-code-prettify/lang-ss.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-swift.js","path":"js/google-code-prettify/lang-swift.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-tcl.js","path":"js/google-code-prettify/lang-tcl.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-tex.js","path":"js/google-code-prettify/lang-tex.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vb.js","path":"js/google-code-prettify/lang-vb.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vbs.js","path":"js/google-code-prettify/lang-vbs.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vhd.js","path":"js/google-code-prettify/lang-vhd.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vhdl.js","path":"js/google-code-prettify/lang-vhdl.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-wiki.js","path":"js/google-code-prettify/lang-wiki.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-xq.js","path":"js/google-code-prettify/lang-xq.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-yaml.js","path":"js/google-code-prettify/lang-yaml.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-xquery.js","path":"js/google-code-prettify/lang-xquery.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/prettify.css","path":"js/google-code-prettify/prettify.css","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/lang-yml.js","path":"js/google-code-prettify/lang-yml.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/prettify.js","path":"js/google-code-prettify/prettify.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/run_prettify.js","path":"js/google-code-prettify/run_prettify.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/google-code-prettify/tomorrow-night-eighties.min.css","path":"js/google-code-prettify/tomorrow-night-eighties.min.css","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.eot","path":"css/fonts/iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.svg","path":"css/fonts/iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.ttf","path":"css/fonts/iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.woff","path":"css/fonts/iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/varaint/source/banner/1.jpg","path":"banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/varaint/source/js/lib.js","path":"js/lib.js","modified":0,"renderable":1},{"_id":"themes/varaint/source/banner/5.jpg","path":"banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/varaint/source/banner/2.jpg","path":"banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/varaint/source/banner/3.jpg","path":"banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/varaint/source/banner/4.jpg","path":"banner/4.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"c12d3f43293e7a5d9f3f875b963c9bac24218b37","modified":1511428214041},{"_id":"source/.project","hash":"4679bdfe179f3c66a07355e14fb628178a3c7e6e","modified":1481640559000},{"_id":"themes/varaint/README.md","hash":"e165ab166ec9ceda2e3a369f00514602c3532d75","modified":1487687670000},{"_id":"source/favicon.ico","hash":"a7169226e85e1b58a4eac43a6b2fd63a140c4f26","modified":1481384508000},{"_id":"themes/varaint/.DS_Store","hash":"07484dfa2c12067a241ce0986892b62703fd98a6","modified":1493732825000},{"_id":"themes/varaint/_config.yml","hash":"63a5a2f0aee01c1ceaf426b2c5f27e9031fc132f","modified":1511494043959},{"_id":"source/_posts/JavaScript设计模式.md","hash":"bb40eb107f5444c99cf5272212f80fa944c518bf","modified":1501312356000},{"_id":"source/_posts/.DS_Store","hash":"97d713e55a25caa29822459d1cb0b00fdc404cec","modified":1485169741000},{"_id":"source/_posts/ES6与ES5.md","hash":"055ab3286c413daeb52eb4babb8803564abab20f","modified":1508036025868},{"_id":"source/_posts/Rx入门学习.md","hash":"cb81c605e859440601c8642286d93e393eb77da6","modified":1502637145000},{"_id":"source/_posts/Vuex与Redux与Mobx.md","hash":"563fd26d79542abb5f66796a39eba04598c0f065","modified":1496404016000},{"_id":"source/_posts/TypeScript中的OOP.md","hash":"d1ec0f7ad694a57722b5241377c1ecb3a914bb0e","modified":1508036084947},{"_id":"source/_posts/WebGL-study.md","hash":"3f236d83bcb1bdf012d082439393dcbec23dae2b","modified":1511080098904},{"_id":"source/_posts/angular4-directive入场动画.md","hash":"db72334f2438fae14d31e0a1d82d1bf0a0355459","modified":1511491887278},{"_id":"source/_posts/js中的arguments.md","hash":"dd682f372590d62eaf196158898c9066a0eb3795","modified":1485169828000},{"_id":"source/_posts/mongodb安全认证.md","hash":"e95817484aa6c79d5f144a73b84c2aa4e545d244","modified":1496840299000},{"_id":"source/_posts/mongodb初探.md","hash":"c547eb5d7e3af5c7f7ea3b664de99413fdc13487","modified":1485273810000},{"_id":"source/_posts/css布局.md","hash":"7f3e9b0b2b8c41c7b6812eb21bca3e5d38504dcf","modified":1508035948452},{"_id":"source/_posts/angular4入门.md","hash":"93d10ca6801349e77de6283eb5f220f03180271b","modified":1508035918806},{"_id":"source/_posts/softwareEngineering.md","hash":"6348013a9639a95b29c349a23de59196044e33f5","modified":1511939059145},{"_id":"source/_posts/mongodb的一些操作.md","hash":"2b7c33ed21c1d2592288e8b953e58c20ba09e5f5","modified":1491017750000},{"_id":"source/_posts/react学习.md","hash":"ab99e1326ecb38d2e9612bb8e8540ed1529e909c","modified":1493949511000},{"_id":"source/_posts/three-js入门.md","hash":"79f637d9e5f0ef247c7f28422d3b50798153be3e","modified":1508035910155},{"_id":"source/_posts/ts数据结构.md","hash":"4f867066d7b155e66f4da87ce0e8779cb9a25651","modified":1508051966524},{"_id":"source/_posts/translate-koa2.md","hash":"669f78c9e4318ac3001555bfff0b898227ec5df4","modified":1491306390000},{"_id":"source/_posts/基础题收集.md","hash":"285151f8d57962ee4c7829216c8898569fefb40d","modified":1500865971000},{"_id":"source/_posts/基于websocket实现服务器浏览器持续通信.md","hash":"07a89bc138ec41de5b15fce48607d346893712b8","modified":1482154306000},{"_id":"source/_posts/第一篇博客.md","hash":"917edce992584c50e153c5e2504b0f68d580b305","modified":1479744312000},{"_id":"source/_posts/记录第一次搭建hexo.md","hash":"a4a6f94aec73fb16d24407bb50b809c7adf7cf38","modified":1508036069791},{"_id":"source/about/about.md","hash":"d918ea347c2d46c29ce64dd25abec82730169cac","modified":1493728428000},{"_id":"source/categories/index.md","hash":"4cd81f62bc5c4fd51d29c61081a6f3936479fc49","modified":1479658142000},{"_id":"source/tags/index.md","hash":"cf63aadf6e84d3583ef397ee6daebdea3b082c10","modified":1479744718000},{"_id":"themes/varaint/scripts/paging.js","hash":"81d67ff0e9e78f44b84ff042a7c0ab365ebfa7dd","modified":1487687670000},{"_id":"themes/varaint/layout/index.ejs","hash":"9f5f9e9a9eeb297782e34dfd10d608ee0ebd9a0b","modified":1487687670000},{"_id":"themes/varaint/layout/layout.ejs","hash":"d700ac5cc73361d54616525ab30ba9cd3939d299","modified":1487687670000},{"_id":"themes/varaint/layout/post.ejs","hash":"596a512dde277b33ec091e101f35c0acb08544fe","modified":1487687670000},{"_id":"themes/varaint/source/.DS_Store","hash":"1cb77aae52c7eb876be1258dc5ca75bcadfd1c16","modified":1493734173000},{"_id":"themes/varaint/source/favicon.svg","hash":"b12867228c15df5638c2edc4bf4ed7c21b31f163","modified":1485171522000},{"_id":"themes/varaint/source/favicon1.png","hash":"e9fc8fabc76fa6aaf3c2fb71535b04400f0e06a8","modified":1487687670000},{"_id":"themes/varaint/source/favicon.png","hash":"a7169226e85e1b58a4eac43a6b2fd63a140c4f26","modified":1481384508000},{"_id":"themes/varaint/layout/_partial/author.ejs","hash":"ef624addd7914c0ceae7d394ad64fe04a1010693","modified":1487687670000},{"_id":"themes/varaint/layout/_partial/banner.ejs","hash":"49ced60b9d231aed216cd77da7013a7357e74152","modified":1487687670000},{"_id":"themes/varaint/layout/_partial/archive.ejs","hash":"5943b5bce733e6fc38b5e9d21492315dec167cbe","modified":1487687670000},{"_id":"themes/varaint/layout/_partial/header.ejs","hash":"0190f18687c44e63a08349a2a7a17bcca6a542ec","modified":1487687670000},{"_id":"themes/varaint/layout/_partial/footer.ejs","hash":"c3cabae8d20ff8f3bfaa726bf1550b35e6fe4736","modified":1493734602000},{"_id":"themes/varaint/layout/_partial/article.ejs","hash":"3fa1cb4118ae05718a19637785575eebef4c616e","modified":1487687670000},{"_id":"themes/varaint/layout/_partial/search.ejs","hash":"a8b8b5057fedf31a907c0147edef2a2511b8754b","modified":1487687670000},{"_id":"themes/varaint/layout/_partial/sidebar.ejs","hash":"92d052fe1076f7fd425639fc4c251fc34323c7c1","modified":1487687670000},{"_id":"themes/varaint/layout/_partial/head.ejs","hash":"f5af720d2775dd2f212a0d68045d972247205db9","modified":1493734619000},{"_id":"themes/varaint/layout/_widget/date.ejs","hash":"9d012a767db8ef232d30bc54db58df6f54b828af","modified":1487687670000},{"_id":"themes/varaint/layout/_widget/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1487687670000},{"_id":"themes/varaint/source/banner/.DS_Store","hash":"8366701ab5d848093491e768c1fb88ece0299f56","modified":1493732800000},{"_id":"themes/varaint/source/css/_font.styl","hash":"66e0478c8cc77efb061e587a1b84d4e3ea8902df","modified":1487687670000},{"_id":"themes/varaint/source/css/_var.styl","hash":"930cd91ab1b020a59303312536238bc040260f66","modified":1487687670000},{"_id":"themes/varaint/source/css/style.styl","hash":"f867044b8e05c81e4594e0c1aaa70a539c579071","modified":1487687670000},{"_id":"themes/varaint/source/js/.DS_Store","hash":"94d6b0cc2e48f980721d5f063a9af89d11fb3ba7","modified":1493732716000},{"_id":"themes/varaint/source/js/module.js","hash":"cee61899e919ebe29fd9c18f6880a335cee8bdfc","modified":1487687670000},{"_id":"themes/varaint/source/js/script.js","hash":"5923cdc0852b83c1c6fe55c6e58424204e57edec","modified":1487687670000},{"_id":"themes/varaint/layout/_partial/post/disqus-comment.ejs","hash":"2eff8228047dfd6b00345fee455c9f3de6a741e9","modified":1487687670000},{"_id":"themes/varaint/layout/_partial/post/duoshuo-comment.ejs","hash":"11f7ab676f0125d0dbfbea3eff612cb63b999dcb","modified":1487687670000},{"_id":"themes/varaint/layout/_partial/post/share.ejs","hash":"e56cc398a4652ba28439f2ed496834886a0442fa","modified":1487687670000},{"_id":"themes/varaint/source/css/_partial/archive.styl","hash":"ee5d4daaabcddd999227c61e78e905e2800d6ef0","modified":1511939246286},{"_id":"themes/varaint/source/css/_partial/article.styl","hash":"9470f37356cec2e384b86658226c8075928c58c4","modified":1487687670000},{"_id":"themes/varaint/source/css/_partial/author.styl","hash":"cab911a74ea31000b37f5c11d02473412a5aaec7","modified":1487687670000},{"_id":"themes/varaint/source/css/_partial/banner.styl","hash":"8f9ce6107c966972c4ec7ceb99fd7a391a8b7260","modified":1487687670000},{"_id":"themes/varaint/source/css/_partial/footer.styl","hash":"45a2ea849690abb158cdf59ad1f82eda1af2f5eb","modified":1487687670000},{"_id":"themes/varaint/source/css/_partial/header.styl","hash":"a3fad4f045270f5a2f9fff5feb44ae0c1caef51e","modified":1487687670000},{"_id":"themes/varaint/source/css/_partial/search.styl","hash":"5b0dae4961ba27f48cd7eec7183673efe6a69a4b","modified":1487687670000},{"_id":"themes/varaint/source/css/_partial/sidebar.styl","hash":"ce695db24414b36bbbb27828db5fdadacce9b77d","modified":1487687670000},{"_id":"themes/varaint/source/css/fonts/din.otf","hash":"db6c925f4906e671f86d43fe5cb750dea99adddb","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-Splus.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-aea.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-basic.js","hash":"efeefe1f0d1f20b66d2cb0635b8f0c7fcfe7ff0a","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-agc.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-apollo.js","hash":"6a795a6049869e05b98fe851e72094276d3ae613","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-cl.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-clj.js","hash":"a2c893fc1b79d9c3aed59e22bcf3769bb5563b5c","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-cbm.js","hash":"efeefe1f0d1f20b66d2cb0635b8f0c7fcfe7ff0a","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-css.js","hash":"22160ffbcd219c018c3dbef745da29cc334c6e8c","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-dart.js","hash":"be57991fbb09bd187be3cb0218bd5e9c997eea5b","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-el.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-erl.js","hash":"d3ba7d0376ff6f95f5785341653c24166d4ef8e4","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-erlang.js","hash":"d3ba7d0376ff6f95f5785341653c24166d4ef8e4","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lasso.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-fs.js","hash":"fe6b2569654df7a1861bb2518a2ac443603d471f","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lassoscript.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-go.js","hash":"640ffa4b3f9c5aee9414962645b9a7f0f49dd555","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-hs.js","hash":"3158902af4476578fc61eb9e47c679e663a77342","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-latex.js","hash":"57371d546cb8e1c105985a59ed135a1b97944d17","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lgt.js","hash":"a8ca762427547d5968153b6afe1e3ee02520886a","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lisp.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-llvm.js","hash":"91b28e339c9b32bfe61fc6ae6eba166936ee38fb","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ll.js","hash":"91b28e339c9b32bfe61fc6ae6eba166936ee38fb","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lua.js","hash":"60a3dccac2fe79b0e1c38dec6be79a6ae51883fa","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-matlab.js","hash":"94c8fd7c44194dd3b1a444a3fc7c2b7fd09d9d6a","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-logtalk.js","hash":"a8ca762427547d5968153b6afe1e3ee02520886a","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ls.js","hash":"ec97ae568bcde0d905af52e4a68ba1bc7b898af9","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-lsp.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-n.js","hash":"65e144772759352d3b8c612219d5d817735cc7a0","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ml.js","hash":"fe6b2569654df7a1861bb2518a2ac443603d471f","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-mumps.js","hash":"a6002126b8dfc84a167040a024aad9b6b4e406ee","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-nemerle.js","hash":"65e144772759352d3b8c612219d5d817735cc7a0","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-proto.js","hash":"76ab0965b0e47de76cb5293ceafc7e5ca1588380","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-pascal.js","hash":"6630a2845b3a0951cbd4b2b8f69d538e0845a53e","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-r.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rd.js","hash":"f2c5bbaca8b6a00737dbdd30d26ea84a0c9db9bc","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rkt.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-rust.js","hash":"4e91bf396678821d7124e45478f77662912f68a6","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-s.js","hash":"cf0eb1b7e60d2b5704901965578eeb8333196ff3","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-scala.js","hash":"cf07e43b333938964236f455826c335fc806aaa5","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-sql.js","hash":"483cc0f4bd0773f6e7377f48b7a028d83790dd1b","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-scm.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-ss.js","hash":"a51313f66790f8de2f39a124b7595d9ff876df36","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-swift.js","hash":"96ecf47954b110d6f46afde474dca4a8a36de641","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-tcl.js","hash":"38c918e9a43c8975074302305b8b8e5f30d513dc","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-tex.js","hash":"57371d546cb8e1c105985a59ed135a1b97944d17","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vb.js","hash":"1f5344a5051aa3800193b8031dab4acbe3e341cb","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vbs.js","hash":"1f5344a5051aa3800193b8031dab4acbe3e341cb","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vhd.js","hash":"09c27f0ced7244e8ece3ab043bf8aa3028cc2927","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-vhdl.js","hash":"09c27f0ced7244e8ece3ab043bf8aa3028cc2927","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-wiki.js","hash":"c4090580e86c5040709e6b8fd63b661f978149a6","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-xq.js","hash":"52c4ad346f115881a250652f1d98f35826f4f239","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-yaml.js","hash":"5aaea285d2e08556c0a754d637d912ed82734d8e","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-xquery.js","hash":"52c4ad346f115881a250652f1d98f35826f4f239","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/prettify.css","hash":"8e1c89c9a44e0e837551bdfe250a672d6c21f2b7","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/lang-yml.js","hash":"5aaea285d2e08556c0a754d637d912ed82734d8e","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/prettify.js","hash":"8f3a565f0a190aa9df6c9e6e0cb2c3c2445bfa55","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/run_prettify.js","hash":"face8177a6804506c67c5644c00f3c6e0e50f02b","modified":1487687670000},{"_id":"themes/varaint/source/js/google-code-prettify/tomorrow-night-eighties.min.css","hash":"f654ece8ef13e740f844ce593912e040e3f21e5f","modified":1487687670000},{"_id":"themes/varaint/source/css/_partial/post/share.styl","hash":"7e7ce553e746b788fe723eb33028e9f3b5a5fb3c","modified":1487687670000},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.eot","hash":"1f90b84b9d3afe27303ce73196f9786efc42953b","modified":1487687670000},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.svg","hash":"73321f0798240e541a0f3f468bb6828feeb64fa0","modified":1487687670000},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.ttf","hash":"cc36ce4748a2294a915a467a6b4feb046b1aaeb1","modified":1487687670000},{"_id":"themes/varaint/source/css/fonts/iconfont/iconfont.woff","hash":"130d610313a6bcdb1d3dd1451b53087a2c2a56e9","modified":1487687670000},{"_id":"themes/varaint/source/banner/1.jpg","hash":"8028af3adf981dff3f38252ef8d00330291198f4","modified":1491383778000},{"_id":"themes/varaint/source/js/lib.js","hash":"d1f3a62d0d91c3000e9b351e41ad441f0632f8b9","modified":1487687670000},{"_id":"themes/varaint/source/banner/5.jpg","hash":"272dc5e2eac84b882ad8f10fff8fd929774f2ae2","modified":1491384131000},{"_id":"themes/varaint/source/banner/2.jpg","hash":"fabaa1cfc2d98eb46c275bd479c09d67d36f3084","modified":1491383491000},{"_id":"themes/varaint/source/banner/3.jpg","hash":"0288742e73b297a6fb876a5940e2c5b246d4d508","modified":1486530834000},{"_id":"themes/varaint/source/banner/4.jpg","hash":"749369b3180ad319cab78e6b3f34f717939b32b2","modified":1486530719000}],"Category":[],"Data":[],"Page":[{"title":"About XunFeng","_content":"有的人心里，\n藏着一片幽暗森林；\n有的人心里，\n留着一个光亮出口。\n<!--more-->\n\n<blockquote class=\"blockquote-center\">学会遗忘</blockquote>","source":"about/about.md","raw":"---\ntitle: About XunFeng\n---\n有的人心里，\n藏着一片幽暗森林；\n有的人心里，\n留着一个光亮出口。\n<!--more-->\n\n<blockquote class=\"blockquote-center\">学会遗忘</blockquote>","date":"2017-11-25T13:40:43.226Z","updated":"2017-05-02T12:33:48.000Z","path":"about/about.html","comments":1,"layout":"page","_id":"cjakphl1m0001ttwpv9ce0dm5","content":"<p>有的人心里，<br>藏着一片幽暗森林；<br>有的人心里，<br>留着一个光亮出口。<br><a id=\"more\"></a></p>\n<blockquote class=\"blockquote-center\">学会遗忘</blockquote>","site":{"data":{}},"excerpt":"<p>有的人心里，<br>藏着一片幽暗森林；<br>有的人心里，<br>留着一个光亮出口。<br>","more":"</p>\n<blockquote class=\"blockquote-center\">学会遗忘</blockquote>"},{"title":"categories","date":"2016-11-20T16:08:38.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-11-21 00:08:38\ntype: \"categories\"\n---\n","updated":"2016-11-20T16:09:02.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjakphl1p0003ttwpm1xebcj4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2016-11-20T16:07:39.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-11-21 00:07:39\ntype: \"tags\"\n---\n","updated":"2016-11-21T16:11:58.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjakphl1w0006ttwprohwykr9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JavaScript设计模式","date":"2017-06-05T02:55:35.000Z","_content":"学不会啊。。。\n<!--more-->\n\n### 设计模式\n\n#### 链式调用\n```js\nvar Func = function () {}\n```","source":"_posts/JavaScript设计模式.md","raw":"---\ntitle: JavaScript设计模式\ndate: 2017-06-05 10:55:35\ntags:\n  - JavaScript\n---\n学不会啊。。。\n<!--more-->\n\n### 设计模式\n\n#### 链式调用\n```js\nvar Func = function () {}\n```","slug":"JavaScript设计模式","published":1,"updated":"2017-07-29T07:12:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl1h0000ttwpn8k7cis0","content":"<p>学不会啊。。。<br><a id=\"more\"></a></p>\n<h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><h4 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h4><pre><code class=\"js\">var Func = function () {}\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>学不会啊。。。<br>","more":"</p>\n<h3 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h3><h4 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h4><pre><code class=\"js\">var Func = function () {}\n</code></pre>"},{"title":"ES6的学习（一）","date":"2017-02-18T14:03:07.000Z","_content":"\n关于ES6的学习\n<!--more-->\n\n### ES5 => ES6\n---\n##### 箭头函数\n- 与函数表达式相比，箭头函数有更短的语法。\n\n```js\n\tfunction (i) { return i * 2} //ES5\n\t(i) => i * 2\t//ES6\n```\n复杂时需要`{}`包裹\n```js\n\tfunction (i, j) {\n\t\ti++\n\t\tj++\n\t\treturn i + j\n\t}  // ES5\n\t(i, j) => {i++, j++, return i + j} // ES6\n```\n- 箭头函数没有自身的this，从外层继承this。\n- 箭头函数通常是匿名的。\n\n\n ##### 块级作用域\n - ES5中只有全局作用域与函数作用域,因此内层变量将会覆盖外层变量\n - let 提供块级作用域,let命名的变量只在当前块内起作用\n - const 声明的是常量，不可更改\n\n```js\n  var a = 1\n  var b = 2\n  var c = 3\n  if (true) {\n    var a = 10  // 函数作用域\n    let b = 20  // if块内的作用域\n        c = 30  // es5解决方法\n    console.log('a:' + a)\n    console.log('b:' + b)\n    console.log('c:' + c)\n  }\n  console.log('a:' + a)\n  console.log('b:' + b)\n  console.log('c:' + c)\n```\nvar声明的变量在循环时新值会覆盖旧值，导致输出的变量都为最终值\n```js\nvar a = []\nfor (var i = 0; i < 9; i++) {\n  a[i] = function () {\n\t\tconsole.log(i)\n\t}\n}\na[2](); // 9\n```\nES5中利用闭包解决这一问题\n```js\nfunction test (index) {\n\t\tvar testback = function () {\n\t\t\tconsole.log(index)\n\t\t}\n\t\treturn testback\n}\nvar a = []\nfor (var i = 0; i < 9; i++) {\n  a[i] = test(i)\n}\na[2]()\n```\nES6中仅仅使用let即可解决\n```js\nvar a = []\nfor (let i = 0; i < 9; i++) {\n  a[i] = function () {\n\t\tconsole.log(i)\n\t}\n}\na[2](); // 2\n```\nconst声明常量\n```js\nconst a = 1\na = 10\nconsole.log(a)\n```\n\n##### 模版字符串\n- ES5中，当需要插入大量html文档时需要引用template插件或是用大量‘+’连接\n- 模版字符串可直接用'``'标识起始\n- 模板字符串可以包含嵌入式表达式,对象字面量,甚至是函数\n\n```js\nvar myName = 'xunfeng'\nconsole.log(`your name is ${myName}`) // your name is xunfeng\n\nvar people = {\n  name: 'xunfeng',\n  age: 20\n}\nconsole.log(`your name is ${people.name}, your age is ${people.age}`)\n// your name is xunfeng, your age is 20\n\nfunction fn () {\n  return 'function'\n}\nconsole.log(`可以嵌套函数：${fn()}`)\n```\n- 模板字符串可以在表达式内进行数学运算\n\n```js\nvar a = 10\nvar b = 20\nconsole.log(`a+b=${a+b}`) //a+b=30\n```\n- 模板字符串内保留空格，不需要换行符即可换行\n\n```js\nconsole.log(`第一行\n第二行`)\n// 第一行\n// 第二行\n```\n\n#####  数值扩展 Numeric Literals\n- 支持二进制(0b)和八进制(0o)新写法\n\n```js\n0b111110111 === 503 // true\n0o767 === 503 // true\n\n将二进制或八进制转换成十进制\nNumber('0b111')  // 7\nNumber('0o10')  // 8\n```\n- 新的方法\n\n```js\nNumber.isFinite() // 检查一个数值是否为有限\nNumber.isNaN()  // 检查一个数值是否为NaN\nNumber.isInteger()  // 检查一个数值是否为整数\nNumber.EPSILON  // 极小的常量，设定的误差范围\n```\n- Math对象的扩展\n\n```js\nMath.trunc()  // 去除一个数的小数部分，返回整数部分\nMath.sign() // 判断一个数到底是正数、负数、还是零\nMath.cbrt() // 用于计算一个数的立方根\nMath.hypot() // 返回所有参数的平方和的平方根\nMath.expm1() // Math.expm1(x)返回ex - 1，即Math.exp(x) - 1\nMath.log1p() // Math.log1p(x)方法返回1 + x的自然对数\nMath.log10() // Math.log10(x)返回以10为底的x的对数\nMath.log2() // Math.log2(x)返回以2为底的x的对数\nMath.sinh(x) // 返回x的双曲正弦（hyperbolic sine）\nMath.cosh(x) // 返回x的双曲余弦（hyperbolic cosine）\nMath.tanh(x) // 返回x的双曲正切（hyperbolic tangent）\nMath.asinh(x) // 返回x的反双曲正弦（inverse hyperbolic sine）\nMath.acosh(x) // 返回x的反双曲余弦（inverse hyperbolic cosine）\nMath.atanh(x) // 返回x的反双曲正切（inverse hyperbolic tangent）\n```\n- 指数运算符 **\n\n```js\nconsole.log(2 ** 3) // 8\n```\n\n##### 对象部分扩展\n- 变量和函数可直接作为对象的属性和方法\n\n```js\n<!-- ES6 -->\nvar object = {\n  value: 42,\n  toString() {\n    return this.value\n  }\n}\nconsole.log(object.toString() === 42) // true\n\n<!-- ES5 -->\nvar object = {\n  value: 42,\n  toString: function toString() {\n    return this.value\n  }\n}\n\nconsole.log(object.toString() === 42) // true\n```\n- 计算属性名可以用变量当做对象的属性名\n\n```js\nvar computed = 'calc'\nvar comFn = {\n  [computed + 'xun']: 'hi',\n  [computed + 'feng']: 'hello'\n}\nconsole.log(comFn['calcxun']) // hi\nconsole.log(comFn['calcfeng']) // hello\n```\n\n##### 解构\n- 允许从数组或对象中提取数据并对变量赋值\n\n```js\nvar a = 1\nvar b = 2\nvar c = {a, b}\nconsole.log(c) // {a: 1, b: 2}\n\nvar c = {a: 1, b: 2}\nvar {a, b} = c\nconsole.log(a, b) // 1 2\n```\n\n##### 默认参数 default\n- ES6可以指定默认参数在arguments中\n\n```js\nfunction myFn(mes = 'hello') {\n  console.log(mes)\n}\nmyFn(); // hello\nmyFn('hi'); // hi\n```\n\n##### 其他参数 rest\n- 允许将部分参数作为一个单独的数组\n\n```js\nfunction myFn(a, ...b) {\n  var result = a\n   for(let i = 0; i<b.length; i++) {\n     result += b[i]\n   }\n   return result\n}\nconsole.log(myFn(1,2,3,4)) // 10\n```\n\n##### 迭代器 iterators && for of\n- 可以直接遍历容器的内容\n\n```js\nvar a=['x', 'y', 'z']\nfor (let i of a){\n  console.log(i)  // x y z\n}\n```\n\n##### 类 classes\n- constructor(构造方法)\n创建实例对象时设定的属性\n- extends(继承)\nclass之间可以通过extends相互继承，相比于原形链更简洁易懂\n- super\n  在子类constructor中调用父类的constructor\n- getter && setter\n在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n- static 静态方法\n不会被实例对象继承，只能通过类或类继承来调用\n\n```js\nclass student {\n  constructor(name, age) {\n    this.name = name\n    this.age = age\n  }\n  getName () {\n    console.log(this.name)\n  }\n  get myAge() {\n    return this.age\n  }\n  set myAge(value) {\n    this._age = value\n  }\n  static bar() {\n    console.log('static')\n  }\n}\n// 创建实例对象\nvar xun = new student('xun', 20)\nxun.getName() // xun\nxun.bar() // TypeError: xun.bar is not a function. (In 'xun.bar()', 'xun.bar' is undefined)\nstudent.bar() // static\n// 继承\nclass Tom extends student {\n  constructor(name, age, sex) {\n    super(name, age)\n    this.sex = sex\n  }\n}\nvar tom = new Tom('tom', 20, 'man')\nconsole.log(tom)  // 实例对象属性\ntom.myAge = 22\nconsole.log(tom._age) // 22\nconsole.log(tom.myAge) // 20\n```\n\n##### 模块 modules\n- export 暴露对外接口\n- import 导入其他模块接口\n\n```js\n<!-- export.js -->\n//命名导出\nexport var foo = ...\nexport let bar = ...\nexport const MY_CONST = ...\n\nexport function myFunc() {\n   ...\n}\nexport function* myGeneratorFunc() {\n   ...\n}\nexport class MyClass {\n   ...\n}\n// default 导出\nexport default 123\nexport default function (x) {\n   return x\n}\nexport default x => x;\nexport default class {\n   constructor(x, y) {\n       this.x = x\n       this.y = y\n   }\n};\n//也可以自己列出所有导出内容\nconst MY_CONST = ...\nfunction myFunc() {\n   ...\n}\n\nexport { MY_CONST, myFunc }\n//或者在导出的时候给他们改个名字\nexport { MY_CONST as THE_CONST, myFunc as theFunc }\n\n//还可以导出从其他地方导入的模块\nexport * from 'src/other_module'\nexport { foo, bar } from 'src/other_module'\nexport { foo as myFoo, bar } from 'src/other_module'\n\n<!-- import.js -->\n\n// Default exports and named exports\nimport theDefault, { named1, named2 } from 'src/mylib'\nimport theDefault from 'src/mylib'\nimport { named1, named2 } from 'src/mylib'\n\n// Renaming: import named1 as myNamed1\nimport { named1 as myNamed1, named2 } from 'src/mylib'\n\n// Importing the module as an object\n// (with one property per named export)\nimport * as mylib from 'src/mylib'\n\n// Only load the module, don’t import anything\nimport 'src/mylib'\n```\n\n##### 参考链接\n[30分钟掌握ES6/ES2015核心内容](http://www.jianshu.com/p/ebfeb687eb70)\n[ECMAScript 6 入门](http://es6.ruanyifeng.com/?search=Spread&x=0&y=0)\n[ ECMAScript 6 equivalents in ES5](https://github.com/addyosmani/es6-equivalents-in-es5/blob/master/README.md#classes)\n","source":"_posts/ES6与ES5.md","raw":"---\ntitle: ES6的学习（一）\ndate: 2017-02-18 22:03:07\ntags:\n  - javascript\n  - ES6\n  - ES5\n---\n\n关于ES6的学习\n<!--more-->\n\n### ES5 => ES6\n---\n##### 箭头函数\n- 与函数表达式相比，箭头函数有更短的语法。\n\n```js\n\tfunction (i) { return i * 2} //ES5\n\t(i) => i * 2\t//ES6\n```\n复杂时需要`{}`包裹\n```js\n\tfunction (i, j) {\n\t\ti++\n\t\tj++\n\t\treturn i + j\n\t}  // ES5\n\t(i, j) => {i++, j++, return i + j} // ES6\n```\n- 箭头函数没有自身的this，从外层继承this。\n- 箭头函数通常是匿名的。\n\n\n ##### 块级作用域\n - ES5中只有全局作用域与函数作用域,因此内层变量将会覆盖外层变量\n - let 提供块级作用域,let命名的变量只在当前块内起作用\n - const 声明的是常量，不可更改\n\n```js\n  var a = 1\n  var b = 2\n  var c = 3\n  if (true) {\n    var a = 10  // 函数作用域\n    let b = 20  // if块内的作用域\n        c = 30  // es5解决方法\n    console.log('a:' + a)\n    console.log('b:' + b)\n    console.log('c:' + c)\n  }\n  console.log('a:' + a)\n  console.log('b:' + b)\n  console.log('c:' + c)\n```\nvar声明的变量在循环时新值会覆盖旧值，导致输出的变量都为最终值\n```js\nvar a = []\nfor (var i = 0; i < 9; i++) {\n  a[i] = function () {\n\t\tconsole.log(i)\n\t}\n}\na[2](); // 9\n```\nES5中利用闭包解决这一问题\n```js\nfunction test (index) {\n\t\tvar testback = function () {\n\t\t\tconsole.log(index)\n\t\t}\n\t\treturn testback\n}\nvar a = []\nfor (var i = 0; i < 9; i++) {\n  a[i] = test(i)\n}\na[2]()\n```\nES6中仅仅使用let即可解决\n```js\nvar a = []\nfor (let i = 0; i < 9; i++) {\n  a[i] = function () {\n\t\tconsole.log(i)\n\t}\n}\na[2](); // 2\n```\nconst声明常量\n```js\nconst a = 1\na = 10\nconsole.log(a)\n```\n\n##### 模版字符串\n- ES5中，当需要插入大量html文档时需要引用template插件或是用大量‘+’连接\n- 模版字符串可直接用'``'标识起始\n- 模板字符串可以包含嵌入式表达式,对象字面量,甚至是函数\n\n```js\nvar myName = 'xunfeng'\nconsole.log(`your name is ${myName}`) // your name is xunfeng\n\nvar people = {\n  name: 'xunfeng',\n  age: 20\n}\nconsole.log(`your name is ${people.name}, your age is ${people.age}`)\n// your name is xunfeng, your age is 20\n\nfunction fn () {\n  return 'function'\n}\nconsole.log(`可以嵌套函数：${fn()}`)\n```\n- 模板字符串可以在表达式内进行数学运算\n\n```js\nvar a = 10\nvar b = 20\nconsole.log(`a+b=${a+b}`) //a+b=30\n```\n- 模板字符串内保留空格，不需要换行符即可换行\n\n```js\nconsole.log(`第一行\n第二行`)\n// 第一行\n// 第二行\n```\n\n#####  数值扩展 Numeric Literals\n- 支持二进制(0b)和八进制(0o)新写法\n\n```js\n0b111110111 === 503 // true\n0o767 === 503 // true\n\n将二进制或八进制转换成十进制\nNumber('0b111')  // 7\nNumber('0o10')  // 8\n```\n- 新的方法\n\n```js\nNumber.isFinite() // 检查一个数值是否为有限\nNumber.isNaN()  // 检查一个数值是否为NaN\nNumber.isInteger()  // 检查一个数值是否为整数\nNumber.EPSILON  // 极小的常量，设定的误差范围\n```\n- Math对象的扩展\n\n```js\nMath.trunc()  // 去除一个数的小数部分，返回整数部分\nMath.sign() // 判断一个数到底是正数、负数、还是零\nMath.cbrt() // 用于计算一个数的立方根\nMath.hypot() // 返回所有参数的平方和的平方根\nMath.expm1() // Math.expm1(x)返回ex - 1，即Math.exp(x) - 1\nMath.log1p() // Math.log1p(x)方法返回1 + x的自然对数\nMath.log10() // Math.log10(x)返回以10为底的x的对数\nMath.log2() // Math.log2(x)返回以2为底的x的对数\nMath.sinh(x) // 返回x的双曲正弦（hyperbolic sine）\nMath.cosh(x) // 返回x的双曲余弦（hyperbolic cosine）\nMath.tanh(x) // 返回x的双曲正切（hyperbolic tangent）\nMath.asinh(x) // 返回x的反双曲正弦（inverse hyperbolic sine）\nMath.acosh(x) // 返回x的反双曲余弦（inverse hyperbolic cosine）\nMath.atanh(x) // 返回x的反双曲正切（inverse hyperbolic tangent）\n```\n- 指数运算符 **\n\n```js\nconsole.log(2 ** 3) // 8\n```\n\n##### 对象部分扩展\n- 变量和函数可直接作为对象的属性和方法\n\n```js\n<!-- ES6 -->\nvar object = {\n  value: 42,\n  toString() {\n    return this.value\n  }\n}\nconsole.log(object.toString() === 42) // true\n\n<!-- ES5 -->\nvar object = {\n  value: 42,\n  toString: function toString() {\n    return this.value\n  }\n}\n\nconsole.log(object.toString() === 42) // true\n```\n- 计算属性名可以用变量当做对象的属性名\n\n```js\nvar computed = 'calc'\nvar comFn = {\n  [computed + 'xun']: 'hi',\n  [computed + 'feng']: 'hello'\n}\nconsole.log(comFn['calcxun']) // hi\nconsole.log(comFn['calcfeng']) // hello\n```\n\n##### 解构\n- 允许从数组或对象中提取数据并对变量赋值\n\n```js\nvar a = 1\nvar b = 2\nvar c = {a, b}\nconsole.log(c) // {a: 1, b: 2}\n\nvar c = {a: 1, b: 2}\nvar {a, b} = c\nconsole.log(a, b) // 1 2\n```\n\n##### 默认参数 default\n- ES6可以指定默认参数在arguments中\n\n```js\nfunction myFn(mes = 'hello') {\n  console.log(mes)\n}\nmyFn(); // hello\nmyFn('hi'); // hi\n```\n\n##### 其他参数 rest\n- 允许将部分参数作为一个单独的数组\n\n```js\nfunction myFn(a, ...b) {\n  var result = a\n   for(let i = 0; i<b.length; i++) {\n     result += b[i]\n   }\n   return result\n}\nconsole.log(myFn(1,2,3,4)) // 10\n```\n\n##### 迭代器 iterators && for of\n- 可以直接遍历容器的内容\n\n```js\nvar a=['x', 'y', 'z']\nfor (let i of a){\n  console.log(i)  // x y z\n}\n```\n\n##### 类 classes\n- constructor(构造方法)\n创建实例对象时设定的属性\n- extends(继承)\nclass之间可以通过extends相互继承，相比于原形链更简洁易懂\n- super\n  在子类constructor中调用父类的constructor\n- getter && setter\n在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n- static 静态方法\n不会被实例对象继承，只能通过类或类继承来调用\n\n```js\nclass student {\n  constructor(name, age) {\n    this.name = name\n    this.age = age\n  }\n  getName () {\n    console.log(this.name)\n  }\n  get myAge() {\n    return this.age\n  }\n  set myAge(value) {\n    this._age = value\n  }\n  static bar() {\n    console.log('static')\n  }\n}\n// 创建实例对象\nvar xun = new student('xun', 20)\nxun.getName() // xun\nxun.bar() // TypeError: xun.bar is not a function. (In 'xun.bar()', 'xun.bar' is undefined)\nstudent.bar() // static\n// 继承\nclass Tom extends student {\n  constructor(name, age, sex) {\n    super(name, age)\n    this.sex = sex\n  }\n}\nvar tom = new Tom('tom', 20, 'man')\nconsole.log(tom)  // 实例对象属性\ntom.myAge = 22\nconsole.log(tom._age) // 22\nconsole.log(tom.myAge) // 20\n```\n\n##### 模块 modules\n- export 暴露对外接口\n- import 导入其他模块接口\n\n```js\n<!-- export.js -->\n//命名导出\nexport var foo = ...\nexport let bar = ...\nexport const MY_CONST = ...\n\nexport function myFunc() {\n   ...\n}\nexport function* myGeneratorFunc() {\n   ...\n}\nexport class MyClass {\n   ...\n}\n// default 导出\nexport default 123\nexport default function (x) {\n   return x\n}\nexport default x => x;\nexport default class {\n   constructor(x, y) {\n       this.x = x\n       this.y = y\n   }\n};\n//也可以自己列出所有导出内容\nconst MY_CONST = ...\nfunction myFunc() {\n   ...\n}\n\nexport { MY_CONST, myFunc }\n//或者在导出的时候给他们改个名字\nexport { MY_CONST as THE_CONST, myFunc as theFunc }\n\n//还可以导出从其他地方导入的模块\nexport * from 'src/other_module'\nexport { foo, bar } from 'src/other_module'\nexport { foo as myFoo, bar } from 'src/other_module'\n\n<!-- import.js -->\n\n// Default exports and named exports\nimport theDefault, { named1, named2 } from 'src/mylib'\nimport theDefault from 'src/mylib'\nimport { named1, named2 } from 'src/mylib'\n\n// Renaming: import named1 as myNamed1\nimport { named1 as myNamed1, named2 } from 'src/mylib'\n\n// Importing the module as an object\n// (with one property per named export)\nimport * as mylib from 'src/mylib'\n\n// Only load the module, don’t import anything\nimport 'src/mylib'\n```\n\n##### 参考链接\n[30分钟掌握ES6/ES2015核心内容](http://www.jianshu.com/p/ebfeb687eb70)\n[ECMAScript 6 入门](http://es6.ruanyifeng.com/?search=Spread&x=0&y=0)\n[ ECMAScript 6 equivalents in ES5](https://github.com/addyosmani/es6-equivalents-in-es5/blob/master/README.md#classes)\n","slug":"ES6与ES5","published":1,"updated":"2017-10-15T02:53:45.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl1n0002ttwppn2f81c7","content":"<p>关于ES6的学习<br><a id=\"more\"></a></p>\n<h3 id=\"ES5-gt-ES6\"><a href=\"#ES5-gt-ES6\" class=\"headerlink\" title=\"ES5 =&gt; ES6\"></a>ES5 =&gt; ES6</h3><hr>\n<h5 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h5><ul>\n<li>与函数表达式相比，箭头函数有更短的语法。</li>\n</ul>\n<pre><code class=\"js\">    function (i) { return i * 2} //ES5\n    (i) =&gt; i * 2    //ES6\n</code></pre>\n<p>复杂时需要<code>{}</code>包裹</p>\n<pre><code class=\"js\">    function (i, j) {\n        i++\n        j++\n        return i + j\n    }  // ES5\n    (i, j) =&gt; {i++, j++, return i + j} // ES6\n</code></pre>\n<ul>\n<li>箭头函数没有自身的this，从外层继承this。</li>\n<li>箭头函数通常是匿名的。</li>\n</ul>\n<h5 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h5><ul>\n<li>ES5中只有全局作用域与函数作用域,因此内层变量将会覆盖外层变量</li>\n<li>let 提供块级作用域,let命名的变量只在当前块内起作用</li>\n<li>const 声明的是常量，不可更改</li>\n</ul>\n<pre><code class=\"js\">  var a = 1\n  var b = 2\n  var c = 3\n  if (true) {\n    var a = 10  // 函数作用域\n    let b = 20  // if块内的作用域\n        c = 30  // es5解决方法\n    console.log(&#39;a:&#39; + a)\n    console.log(&#39;b:&#39; + b)\n    console.log(&#39;c:&#39; + c)\n  }\n  console.log(&#39;a:&#39; + a)\n  console.log(&#39;b:&#39; + b)\n  console.log(&#39;c:&#39; + c)\n</code></pre>\n<p>var声明的变量在循环时新值会覆盖旧值，导致输出的变量都为最终值</p>\n<pre><code class=\"js\">var a = []\nfor (var i = 0; i &lt; 9; i++) {\n  a[i] = function () {\n        console.log(i)\n    }\n}\na[2](); // 9\n</code></pre>\n<p>ES5中利用闭包解决这一问题</p>\n<pre><code class=\"js\">function test (index) {\n        var testback = function () {\n            console.log(index)\n        }\n        return testback\n}\nvar a = []\nfor (var i = 0; i &lt; 9; i++) {\n  a[i] = test(i)\n}\na[2]()\n</code></pre>\n<p>ES6中仅仅使用let即可解决</p>\n<pre><code class=\"js\">var a = []\nfor (let i = 0; i &lt; 9; i++) {\n  a[i] = function () {\n        console.log(i)\n    }\n}\na[2](); // 2\n</code></pre>\n<p>const声明常量</p>\n<pre><code class=\"js\">const a = 1\na = 10\nconsole.log(a)\n</code></pre>\n<h5 id=\"模版字符串\"><a href=\"#模版字符串\" class=\"headerlink\" title=\"模版字符串\"></a>模版字符串</h5><ul>\n<li>ES5中，当需要插入大量html文档时需要引用template插件或是用大量‘+’连接</li>\n<li>模版字符串可直接用’``’标识起始</li>\n<li>模板字符串可以包含嵌入式表达式,对象字面量,甚至是函数</li>\n</ul>\n<pre><code class=\"js\">var myName = &#39;xunfeng&#39;\nconsole.log(`your name is ${myName}`) // your name is xunfeng\n\nvar people = {\n  name: &#39;xunfeng&#39;,\n  age: 20\n}\nconsole.log(`your name is ${people.name}, your age is ${people.age}`)\n// your name is xunfeng, your age is 20\n\nfunction fn () {\n  return &#39;function&#39;\n}\nconsole.log(`可以嵌套函数：${fn()}`)\n</code></pre>\n<ul>\n<li>模板字符串可以在表达式内进行数学运算</li>\n</ul>\n<pre><code class=\"js\">var a = 10\nvar b = 20\nconsole.log(`a+b=${a+b}`) //a+b=30\n</code></pre>\n<ul>\n<li>模板字符串内保留空格，不需要换行符即可换行</li>\n</ul>\n<pre><code class=\"js\">console.log(`第一行\n第二行`)\n// 第一行\n// 第二行\n</code></pre>\n<h5 id=\"数值扩展-Numeric-Literals\"><a href=\"#数值扩展-Numeric-Literals\" class=\"headerlink\" title=\"数值扩展 Numeric Literals\"></a>数值扩展 Numeric Literals</h5><ul>\n<li>支持二进制(0b)和八进制(0o)新写法</li>\n</ul>\n<pre><code class=\"js\">0b111110111 === 503 // true\n0o767 === 503 // true\n\n将二进制或八进制转换成十进制\nNumber(&#39;0b111&#39;)  // 7\nNumber(&#39;0o10&#39;)  // 8\n</code></pre>\n<ul>\n<li>新的方法</li>\n</ul>\n<pre><code class=\"js\">Number.isFinite() // 检查一个数值是否为有限\nNumber.isNaN()  // 检查一个数值是否为NaN\nNumber.isInteger()  // 检查一个数值是否为整数\nNumber.EPSILON  // 极小的常量，设定的误差范围\n</code></pre>\n<ul>\n<li>Math对象的扩展</li>\n</ul>\n<pre><code class=\"js\">Math.trunc()  // 去除一个数的小数部分，返回整数部分\nMath.sign() // 判断一个数到底是正数、负数、还是零\nMath.cbrt() // 用于计算一个数的立方根\nMath.hypot() // 返回所有参数的平方和的平方根\nMath.expm1() // Math.expm1(x)返回ex - 1，即Math.exp(x) - 1\nMath.log1p() // Math.log1p(x)方法返回1 + x的自然对数\nMath.log10() // Math.log10(x)返回以10为底的x的对数\nMath.log2() // Math.log2(x)返回以2为底的x的对数\nMath.sinh(x) // 返回x的双曲正弦（hyperbolic sine）\nMath.cosh(x) // 返回x的双曲余弦（hyperbolic cosine）\nMath.tanh(x) // 返回x的双曲正切（hyperbolic tangent）\nMath.asinh(x) // 返回x的反双曲正弦（inverse hyperbolic sine）\nMath.acosh(x) // 返回x的反双曲余弦（inverse hyperbolic cosine）\nMath.atanh(x) // 返回x的反双曲正切（inverse hyperbolic tangent）\n</code></pre>\n<ul>\n<li>指数运算符 **</li>\n</ul>\n<pre><code class=\"js\">console.log(2 ** 3) // 8\n</code></pre>\n<h5 id=\"对象部分扩展\"><a href=\"#对象部分扩展\" class=\"headerlink\" title=\"对象部分扩展\"></a>对象部分扩展</h5><ul>\n<li>变量和函数可直接作为对象的属性和方法</li>\n</ul>\n<pre><code class=\"js\">&lt;!-- ES6 --&gt;\nvar object = {\n  value: 42,\n  toString() {\n    return this.value\n  }\n}\nconsole.log(object.toString() === 42) // true\n\n&lt;!-- ES5 --&gt;\nvar object = {\n  value: 42,\n  toString: function toString() {\n    return this.value\n  }\n}\n\nconsole.log(object.toString() === 42) // true\n</code></pre>\n<ul>\n<li>计算属性名可以用变量当做对象的属性名</li>\n</ul>\n<pre><code class=\"js\">var computed = &#39;calc&#39;\nvar comFn = {\n  [computed + &#39;xun&#39;]: &#39;hi&#39;,\n  [computed + &#39;feng&#39;]: &#39;hello&#39;\n}\nconsole.log(comFn[&#39;calcxun&#39;]) // hi\nconsole.log(comFn[&#39;calcfeng&#39;]) // hello\n</code></pre>\n<h5 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h5><ul>\n<li>允许从数组或对象中提取数据并对变量赋值</li>\n</ul>\n<pre><code class=\"js\">var a = 1\nvar b = 2\nvar c = {a, b}\nconsole.log(c) // {a: 1, b: 2}\n\nvar c = {a: 1, b: 2}\nvar {a, b} = c\nconsole.log(a, b) // 1 2\n</code></pre>\n<h5 id=\"默认参数-default\"><a href=\"#默认参数-default\" class=\"headerlink\" title=\"默认参数 default\"></a>默认参数 default</h5><ul>\n<li>ES6可以指定默认参数在arguments中</li>\n</ul>\n<pre><code class=\"js\">function myFn(mes = &#39;hello&#39;) {\n  console.log(mes)\n}\nmyFn(); // hello\nmyFn(&#39;hi&#39;); // hi\n</code></pre>\n<h5 id=\"其他参数-rest\"><a href=\"#其他参数-rest\" class=\"headerlink\" title=\"其他参数 rest\"></a>其他参数 rest</h5><ul>\n<li>允许将部分参数作为一个单独的数组</li>\n</ul>\n<pre><code class=\"js\">function myFn(a, ...b) {\n  var result = a\n   for(let i = 0; i&lt;b.length; i++) {\n     result += b[i]\n   }\n   return result\n}\nconsole.log(myFn(1,2,3,4)) // 10\n</code></pre>\n<h5 id=\"迭代器-iterators-amp-amp-for-of\"><a href=\"#迭代器-iterators-amp-amp-for-of\" class=\"headerlink\" title=\"迭代器 iterators &amp;&amp; for of\"></a>迭代器 iterators &amp;&amp; for of</h5><ul>\n<li>可以直接遍历容器的内容</li>\n</ul>\n<pre><code class=\"js\">var a=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]\nfor (let i of a){\n  console.log(i)  // x y z\n}\n</code></pre>\n<h5 id=\"类-classes\"><a href=\"#类-classes\" class=\"headerlink\" title=\"类 classes\"></a>类 classes</h5><ul>\n<li>constructor(构造方法)<br>创建实例对象时设定的属性</li>\n<li>extends(继承)<br>class之间可以通过extends相互继承，相比于原形链更简洁易懂</li>\n<li>super<br>在子类constructor中调用父类的constructor</li>\n<li>getter &amp;&amp; setter<br>在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</li>\n<li>static 静态方法<br>不会被实例对象继承，只能通过类或类继承来调用</li>\n</ul>\n<pre><code class=\"js\">class student {\n  constructor(name, age) {\n    this.name = name\n    this.age = age\n  }\n  getName () {\n    console.log(this.name)\n  }\n  get myAge() {\n    return this.age\n  }\n  set myAge(value) {\n    this._age = value\n  }\n  static bar() {\n    console.log(&#39;static&#39;)\n  }\n}\n// 创建实例对象\nvar xun = new student(&#39;xun&#39;, 20)\nxun.getName() // xun\nxun.bar() // TypeError: xun.bar is not a function. (In &#39;xun.bar()&#39;, &#39;xun.bar&#39; is undefined)\nstudent.bar() // static\n// 继承\nclass Tom extends student {\n  constructor(name, age, sex) {\n    super(name, age)\n    this.sex = sex\n  }\n}\nvar tom = new Tom(&#39;tom&#39;, 20, &#39;man&#39;)\nconsole.log(tom)  // 实例对象属性\ntom.myAge = 22\nconsole.log(tom._age) // 22\nconsole.log(tom.myAge) // 20\n</code></pre>\n<h5 id=\"模块-modules\"><a href=\"#模块-modules\" class=\"headerlink\" title=\"模块 modules\"></a>模块 modules</h5><ul>\n<li>export 暴露对外接口</li>\n<li>import 导入其他模块接口</li>\n</ul>\n<pre><code class=\"js\">&lt;!-- export.js --&gt;\n//命名导出\nexport var foo = ...\nexport let bar = ...\nexport const MY_CONST = ...\n\nexport function myFunc() {\n   ...\n}\nexport function* myGeneratorFunc() {\n   ...\n}\nexport class MyClass {\n   ...\n}\n// default 导出\nexport default 123\nexport default function (x) {\n   return x\n}\nexport default x =&gt; x;\nexport default class {\n   constructor(x, y) {\n       this.x = x\n       this.y = y\n   }\n};\n//也可以自己列出所有导出内容\nconst MY_CONST = ...\nfunction myFunc() {\n   ...\n}\n\nexport { MY_CONST, myFunc }\n//或者在导出的时候给他们改个名字\nexport { MY_CONST as THE_CONST, myFunc as theFunc }\n\n//还可以导出从其他地方导入的模块\nexport * from &#39;src/other_module&#39;\nexport { foo, bar } from &#39;src/other_module&#39;\nexport { foo as myFoo, bar } from &#39;src/other_module&#39;\n\n&lt;!-- import.js --&gt;\n\n// Default exports and named exports\nimport theDefault, { named1, named2 } from &#39;src/mylib&#39;\nimport theDefault from &#39;src/mylib&#39;\nimport { named1, named2 } from &#39;src/mylib&#39;\n\n// Renaming: import named1 as myNamed1\nimport { named1 as myNamed1, named2 } from &#39;src/mylib&#39;\n\n// Importing the module as an object\n// (with one property per named export)\nimport * as mylib from &#39;src/mylib&#39;\n\n// Only load the module, don’t import anything\nimport &#39;src/mylib&#39;\n</code></pre>\n<h5 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h5><p><a href=\"http://www.jianshu.com/p/ebfeb687eb70\" target=\"_blank\" rel=\"external\">30分钟掌握ES6/ES2015核心内容</a><br><a href=\"http://es6.ruanyifeng.com/?search=Spread&amp;x=0&amp;y=0\" target=\"_blank\" rel=\"external\">ECMAScript 6 入门</a><br><a href=\"https://github.com/addyosmani/es6-equivalents-in-es5/blob/master/README.md#classes\" target=\"_blank\" rel=\"external\"> ECMAScript 6 equivalents in ES5</a></p>\n","site":{"data":{}},"excerpt":"<p>关于ES6的学习<br>","more":"</p>\n<h3 id=\"ES5-gt-ES6\"><a href=\"#ES5-gt-ES6\" class=\"headerlink\" title=\"ES5 =&gt; ES6\"></a>ES5 =&gt; ES6</h3><hr>\n<h5 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h5><ul>\n<li>与函数表达式相比，箭头函数有更短的语法。</li>\n</ul>\n<pre><code class=\"js\">    function (i) { return i * 2} //ES5\n    (i) =&gt; i * 2    //ES6\n</code></pre>\n<p>复杂时需要<code>{}</code>包裹</p>\n<pre><code class=\"js\">    function (i, j) {\n        i++\n        j++\n        return i + j\n    }  // ES5\n    (i, j) =&gt; {i++, j++, return i + j} // ES6\n</code></pre>\n<ul>\n<li>箭头函数没有自身的this，从外层继承this。</li>\n<li>箭头函数通常是匿名的。</li>\n</ul>\n<h5 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h5><ul>\n<li>ES5中只有全局作用域与函数作用域,因此内层变量将会覆盖外层变量</li>\n<li>let 提供块级作用域,let命名的变量只在当前块内起作用</li>\n<li>const 声明的是常量，不可更改</li>\n</ul>\n<pre><code class=\"js\">  var a = 1\n  var b = 2\n  var c = 3\n  if (true) {\n    var a = 10  // 函数作用域\n    let b = 20  // if块内的作用域\n        c = 30  // es5解决方法\n    console.log(&#39;a:&#39; + a)\n    console.log(&#39;b:&#39; + b)\n    console.log(&#39;c:&#39; + c)\n  }\n  console.log(&#39;a:&#39; + a)\n  console.log(&#39;b:&#39; + b)\n  console.log(&#39;c:&#39; + c)\n</code></pre>\n<p>var声明的变量在循环时新值会覆盖旧值，导致输出的变量都为最终值</p>\n<pre><code class=\"js\">var a = []\nfor (var i = 0; i &lt; 9; i++) {\n  a[i] = function () {\n        console.log(i)\n    }\n}\na[2](); // 9\n</code></pre>\n<p>ES5中利用闭包解决这一问题</p>\n<pre><code class=\"js\">function test (index) {\n        var testback = function () {\n            console.log(index)\n        }\n        return testback\n}\nvar a = []\nfor (var i = 0; i &lt; 9; i++) {\n  a[i] = test(i)\n}\na[2]()\n</code></pre>\n<p>ES6中仅仅使用let即可解决</p>\n<pre><code class=\"js\">var a = []\nfor (let i = 0; i &lt; 9; i++) {\n  a[i] = function () {\n        console.log(i)\n    }\n}\na[2](); // 2\n</code></pre>\n<p>const声明常量</p>\n<pre><code class=\"js\">const a = 1\na = 10\nconsole.log(a)\n</code></pre>\n<h5 id=\"模版字符串\"><a href=\"#模版字符串\" class=\"headerlink\" title=\"模版字符串\"></a>模版字符串</h5><ul>\n<li>ES5中，当需要插入大量html文档时需要引用template插件或是用大量‘+’连接</li>\n<li>模版字符串可直接用’``’标识起始</li>\n<li>模板字符串可以包含嵌入式表达式,对象字面量,甚至是函数</li>\n</ul>\n<pre><code class=\"js\">var myName = &#39;xunfeng&#39;\nconsole.log(`your name is ${myName}`) // your name is xunfeng\n\nvar people = {\n  name: &#39;xunfeng&#39;,\n  age: 20\n}\nconsole.log(`your name is ${people.name}, your age is ${people.age}`)\n// your name is xunfeng, your age is 20\n\nfunction fn () {\n  return &#39;function&#39;\n}\nconsole.log(`可以嵌套函数：${fn()}`)\n</code></pre>\n<ul>\n<li>模板字符串可以在表达式内进行数学运算</li>\n</ul>\n<pre><code class=\"js\">var a = 10\nvar b = 20\nconsole.log(`a+b=${a+b}`) //a+b=30\n</code></pre>\n<ul>\n<li>模板字符串内保留空格，不需要换行符即可换行</li>\n</ul>\n<pre><code class=\"js\">console.log(`第一行\n第二行`)\n// 第一行\n// 第二行\n</code></pre>\n<h5 id=\"数值扩展-Numeric-Literals\"><a href=\"#数值扩展-Numeric-Literals\" class=\"headerlink\" title=\"数值扩展 Numeric Literals\"></a>数值扩展 Numeric Literals</h5><ul>\n<li>支持二进制(0b)和八进制(0o)新写法</li>\n</ul>\n<pre><code class=\"js\">0b111110111 === 503 // true\n0o767 === 503 // true\n\n将二进制或八进制转换成十进制\nNumber(&#39;0b111&#39;)  // 7\nNumber(&#39;0o10&#39;)  // 8\n</code></pre>\n<ul>\n<li>新的方法</li>\n</ul>\n<pre><code class=\"js\">Number.isFinite() // 检查一个数值是否为有限\nNumber.isNaN()  // 检查一个数值是否为NaN\nNumber.isInteger()  // 检查一个数值是否为整数\nNumber.EPSILON  // 极小的常量，设定的误差范围\n</code></pre>\n<ul>\n<li>Math对象的扩展</li>\n</ul>\n<pre><code class=\"js\">Math.trunc()  // 去除一个数的小数部分，返回整数部分\nMath.sign() // 判断一个数到底是正数、负数、还是零\nMath.cbrt() // 用于计算一个数的立方根\nMath.hypot() // 返回所有参数的平方和的平方根\nMath.expm1() // Math.expm1(x)返回ex - 1，即Math.exp(x) - 1\nMath.log1p() // Math.log1p(x)方法返回1 + x的自然对数\nMath.log10() // Math.log10(x)返回以10为底的x的对数\nMath.log2() // Math.log2(x)返回以2为底的x的对数\nMath.sinh(x) // 返回x的双曲正弦（hyperbolic sine）\nMath.cosh(x) // 返回x的双曲余弦（hyperbolic cosine）\nMath.tanh(x) // 返回x的双曲正切（hyperbolic tangent）\nMath.asinh(x) // 返回x的反双曲正弦（inverse hyperbolic sine）\nMath.acosh(x) // 返回x的反双曲余弦（inverse hyperbolic cosine）\nMath.atanh(x) // 返回x的反双曲正切（inverse hyperbolic tangent）\n</code></pre>\n<ul>\n<li>指数运算符 **</li>\n</ul>\n<pre><code class=\"js\">console.log(2 ** 3) // 8\n</code></pre>\n<h5 id=\"对象部分扩展\"><a href=\"#对象部分扩展\" class=\"headerlink\" title=\"对象部分扩展\"></a>对象部分扩展</h5><ul>\n<li>变量和函数可直接作为对象的属性和方法</li>\n</ul>\n<pre><code class=\"js\">&lt;!-- ES6 --&gt;\nvar object = {\n  value: 42,\n  toString() {\n    return this.value\n  }\n}\nconsole.log(object.toString() === 42) // true\n\n&lt;!-- ES5 --&gt;\nvar object = {\n  value: 42,\n  toString: function toString() {\n    return this.value\n  }\n}\n\nconsole.log(object.toString() === 42) // true\n</code></pre>\n<ul>\n<li>计算属性名可以用变量当做对象的属性名</li>\n</ul>\n<pre><code class=\"js\">var computed = &#39;calc&#39;\nvar comFn = {\n  [computed + &#39;xun&#39;]: &#39;hi&#39;,\n  [computed + &#39;feng&#39;]: &#39;hello&#39;\n}\nconsole.log(comFn[&#39;calcxun&#39;]) // hi\nconsole.log(comFn[&#39;calcfeng&#39;]) // hello\n</code></pre>\n<h5 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h5><ul>\n<li>允许从数组或对象中提取数据并对变量赋值</li>\n</ul>\n<pre><code class=\"js\">var a = 1\nvar b = 2\nvar c = {a, b}\nconsole.log(c) // {a: 1, b: 2}\n\nvar c = {a: 1, b: 2}\nvar {a, b} = c\nconsole.log(a, b) // 1 2\n</code></pre>\n<h5 id=\"默认参数-default\"><a href=\"#默认参数-default\" class=\"headerlink\" title=\"默认参数 default\"></a>默认参数 default</h5><ul>\n<li>ES6可以指定默认参数在arguments中</li>\n</ul>\n<pre><code class=\"js\">function myFn(mes = &#39;hello&#39;) {\n  console.log(mes)\n}\nmyFn(); // hello\nmyFn(&#39;hi&#39;); // hi\n</code></pre>\n<h5 id=\"其他参数-rest\"><a href=\"#其他参数-rest\" class=\"headerlink\" title=\"其他参数 rest\"></a>其他参数 rest</h5><ul>\n<li>允许将部分参数作为一个单独的数组</li>\n</ul>\n<pre><code class=\"js\">function myFn(a, ...b) {\n  var result = a\n   for(let i = 0; i&lt;b.length; i++) {\n     result += b[i]\n   }\n   return result\n}\nconsole.log(myFn(1,2,3,4)) // 10\n</code></pre>\n<h5 id=\"迭代器-iterators-amp-amp-for-of\"><a href=\"#迭代器-iterators-amp-amp-for-of\" class=\"headerlink\" title=\"迭代器 iterators &amp;&amp; for of\"></a>迭代器 iterators &amp;&amp; for of</h5><ul>\n<li>可以直接遍历容器的内容</li>\n</ul>\n<pre><code class=\"js\">var a=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]\nfor (let i of a){\n  console.log(i)  // x y z\n}\n</code></pre>\n<h5 id=\"类-classes\"><a href=\"#类-classes\" class=\"headerlink\" title=\"类 classes\"></a>类 classes</h5><ul>\n<li>constructor(构造方法)<br>创建实例对象时设定的属性</li>\n<li>extends(继承)<br>class之间可以通过extends相互继承，相比于原形链更简洁易懂</li>\n<li>super<br>在子类constructor中调用父类的constructor</li>\n<li>getter &amp;&amp; setter<br>在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</li>\n<li>static 静态方法<br>不会被实例对象继承，只能通过类或类继承来调用</li>\n</ul>\n<pre><code class=\"js\">class student {\n  constructor(name, age) {\n    this.name = name\n    this.age = age\n  }\n  getName () {\n    console.log(this.name)\n  }\n  get myAge() {\n    return this.age\n  }\n  set myAge(value) {\n    this._age = value\n  }\n  static bar() {\n    console.log(&#39;static&#39;)\n  }\n}\n// 创建实例对象\nvar xun = new student(&#39;xun&#39;, 20)\nxun.getName() // xun\nxun.bar() // TypeError: xun.bar is not a function. (In &#39;xun.bar()&#39;, &#39;xun.bar&#39; is undefined)\nstudent.bar() // static\n// 继承\nclass Tom extends student {\n  constructor(name, age, sex) {\n    super(name, age)\n    this.sex = sex\n  }\n}\nvar tom = new Tom(&#39;tom&#39;, 20, &#39;man&#39;)\nconsole.log(tom)  // 实例对象属性\ntom.myAge = 22\nconsole.log(tom._age) // 22\nconsole.log(tom.myAge) // 20\n</code></pre>\n<h5 id=\"模块-modules\"><a href=\"#模块-modules\" class=\"headerlink\" title=\"模块 modules\"></a>模块 modules</h5><ul>\n<li>export 暴露对外接口</li>\n<li>import 导入其他模块接口</li>\n</ul>\n<pre><code class=\"js\">&lt;!-- export.js --&gt;\n//命名导出\nexport var foo = ...\nexport let bar = ...\nexport const MY_CONST = ...\n\nexport function myFunc() {\n   ...\n}\nexport function* myGeneratorFunc() {\n   ...\n}\nexport class MyClass {\n   ...\n}\n// default 导出\nexport default 123\nexport default function (x) {\n   return x\n}\nexport default x =&gt; x;\nexport default class {\n   constructor(x, y) {\n       this.x = x\n       this.y = y\n   }\n};\n//也可以自己列出所有导出内容\nconst MY_CONST = ...\nfunction myFunc() {\n   ...\n}\n\nexport { MY_CONST, myFunc }\n//或者在导出的时候给他们改个名字\nexport { MY_CONST as THE_CONST, myFunc as theFunc }\n\n//还可以导出从其他地方导入的模块\nexport * from &#39;src/other_module&#39;\nexport { foo, bar } from &#39;src/other_module&#39;\nexport { foo as myFoo, bar } from &#39;src/other_module&#39;\n\n&lt;!-- import.js --&gt;\n\n// Default exports and named exports\nimport theDefault, { named1, named2 } from &#39;src/mylib&#39;\nimport theDefault from &#39;src/mylib&#39;\nimport { named1, named2 } from &#39;src/mylib&#39;\n\n// Renaming: import named1 as myNamed1\nimport { named1 as myNamed1, named2 } from &#39;src/mylib&#39;\n\n// Importing the module as an object\n// (with one property per named export)\nimport * as mylib from &#39;src/mylib&#39;\n\n// Only load the module, don’t import anything\nimport &#39;src/mylib&#39;\n</code></pre>\n<h5 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h5><p><a href=\"http://www.jianshu.com/p/ebfeb687eb70\" target=\"_blank\" rel=\"external\">30分钟掌握ES6/ES2015核心内容</a><br><a href=\"http://es6.ruanyifeng.com/?search=Spread&amp;x=0&amp;y=0\" target=\"_blank\" rel=\"external\">ECMAScript 6 入门</a><br><a href=\"https://github.com/addyosmani/es6-equivalents-in-es5/blob/master/README.md#classes\" target=\"_blank\" rel=\"external\"> ECMAScript 6 equivalents in ES5</a></p>"},{"title":"Rx入门学习","date":"2017-08-12T06:08:28.000Z","_content":"## RXjs\n\n### Functional Programming\n - Expression, no Statement\n - Pure Function\n - 利用参数保存状态\n\n\n### 建立Observable\n统一订阅\n```js\nobservable.subscribe({\n    next: function(value) {\n        console.log(value)\n    },\n    complete: function() {\n        console.log('complete!');\n    },\n    error: function(error) {\n        console.log(error)\n    }\n});\n```\n- `create`\n```js\n/**\n@param: `callback function`\n*/\nvar observable = Rx.Observable\n  .create(function(observer) {\n    observer.next('Jerry'); // RxJS 4.x 以前的版本用 onNext\n    observer.next('Anna');\n  })\n```\n\n- `of`\n多个传递值\n```js\nvar observable = Rx.Observable.of('Jerry', 'Anna');\n```\n\n- `from`\n数组，字符串，promise对象\n```js\nvar params = ['Jerry', 'Anna']  // 数组\nvar params = 'Jerry' // 字符串\nvar params = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('hi')\n    }, 300)\n})                  // promise对象\nvar observable = Rx.Observable.from(params)\n```\n\n- `fromEvent`\n为DOM元素添加监听事件\nparam1: DOM对象，param2: 监听事件\n```js\nvar observable = Rx.Observable.fromEvent($DOM, $event);\n```\n\n- `fromEventPattern`\n同时具有注册移除监听的类事件使用\n```js\nclass Producer {\n\tconstructor() {\n\t\tthis.listeners = [];\n\t}\n\taddListener(listener) {\n\t\tif(typeof listener === 'function') {\n\t\t\tthis.listeners.push(listener)\n\t\t} else {\n\t\t\tthrow new Error('listener 必須是 function')\n\t\t}\n\t}\n\tremoveListener(listener) {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1)\n\t}\n\tnotify(message) {\n\t\tthis.listeners.forEach(listener => {\n\t\t\tlistener(message);\n\t\t})\n\t}\n}\nvar egghead = new Producer(); \nvar source = Rx.Observable\n    .fromEventPattern(\n        (handler) => egghead.addListener(handler), \n        (handler) => egghead.removeListener(handler)\n    ); \nsource.subscribe({\n    next: function(value) {\n        console.log(value)\n    },\n    complete: function() {\n        console.log('complete!');\n    },\n    error: function(error) {\n        console.log(error)\n    }\n})\negghead.notify('Hello! Can you hear me?');\n// Hello! Can you hear me?\n```\n\n\n- `empty`\n给出一个空的Observable，如果订阅这个Observable则会立即push出complete\n```js\nvar source = Rx.Observable.empty()\n```\n\n- `never`\n给出一个无穷的Observable，订阅后将什么都不发生，但存在\n```js\nvar source = Rx.Observable.never()\n```\n\n- `throw`\n给出一个错误的Observable，订阅后将直接抛出错误\n```js\nvar source = Rx.Observable.throw()\n```\n\n- `interval`\n每隔一段时间推送出一个从零开始递增的整数\n```js\nvar source = Rx.Observable.interval(666)\n```\n\n- `timer`\n`param_one`: 发出第一个值的等待时间(number)/等待到的日期(Date)\n`param_two`: 第一个值发出之后发送每个值的间隔时间\n如果只有一个参数，发出第一个值之后触发complete\n```js\nvar source = Rx.Observable.timer(5000, 1000)\n```\n\n\n### Subscription\n订阅Observable后会回传一个subscription对象，这个对象含有释放资源的`unsubscribe`方法，可以停止订阅\n```js\nvar source = Rx.Observable.timer(1000, 1000);\n// 取得 subscription\nvar subscription = source.subscribe({\n\tnext: function(value) {\n\t\tconsole.log(value)\n\t},\n\tcomplete: function() {\n\t\tconsole.log('complete!');\n\t},\n\terror: function(error) {\n    console.log('Throw Error: ' + error)\n\t}\n});\nsetTimeout(() => {\n    subscription.unsubscribe()\n}, 5000)\n// 输出: 0,1,2,3,4\n```\n\n### Operator\n`Operators`是一个个被附加到`Observable`上的方法，经过这些方法传递出一个新的`observable`\n\n#### Transformation Operators\n- `map`: 对 `Observable` 对象发出的每个值，使用指定的 `project` 函数，进行映射处理\n```js\nvar source = Rx.Observable.interval(1000);\nvar newest = source.map(x => x + 2); \nnewest.subscribe(console.log);\n```\n```\nsource: -----0-----1-----2-----3--...\n            map(x => x + 2)\nnewest: -----2-----3-----4-----5--...\n```\n- `mapTo`: 对 `Observable` 对象发出的每个值，映射成固定的值\n```js\nvar source = Rx.Observable.interval(1000);\nvar newest = source.mapTo(2); \nnewest.subscribe(console.log);\n```\n```\nsource: -----0-----1-----2-----3--...\n                mapTo(2)\nnewest: -----2-----2-----2-----2--...\n```\n- `scan`: 对 `Observable` 发出值，执行 `accumulator` 指定的运算，类似于 `reduce` \n```js\nvar source = Rx.Observable.interval(1000)\nvar newest = source.scan( count => count + 5, '2')\nnewest.subscribe(console.log);\n```\n```\nsource: -----0------1------2------3--...\n        scan( x => x + 5, 0)\nnewest: -----5-----10-----15-----20--...\n```\n\n- `buffer`: 缓冲源 `Observable` 对象已发出的值，直到 `closingNotifier` 触发后，统一输出缓存的元素\n```js\nvar source = Rx.Observable.interval(300);\nvar source2 = Rx.Observable.interval(1000);\nvar example = source.buffer(source2);\nexample.subscribe(...);\n```\n```\nsource : --0--1--2--3--4--5--6--7..\nsource2: ---------0---------1--------...\n            buffer(source2)\nexample: ---------([0,1,2])---------([3,4,5]) \n```\n\n- `bufferTime`: 设定源 `Observable` 对象已发出的值的缓冲时间\n```js\nvar source = Rx.Observable.interval(300);\nvar example = source.bufferTime(1000);\nexample.subscribe(...);\n```\n```\nsource : --0--1--2--3--4--5--6--7..\n            bufferTime(1000)\nexample: ---------([0,1,2])---------([3,4,5]) \n```\n\n- `bufferCount`: 缓冲源 `Observable` 对象已发出的值，直到大小达到给定的最大 `bufferSize` \n```js\nvar source = Rx.Observable.interval(300);\nvar example = source.bufferCount(3);\nexample.subscribe(...);\n```\n```\nsource : --0--1--2--3--4--5--6--7..\n            bufferCount(3)\nexample: ---------([0,1,2])---------([3,4,5]) \n```\n\n- `concatMap`: 对每个 `Observable` 对象发出的值，进行映射处理，并进行合并。该操作符也会依序所有`Observable` 对象\n```js\nvar source = Rx.Observable.fromEvent(document.body, 'click');\nvar example = source.concatMap(e => Rx.Observable.interval(100).take(3));\nexample.subscribe(...);\n```\n```\nsource : -----------c--c------------------...\n        concatMap(c => Rx.Observable.interval(100).take(3))\nexample: -------------0-1-2-0-1-2---------...\n```\n\n- `switchMap`: 对源 `Observable` 对象发出的值，做映射处理。若有新的 `Observable` 对象出现，会在新的 `Observable` 对象发出新值后，退订前一个未处理完的 `Observable` 对象\n```js\nvar source = Rx.Observable.fromEvent(document.body, 'click');\nvar example = source.switchMap(e => Rx.Observable.interval(100).take(3));\nexample.subscribe(...);\n```\n```\nsource : -----------c--c-----------------...\n        concatMap(c => Rx.Observable.interval(100).take(3))\nexample: -------------0--0-1-2-----------...\n```\n\n#### Filtering Operators\n- `filter`: 过滤值\n```js\nvar source = Rx.Observable.interval(1000);\nvar newest = source.filter(x => x % 2 === 0); \n```\n```\nsource: -----0-----1-----2-----3-----4-...\n            filter(x => x % 2 === 0)\nnewest: -----0-----------2-----------4-...\n```\n\n- `take`: 获取 `Observable` 对象发出的前n项值，取完结束。\n```js\nvar source = Rx.Observable.interval(1000);\nvar example = source.take(3);\n```\n```\nsource : -----0-----1-----2-----3--..\n                take(3)\nexample: -----0-----1-----2|\n```\n\n- `first`: 获取 `Observable` 对象发出的第一个元素，取完结束。\n```js\nvar source = Rx.Observable.interval(1000);\nvar example = source.first();\n```\n```\nsource : -----0-----1-----2-----3--..\n                first()\nexample: -----0|\n```\n\n- `takeUntil`: 当 `takeUntil` 传入的 `notifier` 发出值时，源 `Observable` 对象就会直接进入完成状态\n```js\nvar source = Rx.Observable.interval(1000);\nvar click = Rx.Observable.fromEvent(document.body, 'click');\nvar example = source.takeUntil(click);\n```\n```\nsource : -----0-----1-----2------3--\nclick  : ----------------------c----\n                takeUntil(click)\nexample: -----0-----1-----2----|\n```\n\n- `skip`: 跳过 源`Observable`的前n项，并返回新的`Observable`对象\n```js\nvar source = Rx.Observable.interval(1000);\nvar example = source.skip(3);\n```\n```\nsource : ----0----1----2----3----4----5--....\n                    skip(3)\nexample: -------------------3----4----5--...\n```\n\n- `takeLast`: 获取 源`Observable`发出的后n项\n```js\nvar source = Rx.Observable.interval(1000).take(6);\nvar example = source.takeLast(2);\n```\n```\nsource : ----0----1----2----3----4----5|\n                takeLast(2)\nexample: ------------------------------(45)|\n```\n\n- `last`: 获取 源`Observable`发出的最后一项\n```js\nvar source = Rx.Observable.interval(1000).take(6);\nvar example = source.last();\n```\n```\nsource : ----0----1----2----3----4----5|\n                    last()\nexample: ------------------------------(5)|\n```\n\n- `debounceTime`: 在设定的时间跨度内，若源 `Observable` 对象没有再发出新值，则返回最近一次发出的值\n```js\nvar source = Rx.Observable.interval(300).take(5);\nvar example = source.debounceTime(1000);\n```\n```\nsource : --0--1--2--3--4|\n        debounceTime(1000)\nexample: --------------4| \n```\n\n- `throttleTime`: 节流，从 源`Observable`对象发出的第一个值开始，忽略等待时间内发出的值\n```js\nvar source = Rx.Observable.interval(300).take(5);\nvar example = source.throttleTime(1000);\n```\n```\nsource : --0--1--2--3--4|\n        throttleTime(1000)\nexample: --0------------4|  \n```\n\n- `distinct`: 去重\n```js\nvar source = Rx.Observable.from(['a', 'b', 'c', 'a', 'b'])\nvar example = source.distinct()\n```\n```\nsource : --a--b--c--a--b|\n            distinct()\nexample: --a--b--c------|\n```\n\n- `distinctUntilChanged`: 过滤 `Observable`发出的值，若当前值与上一次值不一致，则发出该值。\n```js\nvar source = Rx.Observable.from(['a', 'b', 'c', 'c', 'b'])\nvar example = source.distinctUntilChanged()\n```\n```\nsource : --a--b--c--c--b|\n            distinctUntilChanged()\nexample: --a--b--c-----b|\n```\n#### `Combination Operators`\n\n- `concat`: 合并多个`Observable`对象，并依次执行\n```js\nvar source = Rx.Observable.interval(1000).take(3);\nvar source2 = Rx.Observable.of(3)\nvar source3 = Rx.Observable.of(4,5,6)\nvar example = source.concat(source2, source3);\n```\n```\nsource : ----0----1----2|\nsource2: (3)|\nsource3: (456)|\n            concat()\nexample: ----0----1----2(3456)|\n```\n\n- `concatAll`: 合并多个`Observable`对象，并在上一个`Obs`完成订阅后订阅下一个`Obs`\n```js\nvar obs1 = Rx.Observable.interval(1000).take(5);\nvar obs2 = Rx.Observable.interval(500).take(2);\nvar obs3 = Rx.Observable.interval(2000).take(1);\nvar source = Rx.Observable.of(obs1, obs2, obs3);\nvar example = source.concatAll();\n```\n```\nsource : (o1                 o2      o3)|\n           \\                  \\       \\\n            --0--1--2--3--4|   -0-1|   ----0|               \n                concatAll()        \nexample: --0--1--2--3--4-0-1----0|\n```\n\n- `startWith`: 在开始发出`Obs`对象的数据之前发出已经设置的参数\n```js\nvar source = Rx.Observable.interval(1000);\nvar example = source.startWith(222);\n```\n```\nsource : ----0----1----2----3--...\n                startWith(222)\nexample: (222)----0----1----2----3--...\n```\n\n- `merage`: 合并 `Obs`对象，并按给定的时序发出对应值\n```js\nvar source = Rx.Observable.interval(500).take(3);\nvar source2 = Rx.Observable.interval(300).take(6);\nvar example = source.merge(source2);\n```\n```\nsource : ----0----1----2|\nsource2: --0--1--2--3--4--5|\n            merge()\nexample: --0-01--21-3--(24)--5|\n```\n\n- `merageAll`: 将高阶`Obs`转换为一阶`Obs`，并同时处理所有`Obs`\n```js\nvar click = Rx.Observable.fromEvent(document.body, 'click');\nvar source = click.map(e => Rx.Observable.interval(1000));\nvar example = source.mergeAll();\n```\n```\nclick  : ---------c-c------------------c--.. \n        map(e => Rx.Observable.interval(1000))\nsource : ---------o-o------------------o--..\n                   \\ \\                  \\----0----1--...\n                    \\ ----0----1----2----3----4--...\n                     ----0----1----2----3----4--...\n                     mergeAll()\nexample: ----------------00---11---22---33---(04)4--...\n```\n\n- `combineLatest`: 合并输入的`Obs`对象，当源`Obs`和其他`Obs`都发出值后，才会调用`project`函数\n```js\nvar source = Rx.Observable.interval(500).take(3);\nvar newest = Rx.Observable.interval(300).take(6);\nvar example = source.combineLatest(newest, (x, y) => x + y);\n```\n```\nsource : ----0----1----2|\nnewest : --0--1--2--3--4--5|\n    combineLatest(newest, (x, y) => x + y);\nexample: ----01--23-4--(56)--7|\n```\n\n- `zip`: 根据所有的`Obs`对象的输入顺序，产生一个新`Obs`\n```js\nvar source = Rx.Observable.interval(500).take(3);\nvar newest = Rx.Observable.interval(300).take(6);\nvar example = source.zip(newest, (x, y) => x + y);\n```\n```\nsource : ----0----1----2|\nnewest : --0--1--2--3--4--5|\n    zip(newest, (x, y) => x + y)\nexample: ----0----2----4|\n```\n\n- `withLatestFrom`: 当源`Obs`发出新值时，根据`project`函数，合并其他`Obs`之前发出的最新值\n```js\nvar main = Rx.Observable.from('hello').zip(Rx.Observable.interval(500), \n    (x, y) => x);\nvar some = Rx.Observable.from([0,1,0,0,0,1]).zip(Rx.Observable.interval(300), \n    (x, y) => x);\nvar example = main.withLatestFrom(some, (x, y) => {\n    return y === 1 ? x.toUpperCase() : x;\n});\n```\n```\nmain   : ----h----e----l----l----o|\nsome   : --0--1--0--0--0--1|\nwithLatestFrom(some, (x, y) =>  y === 1 ? x.toUpperCase() : x);\nexample: ----h----e----l----L----O|\n```\n\n- `switch`: 切换为最新的`Obs`数据源，并退订之前的`Obs`\n```js\nvar click = Rx.Observable.fromEvent(document.body, 'click');\nvar source = click.map(e => Rx.Observable.interval(1000));\nvar example = source.switch();\n```\n```\nclick  : ---------c-c------------------c--.. \n        map(e => Rx.Observable.interval(1000))\nsource : ---------o-o------------------o--..\n                   \\ \\                  \\----0----1--...\n                    \\ ----0----1----2----3----4--...\n                     ----0----1----2----3----4--...\n                     switch()\nexample: -----------------0----1----2--------0----1--...\n```\n\n#### `Utility Operators`\n- `delay`: 延迟源`Obs`发出的第一个元素的时间点\n```js\nvar source = Rx.Observable.interval(300).take(5);\nvar example = source.delay(500);\n```\n```\nsource : --0--1--2--3--4|\n        delay(500)\nexample: -------0--1--2--3--4|\n```\n\n- `delayWhen`: `delayWhen` 会响每个元素，调用的时候需要设置 `delayDurationSelector` 函数，该函数的返回值是 `Observable` 对象\n```js\nvar source = Rx.Observable.interval(300).take(5);\nvar example = source.delayWhen( x => Rx.Observable.interval(100 * x).take(1));\n```\n```\nsource : --0--1--2--3--4|\n    .delayWhen(x => Rx.Observable.interval(100 * x).take(1));\nexample: --0---1----2-----3------4|\n```\n\n#### `Multicasting Operators`\n- `multicast`: 用于挂载`Subject`，并返回一个可链接的`Obs`对象\n```js\nvar source = Rx.Observable.interval(1000)\n             .take(3)\n             .multicast(new Rx.Subject());\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n};\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n};\nsource.subscribe(observerA); // subject.subscribe(observerA)\nsource.connect(); // source.subscribe(subject)\nsetTimeout(() => {\n    source.subscribe(observerB); // subject.subscribe(observerA)\n}, 1000);\n```\n- `refCount`: 使 `multicast Observalbe`可以在第一个`subscriber`到达时自动执行，并在最后一个`subscriber`离开时结束。\n`refCount()`存在于`ConnectableObservable`上，并返回一个新的`Observalbe`\n```js\nvar source = Rx.Observable.interval(1000)\n             .do(x => console.log('send: ' + x))\n             .multicast(new Rx.Subject())\n             .refCount();\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n};\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n}\nvar subscriptionA = source.subscribe(observerA);\n// 订阅数 0 => 1\nvar subscriptionB;\nsetTimeout(() => {\n    subscriptionB = source.subscribe(observerB);\n    // 订阅数 1 => 2\n}, 1000);\nsetTimeout(() => {\n    subscriptionA.unsubscribe(); // 订阅数 2 => 1\n    subscriptionB.unsubscribe(); // 订阅数 1 => 0，source 停止发送元素\n}, 5000);\n```\n\n- `publish`: 用于挂载 `Subject` 对象，并返回一个可链接 (connectable) 的 `Obs`, `publish` `multicast(new Rx.Subject())` 等价\n```js\nvar source = Rx.Observable.interval(1000)\n             .publish() \n             .refCount();        \nvar source = Rx.Observable.interval(1000)\n             .multicast(new Rx.Subject()) \n             .refCount();\n```\n- `publishReplay`\n```js\nvar source = Rx.Observable.interval(1000)\n             .publishReplay(1) \n             .refCount();          \nvar source = Rx.Observable.interval(1000)\n            .multicast(new Rx.ReplaySubject(1)) \n            .refCount();\n```\n\n- `publishBehavior`\n```js\nvar source = Rx.Observable.interval(1000)\n             .publishBehavior(0) \n             .refCount();           \nvar source = Rx.Observable.interval(1000)\n             .multicast(new Rx.BehaviorSubject(0)) \n             .refCount();\n```\n\n- `publishLast`\n```js\nvar source = Rx.Observable.interval(1000)\n             .publishLast() \n             .refCount();          \nvar source = Rx.Observable.interval(1000)\n             .multicast(new Rx.AsyncSubject(1)) \n             .refCount();\n```\n\n- `share`: `publish` + `refCount` 的简写\n```js\nvar source = Rx.Observable.interval(1000)\n             .share();          \nvar source = Rx.Observable.interval(1000)\n             .publish()\n             .refCount();\nvar source = Rx.Observable.interval(1000)\n             .multicast(new Rx.Subject()) \n             .refCount();\n```\n\n#### `Error Handling Operators`\n- `catch`: 捕获异常，同时返回一个 `Obs`，用于发出新的值\n```js\nvar source = Rx.Observable.from(['a','b','c','d',2])\n               .zip(Rx.Observable.interval(500), (x,y) => x);\nvar example = source.map(x => x.toUpperCase())\n                    .catch(error => Rx.Observable.of('h'));\n```\n```\nsource : ----a----b----c----d----2|\n        map(x => x.toUpperCase())\n         ----a----b----c----d----X|\n        catch(error => Rx.Observable.of('h'))\nexample: ----A----B----C----D----h|\n```\n- `retry`: 发生错误后，重试 `count` 次数\n```js\nvar source = Rx.Observable.from(['a','b','c','d',2])\n               .zip(Rx.Observable.interval(500), (x,y) => x);\nvar example = source.map(x => x.toUpperCase())\n                    .retry(1);\n```\n```\nsource : ----a----b----c----d----2|\n        map(x => x.toUpperCase())\n         ----a----b----c----d----X|\n                retry(1)\nexample: ----A----B----C----D--------A----B----C----D----X|\n```\n\n- `retryWhen`: 捕获异常 `Obs`, 处理后可以重新订阅源`Obs`\n```js\nvar source = Rx.Observable.from(['a','b','c','d',2])\n               .zip(Rx.Observable.interval(500), (x,y) => x);\nvar example = source.map(x => x.toUpperCase())\n                    .retryWhen(errorObs => errorObs.delay(1000));\n```\n```\nsource : ----a----b----c----d----2|\n        map(x => x.toUpperCase())\n         ----a----b----c----d----X|\n        retryWhen(errorObs => errorObs.delay(1000))\nexample: ----A----B----C----D-------------------A----B----C----D----...\n```\n\n### Subject\n - `Subject`: 继承于`Observable`的 `Observer Pattern` 的实例\n`Subject` 既是 `Observable` 又是 `Observer`\n`Subject` 会对內部的 `observers` 列表进行组播(multicast)\n\n```js\nvar subject = new Rx.Subject();\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n}\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n}\nsubject.subscribe(observerA);\nsubject.subscribe(observerB);\nsubject.next(1);\n// \"A next: 1\"\n// \"B next: 1\"\nsubject.next(2);\n// \"A next: 2\"\n// \"B next: 2\"\n```\n- `BehaviorSubject`: 会记住最新一次推送的元素，并把该元素当做当前值推送（建立时需给定状态）\n```js\nvar subject = new Rx.BehaviorSubject(0); // 0 為起始值\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n}\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n}\nsubject.subscribe(observerA);\n// \"A next: 0\"\nsubject.next(1);\n// \"A next: 1\"\nsubject.next(2);\n// \"A next: 2\"\nsubject.next(3);\n// \"A next: 3\"\nsetTimeout(() => {\n    subject.subscribe(observerB); \n    // \"B next: 3\"\n},3000)\n```\n\n- `ReplaySubject`: 在新订阅后重新发送最后几个元素\n```js\nvar subject = new Rx.ReplaySubject(2); // 重複發送最後 2 個元素\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n}\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n}\nsubject.subscribe(observerA);\nsubject.next(1);\n// \"A next: 1\"\nsubject.next(2);\n// \"A next: 2\"\nsubject.next(3);\n// \"A next: 3\"\nsetTimeout(() => {\n    subject.subscribe(observerB);\n    // \"B next: 2\"\n    // \"B next: 3\"\n},3000)\n```\n\n- `AsyncSubject`: 在`subject`结束后送出最后一个值并结束\n```js\nvar subject = new Rx.AsyncSubject();\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n}\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n}\nsubject.subscribe(observerA);\nsubject.next(1);\nsubject.next(2);\nsubject.next(3);\nsubject.complete();\n// \"A next: 3\"\n// \"A complete!\"\nsetTimeout(() => {\n    subject.subscribe(observerB);\n    // \"B next: 3\"\n    // \"B complete!\"\n},3000)\n```\n\n\n### Observer\n - `next`: 当Observable推送新值时调用\n - `complete`: 当Observable所有值调用完毕之后，调用后next将不再起作用\n - `error`: 报错时\n```js\nvar observer = {\n\tnext: function(value) {\n\t\tconsole.log(value);\n\t},\n\terror: function(error) {\n\t\tconsole.log(error)\n\t},\n\tcomplete: function() {\n\t\tconsole.log('complete')\n\t}\n}\n//  使用之前定义的观察者来订阅\nobservable.subscribe(observer)\n// Jerry\n// Anna\n// complete\n```\n\n\n### Scheduler\n- 数据结构，知道如何根据优先级或其他标准来执行并列任务\n- 执行环境，知道事件何时何处执行\n- 虚拟时钟，可以让事件在特定时间执行\n","source":"_posts/Rx入门学习.md","raw":"---\ntitle: Rx入门学习\ndate: 2017-08-12 14:08:28\ntags:\n---\n## RXjs\n\n### Functional Programming\n - Expression, no Statement\n - Pure Function\n - 利用参数保存状态\n\n\n### 建立Observable\n统一订阅\n```js\nobservable.subscribe({\n    next: function(value) {\n        console.log(value)\n    },\n    complete: function() {\n        console.log('complete!');\n    },\n    error: function(error) {\n        console.log(error)\n    }\n});\n```\n- `create`\n```js\n/**\n@param: `callback function`\n*/\nvar observable = Rx.Observable\n  .create(function(observer) {\n    observer.next('Jerry'); // RxJS 4.x 以前的版本用 onNext\n    observer.next('Anna');\n  })\n```\n\n- `of`\n多个传递值\n```js\nvar observable = Rx.Observable.of('Jerry', 'Anna');\n```\n\n- `from`\n数组，字符串，promise对象\n```js\nvar params = ['Jerry', 'Anna']  // 数组\nvar params = 'Jerry' // 字符串\nvar params = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve('hi')\n    }, 300)\n})                  // promise对象\nvar observable = Rx.Observable.from(params)\n```\n\n- `fromEvent`\n为DOM元素添加监听事件\nparam1: DOM对象，param2: 监听事件\n```js\nvar observable = Rx.Observable.fromEvent($DOM, $event);\n```\n\n- `fromEventPattern`\n同时具有注册移除监听的类事件使用\n```js\nclass Producer {\n\tconstructor() {\n\t\tthis.listeners = [];\n\t}\n\taddListener(listener) {\n\t\tif(typeof listener === 'function') {\n\t\t\tthis.listeners.push(listener)\n\t\t} else {\n\t\t\tthrow new Error('listener 必須是 function')\n\t\t}\n\t}\n\tremoveListener(listener) {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1)\n\t}\n\tnotify(message) {\n\t\tthis.listeners.forEach(listener => {\n\t\t\tlistener(message);\n\t\t})\n\t}\n}\nvar egghead = new Producer(); \nvar source = Rx.Observable\n    .fromEventPattern(\n        (handler) => egghead.addListener(handler), \n        (handler) => egghead.removeListener(handler)\n    ); \nsource.subscribe({\n    next: function(value) {\n        console.log(value)\n    },\n    complete: function() {\n        console.log('complete!');\n    },\n    error: function(error) {\n        console.log(error)\n    }\n})\negghead.notify('Hello! Can you hear me?');\n// Hello! Can you hear me?\n```\n\n\n- `empty`\n给出一个空的Observable，如果订阅这个Observable则会立即push出complete\n```js\nvar source = Rx.Observable.empty()\n```\n\n- `never`\n给出一个无穷的Observable，订阅后将什么都不发生，但存在\n```js\nvar source = Rx.Observable.never()\n```\n\n- `throw`\n给出一个错误的Observable，订阅后将直接抛出错误\n```js\nvar source = Rx.Observable.throw()\n```\n\n- `interval`\n每隔一段时间推送出一个从零开始递增的整数\n```js\nvar source = Rx.Observable.interval(666)\n```\n\n- `timer`\n`param_one`: 发出第一个值的等待时间(number)/等待到的日期(Date)\n`param_two`: 第一个值发出之后发送每个值的间隔时间\n如果只有一个参数，发出第一个值之后触发complete\n```js\nvar source = Rx.Observable.timer(5000, 1000)\n```\n\n\n### Subscription\n订阅Observable后会回传一个subscription对象，这个对象含有释放资源的`unsubscribe`方法，可以停止订阅\n```js\nvar source = Rx.Observable.timer(1000, 1000);\n// 取得 subscription\nvar subscription = source.subscribe({\n\tnext: function(value) {\n\t\tconsole.log(value)\n\t},\n\tcomplete: function() {\n\t\tconsole.log('complete!');\n\t},\n\terror: function(error) {\n    console.log('Throw Error: ' + error)\n\t}\n});\nsetTimeout(() => {\n    subscription.unsubscribe()\n}, 5000)\n// 输出: 0,1,2,3,4\n```\n\n### Operator\n`Operators`是一个个被附加到`Observable`上的方法，经过这些方法传递出一个新的`observable`\n\n#### Transformation Operators\n- `map`: 对 `Observable` 对象发出的每个值，使用指定的 `project` 函数，进行映射处理\n```js\nvar source = Rx.Observable.interval(1000);\nvar newest = source.map(x => x + 2); \nnewest.subscribe(console.log);\n```\n```\nsource: -----0-----1-----2-----3--...\n            map(x => x + 2)\nnewest: -----2-----3-----4-----5--...\n```\n- `mapTo`: 对 `Observable` 对象发出的每个值，映射成固定的值\n```js\nvar source = Rx.Observable.interval(1000);\nvar newest = source.mapTo(2); \nnewest.subscribe(console.log);\n```\n```\nsource: -----0-----1-----2-----3--...\n                mapTo(2)\nnewest: -----2-----2-----2-----2--...\n```\n- `scan`: 对 `Observable` 发出值，执行 `accumulator` 指定的运算，类似于 `reduce` \n```js\nvar source = Rx.Observable.interval(1000)\nvar newest = source.scan( count => count + 5, '2')\nnewest.subscribe(console.log);\n```\n```\nsource: -----0------1------2------3--...\n        scan( x => x + 5, 0)\nnewest: -----5-----10-----15-----20--...\n```\n\n- `buffer`: 缓冲源 `Observable` 对象已发出的值，直到 `closingNotifier` 触发后，统一输出缓存的元素\n```js\nvar source = Rx.Observable.interval(300);\nvar source2 = Rx.Observable.interval(1000);\nvar example = source.buffer(source2);\nexample.subscribe(...);\n```\n```\nsource : --0--1--2--3--4--5--6--7..\nsource2: ---------0---------1--------...\n            buffer(source2)\nexample: ---------([0,1,2])---------([3,4,5]) \n```\n\n- `bufferTime`: 设定源 `Observable` 对象已发出的值的缓冲时间\n```js\nvar source = Rx.Observable.interval(300);\nvar example = source.bufferTime(1000);\nexample.subscribe(...);\n```\n```\nsource : --0--1--2--3--4--5--6--7..\n            bufferTime(1000)\nexample: ---------([0,1,2])---------([3,4,5]) \n```\n\n- `bufferCount`: 缓冲源 `Observable` 对象已发出的值，直到大小达到给定的最大 `bufferSize` \n```js\nvar source = Rx.Observable.interval(300);\nvar example = source.bufferCount(3);\nexample.subscribe(...);\n```\n```\nsource : --0--1--2--3--4--5--6--7..\n            bufferCount(3)\nexample: ---------([0,1,2])---------([3,4,5]) \n```\n\n- `concatMap`: 对每个 `Observable` 对象发出的值，进行映射处理，并进行合并。该操作符也会依序所有`Observable` 对象\n```js\nvar source = Rx.Observable.fromEvent(document.body, 'click');\nvar example = source.concatMap(e => Rx.Observable.interval(100).take(3));\nexample.subscribe(...);\n```\n```\nsource : -----------c--c------------------...\n        concatMap(c => Rx.Observable.interval(100).take(3))\nexample: -------------0-1-2-0-1-2---------...\n```\n\n- `switchMap`: 对源 `Observable` 对象发出的值，做映射处理。若有新的 `Observable` 对象出现，会在新的 `Observable` 对象发出新值后，退订前一个未处理完的 `Observable` 对象\n```js\nvar source = Rx.Observable.fromEvent(document.body, 'click');\nvar example = source.switchMap(e => Rx.Observable.interval(100).take(3));\nexample.subscribe(...);\n```\n```\nsource : -----------c--c-----------------...\n        concatMap(c => Rx.Observable.interval(100).take(3))\nexample: -------------0--0-1-2-----------...\n```\n\n#### Filtering Operators\n- `filter`: 过滤值\n```js\nvar source = Rx.Observable.interval(1000);\nvar newest = source.filter(x => x % 2 === 0); \n```\n```\nsource: -----0-----1-----2-----3-----4-...\n            filter(x => x % 2 === 0)\nnewest: -----0-----------2-----------4-...\n```\n\n- `take`: 获取 `Observable` 对象发出的前n项值，取完结束。\n```js\nvar source = Rx.Observable.interval(1000);\nvar example = source.take(3);\n```\n```\nsource : -----0-----1-----2-----3--..\n                take(3)\nexample: -----0-----1-----2|\n```\n\n- `first`: 获取 `Observable` 对象发出的第一个元素，取完结束。\n```js\nvar source = Rx.Observable.interval(1000);\nvar example = source.first();\n```\n```\nsource : -----0-----1-----2-----3--..\n                first()\nexample: -----0|\n```\n\n- `takeUntil`: 当 `takeUntil` 传入的 `notifier` 发出值时，源 `Observable` 对象就会直接进入完成状态\n```js\nvar source = Rx.Observable.interval(1000);\nvar click = Rx.Observable.fromEvent(document.body, 'click');\nvar example = source.takeUntil(click);\n```\n```\nsource : -----0-----1-----2------3--\nclick  : ----------------------c----\n                takeUntil(click)\nexample: -----0-----1-----2----|\n```\n\n- `skip`: 跳过 源`Observable`的前n项，并返回新的`Observable`对象\n```js\nvar source = Rx.Observable.interval(1000);\nvar example = source.skip(3);\n```\n```\nsource : ----0----1----2----3----4----5--....\n                    skip(3)\nexample: -------------------3----4----5--...\n```\n\n- `takeLast`: 获取 源`Observable`发出的后n项\n```js\nvar source = Rx.Observable.interval(1000).take(6);\nvar example = source.takeLast(2);\n```\n```\nsource : ----0----1----2----3----4----5|\n                takeLast(2)\nexample: ------------------------------(45)|\n```\n\n- `last`: 获取 源`Observable`发出的最后一项\n```js\nvar source = Rx.Observable.interval(1000).take(6);\nvar example = source.last();\n```\n```\nsource : ----0----1----2----3----4----5|\n                    last()\nexample: ------------------------------(5)|\n```\n\n- `debounceTime`: 在设定的时间跨度内，若源 `Observable` 对象没有再发出新值，则返回最近一次发出的值\n```js\nvar source = Rx.Observable.interval(300).take(5);\nvar example = source.debounceTime(1000);\n```\n```\nsource : --0--1--2--3--4|\n        debounceTime(1000)\nexample: --------------4| \n```\n\n- `throttleTime`: 节流，从 源`Observable`对象发出的第一个值开始，忽略等待时间内发出的值\n```js\nvar source = Rx.Observable.interval(300).take(5);\nvar example = source.throttleTime(1000);\n```\n```\nsource : --0--1--2--3--4|\n        throttleTime(1000)\nexample: --0------------4|  \n```\n\n- `distinct`: 去重\n```js\nvar source = Rx.Observable.from(['a', 'b', 'c', 'a', 'b'])\nvar example = source.distinct()\n```\n```\nsource : --a--b--c--a--b|\n            distinct()\nexample: --a--b--c------|\n```\n\n- `distinctUntilChanged`: 过滤 `Observable`发出的值，若当前值与上一次值不一致，则发出该值。\n```js\nvar source = Rx.Observable.from(['a', 'b', 'c', 'c', 'b'])\nvar example = source.distinctUntilChanged()\n```\n```\nsource : --a--b--c--c--b|\n            distinctUntilChanged()\nexample: --a--b--c-----b|\n```\n#### `Combination Operators`\n\n- `concat`: 合并多个`Observable`对象，并依次执行\n```js\nvar source = Rx.Observable.interval(1000).take(3);\nvar source2 = Rx.Observable.of(3)\nvar source3 = Rx.Observable.of(4,5,6)\nvar example = source.concat(source2, source3);\n```\n```\nsource : ----0----1----2|\nsource2: (3)|\nsource3: (456)|\n            concat()\nexample: ----0----1----2(3456)|\n```\n\n- `concatAll`: 合并多个`Observable`对象，并在上一个`Obs`完成订阅后订阅下一个`Obs`\n```js\nvar obs1 = Rx.Observable.interval(1000).take(5);\nvar obs2 = Rx.Observable.interval(500).take(2);\nvar obs3 = Rx.Observable.interval(2000).take(1);\nvar source = Rx.Observable.of(obs1, obs2, obs3);\nvar example = source.concatAll();\n```\n```\nsource : (o1                 o2      o3)|\n           \\                  \\       \\\n            --0--1--2--3--4|   -0-1|   ----0|               \n                concatAll()        \nexample: --0--1--2--3--4-0-1----0|\n```\n\n- `startWith`: 在开始发出`Obs`对象的数据之前发出已经设置的参数\n```js\nvar source = Rx.Observable.interval(1000);\nvar example = source.startWith(222);\n```\n```\nsource : ----0----1----2----3--...\n                startWith(222)\nexample: (222)----0----1----2----3--...\n```\n\n- `merage`: 合并 `Obs`对象，并按给定的时序发出对应值\n```js\nvar source = Rx.Observable.interval(500).take(3);\nvar source2 = Rx.Observable.interval(300).take(6);\nvar example = source.merge(source2);\n```\n```\nsource : ----0----1----2|\nsource2: --0--1--2--3--4--5|\n            merge()\nexample: --0-01--21-3--(24)--5|\n```\n\n- `merageAll`: 将高阶`Obs`转换为一阶`Obs`，并同时处理所有`Obs`\n```js\nvar click = Rx.Observable.fromEvent(document.body, 'click');\nvar source = click.map(e => Rx.Observable.interval(1000));\nvar example = source.mergeAll();\n```\n```\nclick  : ---------c-c------------------c--.. \n        map(e => Rx.Observable.interval(1000))\nsource : ---------o-o------------------o--..\n                   \\ \\                  \\----0----1--...\n                    \\ ----0----1----2----3----4--...\n                     ----0----1----2----3----4--...\n                     mergeAll()\nexample: ----------------00---11---22---33---(04)4--...\n```\n\n- `combineLatest`: 合并输入的`Obs`对象，当源`Obs`和其他`Obs`都发出值后，才会调用`project`函数\n```js\nvar source = Rx.Observable.interval(500).take(3);\nvar newest = Rx.Observable.interval(300).take(6);\nvar example = source.combineLatest(newest, (x, y) => x + y);\n```\n```\nsource : ----0----1----2|\nnewest : --0--1--2--3--4--5|\n    combineLatest(newest, (x, y) => x + y);\nexample: ----01--23-4--(56)--7|\n```\n\n- `zip`: 根据所有的`Obs`对象的输入顺序，产生一个新`Obs`\n```js\nvar source = Rx.Observable.interval(500).take(3);\nvar newest = Rx.Observable.interval(300).take(6);\nvar example = source.zip(newest, (x, y) => x + y);\n```\n```\nsource : ----0----1----2|\nnewest : --0--1--2--3--4--5|\n    zip(newest, (x, y) => x + y)\nexample: ----0----2----4|\n```\n\n- `withLatestFrom`: 当源`Obs`发出新值时，根据`project`函数，合并其他`Obs`之前发出的最新值\n```js\nvar main = Rx.Observable.from('hello').zip(Rx.Observable.interval(500), \n    (x, y) => x);\nvar some = Rx.Observable.from([0,1,0,0,0,1]).zip(Rx.Observable.interval(300), \n    (x, y) => x);\nvar example = main.withLatestFrom(some, (x, y) => {\n    return y === 1 ? x.toUpperCase() : x;\n});\n```\n```\nmain   : ----h----e----l----l----o|\nsome   : --0--1--0--0--0--1|\nwithLatestFrom(some, (x, y) =>  y === 1 ? x.toUpperCase() : x);\nexample: ----h----e----l----L----O|\n```\n\n- `switch`: 切换为最新的`Obs`数据源，并退订之前的`Obs`\n```js\nvar click = Rx.Observable.fromEvent(document.body, 'click');\nvar source = click.map(e => Rx.Observable.interval(1000));\nvar example = source.switch();\n```\n```\nclick  : ---------c-c------------------c--.. \n        map(e => Rx.Observable.interval(1000))\nsource : ---------o-o------------------o--..\n                   \\ \\                  \\----0----1--...\n                    \\ ----0----1----2----3----4--...\n                     ----0----1----2----3----4--...\n                     switch()\nexample: -----------------0----1----2--------0----1--...\n```\n\n#### `Utility Operators`\n- `delay`: 延迟源`Obs`发出的第一个元素的时间点\n```js\nvar source = Rx.Observable.interval(300).take(5);\nvar example = source.delay(500);\n```\n```\nsource : --0--1--2--3--4|\n        delay(500)\nexample: -------0--1--2--3--4|\n```\n\n- `delayWhen`: `delayWhen` 会响每个元素，调用的时候需要设置 `delayDurationSelector` 函数，该函数的返回值是 `Observable` 对象\n```js\nvar source = Rx.Observable.interval(300).take(5);\nvar example = source.delayWhen( x => Rx.Observable.interval(100 * x).take(1));\n```\n```\nsource : --0--1--2--3--4|\n    .delayWhen(x => Rx.Observable.interval(100 * x).take(1));\nexample: --0---1----2-----3------4|\n```\n\n#### `Multicasting Operators`\n- `multicast`: 用于挂载`Subject`，并返回一个可链接的`Obs`对象\n```js\nvar source = Rx.Observable.interval(1000)\n             .take(3)\n             .multicast(new Rx.Subject());\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n};\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n};\nsource.subscribe(observerA); // subject.subscribe(observerA)\nsource.connect(); // source.subscribe(subject)\nsetTimeout(() => {\n    source.subscribe(observerB); // subject.subscribe(observerA)\n}, 1000);\n```\n- `refCount`: 使 `multicast Observalbe`可以在第一个`subscriber`到达时自动执行，并在最后一个`subscriber`离开时结束。\n`refCount()`存在于`ConnectableObservable`上，并返回一个新的`Observalbe`\n```js\nvar source = Rx.Observable.interval(1000)\n             .do(x => console.log('send: ' + x))\n             .multicast(new Rx.Subject())\n             .refCount();\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n};\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n}\nvar subscriptionA = source.subscribe(observerA);\n// 订阅数 0 => 1\nvar subscriptionB;\nsetTimeout(() => {\n    subscriptionB = source.subscribe(observerB);\n    // 订阅数 1 => 2\n}, 1000);\nsetTimeout(() => {\n    subscriptionA.unsubscribe(); // 订阅数 2 => 1\n    subscriptionB.unsubscribe(); // 订阅数 1 => 0，source 停止发送元素\n}, 5000);\n```\n\n- `publish`: 用于挂载 `Subject` 对象，并返回一个可链接 (connectable) 的 `Obs`, `publish` `multicast(new Rx.Subject())` 等价\n```js\nvar source = Rx.Observable.interval(1000)\n             .publish() \n             .refCount();        \nvar source = Rx.Observable.interval(1000)\n             .multicast(new Rx.Subject()) \n             .refCount();\n```\n- `publishReplay`\n```js\nvar source = Rx.Observable.interval(1000)\n             .publishReplay(1) \n             .refCount();          \nvar source = Rx.Observable.interval(1000)\n            .multicast(new Rx.ReplaySubject(1)) \n            .refCount();\n```\n\n- `publishBehavior`\n```js\nvar source = Rx.Observable.interval(1000)\n             .publishBehavior(0) \n             .refCount();           \nvar source = Rx.Observable.interval(1000)\n             .multicast(new Rx.BehaviorSubject(0)) \n             .refCount();\n```\n\n- `publishLast`\n```js\nvar source = Rx.Observable.interval(1000)\n             .publishLast() \n             .refCount();          \nvar source = Rx.Observable.interval(1000)\n             .multicast(new Rx.AsyncSubject(1)) \n             .refCount();\n```\n\n- `share`: `publish` + `refCount` 的简写\n```js\nvar source = Rx.Observable.interval(1000)\n             .share();          \nvar source = Rx.Observable.interval(1000)\n             .publish()\n             .refCount();\nvar source = Rx.Observable.interval(1000)\n             .multicast(new Rx.Subject()) \n             .refCount();\n```\n\n#### `Error Handling Operators`\n- `catch`: 捕获异常，同时返回一个 `Obs`，用于发出新的值\n```js\nvar source = Rx.Observable.from(['a','b','c','d',2])\n               .zip(Rx.Observable.interval(500), (x,y) => x);\nvar example = source.map(x => x.toUpperCase())\n                    .catch(error => Rx.Observable.of('h'));\n```\n```\nsource : ----a----b----c----d----2|\n        map(x => x.toUpperCase())\n         ----a----b----c----d----X|\n        catch(error => Rx.Observable.of('h'))\nexample: ----A----B----C----D----h|\n```\n- `retry`: 发生错误后，重试 `count` 次数\n```js\nvar source = Rx.Observable.from(['a','b','c','d',2])\n               .zip(Rx.Observable.interval(500), (x,y) => x);\nvar example = source.map(x => x.toUpperCase())\n                    .retry(1);\n```\n```\nsource : ----a----b----c----d----2|\n        map(x => x.toUpperCase())\n         ----a----b----c----d----X|\n                retry(1)\nexample: ----A----B----C----D--------A----B----C----D----X|\n```\n\n- `retryWhen`: 捕获异常 `Obs`, 处理后可以重新订阅源`Obs`\n```js\nvar source = Rx.Observable.from(['a','b','c','d',2])\n               .zip(Rx.Observable.interval(500), (x,y) => x);\nvar example = source.map(x => x.toUpperCase())\n                    .retryWhen(errorObs => errorObs.delay(1000));\n```\n```\nsource : ----a----b----c----d----2|\n        map(x => x.toUpperCase())\n         ----a----b----c----d----X|\n        retryWhen(errorObs => errorObs.delay(1000))\nexample: ----A----B----C----D-------------------A----B----C----D----...\n```\n\n### Subject\n - `Subject`: 继承于`Observable`的 `Observer Pattern` 的实例\n`Subject` 既是 `Observable` 又是 `Observer`\n`Subject` 会对內部的 `observers` 列表进行组播(multicast)\n\n```js\nvar subject = new Rx.Subject();\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n}\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n}\nsubject.subscribe(observerA);\nsubject.subscribe(observerB);\nsubject.next(1);\n// \"A next: 1\"\n// \"B next: 1\"\nsubject.next(2);\n// \"A next: 2\"\n// \"B next: 2\"\n```\n- `BehaviorSubject`: 会记住最新一次推送的元素，并把该元素当做当前值推送（建立时需给定状态）\n```js\nvar subject = new Rx.BehaviorSubject(0); // 0 為起始值\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n}\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n}\nsubject.subscribe(observerA);\n// \"A next: 0\"\nsubject.next(1);\n// \"A next: 1\"\nsubject.next(2);\n// \"A next: 2\"\nsubject.next(3);\n// \"A next: 3\"\nsetTimeout(() => {\n    subject.subscribe(observerB); \n    // \"B next: 3\"\n},3000)\n```\n\n- `ReplaySubject`: 在新订阅后重新发送最后几个元素\n```js\nvar subject = new Rx.ReplaySubject(2); // 重複發送最後 2 個元素\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n}\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n}\nsubject.subscribe(observerA);\nsubject.next(1);\n// \"A next: 1\"\nsubject.next(2);\n// \"A next: 2\"\nsubject.next(3);\n// \"A next: 3\"\nsetTimeout(() => {\n    subject.subscribe(observerB);\n    // \"B next: 2\"\n    // \"B next: 3\"\n},3000)\n```\n\n- `AsyncSubject`: 在`subject`结束后送出最后一个值并结束\n```js\nvar subject = new Rx.AsyncSubject();\nvar observerA = {\n    next: value => console.log('A next: ' + value),\n    error: error => console.log('A error: ' + error),\n    complete: () => console.log('A complete!')\n}\nvar observerB = {\n    next: value => console.log('B next: ' + value),\n    error: error => console.log('B error: ' + error),\n    complete: () => console.log('B complete!')\n}\nsubject.subscribe(observerA);\nsubject.next(1);\nsubject.next(2);\nsubject.next(3);\nsubject.complete();\n// \"A next: 3\"\n// \"A complete!\"\nsetTimeout(() => {\n    subject.subscribe(observerB);\n    // \"B next: 3\"\n    // \"B complete!\"\n},3000)\n```\n\n\n### Observer\n - `next`: 当Observable推送新值时调用\n - `complete`: 当Observable所有值调用完毕之后，调用后next将不再起作用\n - `error`: 报错时\n```js\nvar observer = {\n\tnext: function(value) {\n\t\tconsole.log(value);\n\t},\n\terror: function(error) {\n\t\tconsole.log(error)\n\t},\n\tcomplete: function() {\n\t\tconsole.log('complete')\n\t}\n}\n//  使用之前定义的观察者来订阅\nobservable.subscribe(observer)\n// Jerry\n// Anna\n// complete\n```\n\n\n### Scheduler\n- 数据结构，知道如何根据优先级或其他标准来执行并列任务\n- 执行环境，知道事件何时何处执行\n- 虚拟时钟，可以让事件在特定时间执行\n","slug":"Rx入门学习","published":1,"updated":"2017-08-13T15:12:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl1u0005ttwpux7o7yql","content":"<h2 id=\"RXjs\"><a href=\"#RXjs\" class=\"headerlink\" title=\"RXjs\"></a>RXjs</h2><h3 id=\"Functional-Programming\"><a href=\"#Functional-Programming\" class=\"headerlink\" title=\"Functional Programming\"></a>Functional Programming</h3><ul>\n<li>Expression, no Statement</li>\n<li>Pure Function</li>\n<li>利用参数保存状态</li>\n</ul>\n<h3 id=\"建立Observable\"><a href=\"#建立Observable\" class=\"headerlink\" title=\"建立Observable\"></a>建立Observable</h3><p>统一订阅</p>\n<pre><code class=\"js\">observable.subscribe({\n    next: function(value) {\n        console.log(value)\n    },\n    complete: function() {\n        console.log(&#39;complete!&#39;);\n    },\n    error: function(error) {\n        console.log(error)\n    }\n});\n</code></pre>\n<ul>\n<li><p><code>create</code></p>\n<pre><code class=\"js\">/**\n@param: `callback function`\n*/\nvar observable = Rx.Observable\n.create(function(observer) {\n  observer.next(&#39;Jerry&#39;); // RxJS 4.x 以前的版本用 onNext\n  observer.next(&#39;Anna&#39;);\n})\n</code></pre>\n</li>\n<li><p><code>of</code><br>多个传递值</p>\n<pre><code class=\"js\">var observable = Rx.Observable.of(&#39;Jerry&#39;, &#39;Anna&#39;);\n</code></pre>\n</li>\n<li><p><code>from</code><br>数组，字符串，promise对象</p>\n<pre><code class=\"js\">var params = [&#39;Jerry&#39;, &#39;Anna&#39;]  // 数组\nvar params = &#39;Jerry&#39; // 字符串\nvar params = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n      resolve(&#39;hi&#39;)\n  }, 300)\n})                  // promise对象\nvar observable = Rx.Observable.from(params)\n</code></pre>\n</li>\n<li><p><code>fromEvent</code><br>为DOM元素添加监听事件<br>param1: DOM对象，param2: 监听事件</p>\n<pre><code class=\"js\">var observable = Rx.Observable.fromEvent($DOM, $event);\n</code></pre>\n</li>\n<li><p><code>fromEventPattern</code><br>同时具有注册移除监听的类事件使用</p>\n<pre><code class=\"js\">class Producer {\n  constructor() {\n      this.listeners = [];\n  }\n  addListener(listener) {\n      if(typeof listener === &#39;function&#39;) {\n          this.listeners.push(listener)\n      } else {\n          throw new Error(&#39;listener 必須是 function&#39;)\n      }\n  }\n  removeListener(listener) {\n      this.listeners.splice(this.listeners.indexOf(listener), 1)\n  }\n  notify(message) {\n      this.listeners.forEach(listener =&gt; {\n          listener(message);\n      })\n  }\n}\nvar egghead = new Producer(); \nvar source = Rx.Observable\n  .fromEventPattern(\n      (handler) =&gt; egghead.addListener(handler), \n      (handler) =&gt; egghead.removeListener(handler)\n  ); \nsource.subscribe({\n  next: function(value) {\n      console.log(value)\n  },\n  complete: function() {\n      console.log(&#39;complete!&#39;);\n  },\n  error: function(error) {\n      console.log(error)\n  }\n})\negghead.notify(&#39;Hello! Can you hear me?&#39;);\n// Hello! Can you hear me?\n</code></pre>\n</li>\n</ul>\n<ul>\n<li><p><code>empty</code><br>给出一个空的Observable，如果订阅这个Observable则会立即push出complete</p>\n<pre><code class=\"js\">var source = Rx.Observable.empty()\n</code></pre>\n</li>\n<li><p><code>never</code><br>给出一个无穷的Observable，订阅后将什么都不发生，但存在</p>\n<pre><code class=\"js\">var source = Rx.Observable.never()\n</code></pre>\n</li>\n<li><p><code>throw</code><br>给出一个错误的Observable，订阅后将直接抛出错误</p>\n<pre><code class=\"js\">var source = Rx.Observable.throw()\n</code></pre>\n</li>\n<li><p><code>interval</code><br>每隔一段时间推送出一个从零开始递增的整数</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(666)\n</code></pre>\n</li>\n<li><p><code>timer</code><br><code>param_one</code>: 发出第一个值的等待时间(number)/等待到的日期(Date)<br><code>param_two</code>: 第一个值发出之后发送每个值的间隔时间<br>如果只有一个参数，发出第一个值之后触发complete</p>\n<pre><code class=\"js\">var source = Rx.Observable.timer(5000, 1000)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Subscription\"><a href=\"#Subscription\" class=\"headerlink\" title=\"Subscription\"></a>Subscription</h3><p>订阅Observable后会回传一个subscription对象，这个对象含有释放资源的<code>unsubscribe</code>方法，可以停止订阅</p>\n<pre><code class=\"js\">var source = Rx.Observable.timer(1000, 1000);\n// 取得 subscription\nvar subscription = source.subscribe({\n    next: function(value) {\n        console.log(value)\n    },\n    complete: function() {\n        console.log(&#39;complete!&#39;);\n    },\n    error: function(error) {\n    console.log(&#39;Throw Error: &#39; + error)\n    }\n});\nsetTimeout(() =&gt; {\n    subscription.unsubscribe()\n}, 5000)\n// 输出: 0,1,2,3,4\n</code></pre>\n<h3 id=\"Operator\"><a href=\"#Operator\" class=\"headerlink\" title=\"Operator\"></a>Operator</h3><p><code>Operators</code>是一个个被附加到<code>Observable</code>上的方法，经过这些方法传递出一个新的<code>observable</code></p>\n<h4 id=\"Transformation-Operators\"><a href=\"#Transformation-Operators\" class=\"headerlink\" title=\"Transformation Operators\"></a>Transformation Operators</h4><ul>\n<li><code>map</code>: 对 <code>Observable</code> 对象发出的每个值，使用指定的 <code>project</code> 函数，进行映射处理<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar newest = source.map(x =&gt; x + 2); \nnewest.subscribe(console.log);\n</code></pre>\n<pre><code>source: -----0-----1-----2-----3--...\n          map(x =&gt; x + 2)\nnewest: -----2-----3-----4-----5--...\n</code></pre></li>\n<li><code>mapTo</code>: 对 <code>Observable</code> 对象发出的每个值，映射成固定的值<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar newest = source.mapTo(2); \nnewest.subscribe(console.log);\n</code></pre>\n<pre><code>source: -----0-----1-----2-----3--...\n              mapTo(2)\nnewest: -----2-----2-----2-----2--...\n</code></pre></li>\n<li><p><code>scan</code>: 对 <code>Observable</code> 发出值，执行 <code>accumulator</code> 指定的运算，类似于 <code>reduce</code> </p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\nvar newest = source.scan( count =&gt; count + 5, &#39;2&#39;)\nnewest.subscribe(console.log);\n</code></pre>\n<pre><code>source: -----0------1------2------3--...\n      scan( x =&gt; x + 5, 0)\nnewest: -----5-----10-----15-----20--...\n</code></pre></li>\n<li><p><code>buffer</code>: 缓冲源 <code>Observable</code> 对象已发出的值，直到 <code>closingNotifier</code> 触发后，统一输出缓存的元素</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300);\nvar source2 = Rx.Observable.interval(1000);\nvar example = source.buffer(source2);\nexample.subscribe(...);\n</code></pre>\n<pre><code>source : --0--1--2--3--4--5--6--7..\nsource2: ---------0---------1--------...\n          buffer(source2)\nexample: ---------([0,1,2])---------([3,4,5])\n</code></pre></li>\n<li><p><code>bufferTime</code>: 设定源 <code>Observable</code> 对象已发出的值的缓冲时间</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300);\nvar example = source.bufferTime(1000);\nexample.subscribe(...);\n</code></pre>\n<pre><code>source : --0--1--2--3--4--5--6--7..\n          bufferTime(1000)\nexample: ---------([0,1,2])---------([3,4,5])\n</code></pre></li>\n<li><p><code>bufferCount</code>: 缓冲源 <code>Observable</code> 对象已发出的值，直到大小达到给定的最大 <code>bufferSize</code> </p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300);\nvar example = source.bufferCount(3);\nexample.subscribe(...);\n</code></pre>\n<pre><code>source : --0--1--2--3--4--5--6--7..\n          bufferCount(3)\nexample: ---------([0,1,2])---------([3,4,5])\n</code></pre></li>\n<li><p><code>concatMap</code>: 对每个 <code>Observable</code> 对象发出的值，进行映射处理，并进行合并。该操作符也会依序所有<code>Observable</code> 对象</p>\n<pre><code class=\"js\">var source = Rx.Observable.fromEvent(document.body, &#39;click&#39;);\nvar example = source.concatMap(e =&gt; Rx.Observable.interval(100).take(3));\nexample.subscribe(...);\n</code></pre>\n<pre><code>source : -----------c--c------------------...\n      concatMap(c =&gt; Rx.Observable.interval(100).take(3))\nexample: -------------0-1-2-0-1-2---------...\n</code></pre></li>\n<li><p><code>switchMap</code>: 对源 <code>Observable</code> 对象发出的值，做映射处理。若有新的 <code>Observable</code> 对象出现，会在新的 <code>Observable</code> 对象发出新值后，退订前一个未处理完的 <code>Observable</code> 对象</p>\n<pre><code class=\"js\">var source = Rx.Observable.fromEvent(document.body, &#39;click&#39;);\nvar example = source.switchMap(e =&gt; Rx.Observable.interval(100).take(3));\nexample.subscribe(...);\n</code></pre>\n<pre><code>source : -----------c--c-----------------...\n      concatMap(c =&gt; Rx.Observable.interval(100).take(3))\nexample: -------------0--0-1-2-----------...\n</code></pre></li>\n</ul>\n<h4 id=\"Filtering-Operators\"><a href=\"#Filtering-Operators\" class=\"headerlink\" title=\"Filtering Operators\"></a>Filtering Operators</h4><ul>\n<li><p><code>filter</code>: 过滤值</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar newest = source.filter(x =&gt; x % 2 === 0);\n</code></pre>\n<pre><code>source: -----0-----1-----2-----3-----4-...\n          filter(x =&gt; x % 2 === 0)\nnewest: -----0-----------2-----------4-...\n</code></pre></li>\n<li><p><code>take</code>: 获取 <code>Observable</code> 对象发出的前n项值，取完结束。</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar example = source.take(3);\n</code></pre>\n<pre><code>source : -----0-----1-----2-----3--..\n              take(3)\nexample: -----0-----1-----2|\n</code></pre></li>\n<li><p><code>first</code>: 获取 <code>Observable</code> 对象发出的第一个元素，取完结束。</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar example = source.first();\n</code></pre>\n<pre><code>source : -----0-----1-----2-----3--..\n              first()\nexample: -----0|\n</code></pre></li>\n<li><p><code>takeUntil</code>: 当 <code>takeUntil</code> 传入的 <code>notifier</code> 发出值时，源 <code>Observable</code> 对象就会直接进入完成状态</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar click = Rx.Observable.fromEvent(document.body, &#39;click&#39;);\nvar example = source.takeUntil(click);\n</code></pre>\n<pre><code>source : -----0-----1-----2------3--\nclick  : ----------------------c----\n              takeUntil(click)\nexample: -----0-----1-----2----|\n</code></pre></li>\n<li><p><code>skip</code>: 跳过 源<code>Observable</code>的前n项，并返回新的<code>Observable</code>对象</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar example = source.skip(3);\n</code></pre>\n<pre><code>source : ----0----1----2----3----4----5--....\n                  skip(3)\nexample: -------------------3----4----5--...\n</code></pre></li>\n<li><p><code>takeLast</code>: 获取 源<code>Observable</code>发出的后n项</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000).take(6);\nvar example = source.takeLast(2);\n</code></pre>\n<pre><code>source : ----0----1----2----3----4----5|\n              takeLast(2)\nexample: ------------------------------(45)|\n</code></pre></li>\n<li><p><code>last</code>: 获取 源<code>Observable</code>发出的最后一项</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000).take(6);\nvar example = source.last();\n</code></pre>\n<pre><code>source : ----0----1----2----3----4----5|\n                  last()\nexample: ------------------------------(5)|\n</code></pre></li>\n<li><p><code>debounceTime</code>: 在设定的时间跨度内，若源 <code>Observable</code> 对象没有再发出新值，则返回最近一次发出的值</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300).take(5);\nvar example = source.debounceTime(1000);\n</code></pre>\n<pre><code>source : --0--1--2--3--4|\n      debounceTime(1000)\nexample: --------------4|\n</code></pre></li>\n<li><p><code>throttleTime</code>: 节流，从 源<code>Observable</code>对象发出的第一个值开始，忽略等待时间内发出的值</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300).take(5);\nvar example = source.throttleTime(1000);\n</code></pre>\n<pre><code>source : --0--1--2--3--4|\n      throttleTime(1000)\nexample: --0------------4|\n</code></pre></li>\n<li><p><code>distinct</code>: 去重</p>\n<pre><code class=\"js\">var source = Rx.Observable.from([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;])\nvar example = source.distinct()\n</code></pre>\n<pre><code>source : --a--b--c--a--b|\n          distinct()\nexample: --a--b--c------|\n</code></pre></li>\n<li><p><code>distinctUntilChanged</code>: 过滤 <code>Observable</code>发出的值，若当前值与上一次值不一致，则发出该值。</p>\n<pre><code class=\"js\">var source = Rx.Observable.from([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;b&#39;])\nvar example = source.distinctUntilChanged()\n</code></pre>\n<pre><code>source : --a--b--c--c--b|\n          distinctUntilChanged()\nexample: --a--b--c-----b|\n</code></pre><h4 id=\"Combination-Operators\"><a href=\"#Combination-Operators\" class=\"headerlink\" title=\"Combination Operators\"></a><code>Combination Operators</code></h4></li>\n<li><p><code>concat</code>: 合并多个<code>Observable</code>对象，并依次执行</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000).take(3);\nvar source2 = Rx.Observable.of(3)\nvar source3 = Rx.Observable.of(4,5,6)\nvar example = source.concat(source2, source3);\n</code></pre>\n<pre><code>source : ----0----1----2|\nsource2: (3)|\nsource3: (456)|\n          concat()\nexample: ----0----1----2(3456)|\n</code></pre></li>\n<li><p><code>concatAll</code>: 合并多个<code>Observable</code>对象，并在上一个<code>Obs</code>完成订阅后订阅下一个<code>Obs</code></p>\n<pre><code class=\"js\">var obs1 = Rx.Observable.interval(1000).take(5);\nvar obs2 = Rx.Observable.interval(500).take(2);\nvar obs3 = Rx.Observable.interval(2000).take(1);\nvar source = Rx.Observable.of(obs1, obs2, obs3);\nvar example = source.concatAll();\n</code></pre>\n<pre><code>source : (o1                 o2      o3)|\n         \\                  \\       \\\n          --0--1--2--3--4|   -0-1|   ----0|               \n              concatAll()        \nexample: --0--1--2--3--4-0-1----0|\n</code></pre></li>\n<li><p><code>startWith</code>: 在开始发出<code>Obs</code>对象的数据之前发出已经设置的参数</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar example = source.startWith(222);\n</code></pre>\n<pre><code>source : ----0----1----2----3--...\n              startWith(222)\nexample: (222)----0----1----2----3--...\n</code></pre></li>\n<li><p><code>merage</code>: 合并 <code>Obs</code>对象，并按给定的时序发出对应值</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(500).take(3);\nvar source2 = Rx.Observable.interval(300).take(6);\nvar example = source.merge(source2);\n</code></pre>\n<pre><code>source : ----0----1----2|\nsource2: --0--1--2--3--4--5|\n          merge()\nexample: --0-01--21-3--(24)--5|\n</code></pre></li>\n<li><p><code>merageAll</code>: 将高阶<code>Obs</code>转换为一阶<code>Obs</code>，并同时处理所有<code>Obs</code></p>\n<pre><code class=\"js\">var click = Rx.Observable.fromEvent(document.body, &#39;click&#39;);\nvar source = click.map(e =&gt; Rx.Observable.interval(1000));\nvar example = source.mergeAll();\n</code></pre>\n<pre><code>click  : ---------c-c------------------c--.. \n      map(e =&gt; Rx.Observable.interval(1000))\nsource : ---------o-o------------------o--..\n                 \\ \\                  \\----0----1--...\n                  \\ ----0----1----2----3----4--...\n                   ----0----1----2----3----4--...\n                   mergeAll()\nexample: ----------------00---11---22---33---(04)4--...\n</code></pre></li>\n<li><p><code>combineLatest</code>: 合并输入的<code>Obs</code>对象，当源<code>Obs</code>和其他<code>Obs</code>都发出值后，才会调用<code>project</code>函数</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(500).take(3);\nvar newest = Rx.Observable.interval(300).take(6);\nvar example = source.combineLatest(newest, (x, y) =&gt; x + y);\n</code></pre>\n<pre><code>source : ----0----1----2|\nnewest : --0--1--2--3--4--5|\n  combineLatest(newest, (x, y) =&gt; x + y);\nexample: ----01--23-4--(56)--7|\n</code></pre></li>\n<li><p><code>zip</code>: 根据所有的<code>Obs</code>对象的输入顺序，产生一个新<code>Obs</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(500).take(3);\nvar newest = Rx.Observable.interval(300).take(6);\nvar example = source.zip(newest, (x, y) =&gt; x + y);\n</code></pre>\n<pre><code>source : ----0----1----2|\nnewest : --0--1--2--3--4--5|\n  zip(newest, (x, y) =&gt; x + y)\nexample: ----0----2----4|\n</code></pre></li>\n<li><p><code>withLatestFrom</code>: 当源<code>Obs</code>发出新值时，根据<code>project</code>函数，合并其他<code>Obs</code>之前发出的最新值</p>\n<pre><code class=\"js\">var main = Rx.Observable.from(&#39;hello&#39;).zip(Rx.Observable.interval(500), \n  (x, y) =&gt; x);\nvar some = Rx.Observable.from([0,1,0,0,0,1]).zip(Rx.Observable.interval(300), \n  (x, y) =&gt; x);\nvar example = main.withLatestFrom(some, (x, y) =&gt; {\n  return y === 1 ? x.toUpperCase() : x;\n});\n</code></pre>\n<pre><code>main   : ----h----e----l----l----o|\nsome   : --0--1--0--0--0--1|\nwithLatestFrom(some, (x, y) =&gt;  y === 1 ? x.toUpperCase() : x);\nexample: ----h----e----l----L----O|\n</code></pre></li>\n<li><p><code>switch</code>: 切换为最新的<code>Obs</code>数据源，并退订之前的<code>Obs</code></p>\n<pre><code class=\"js\">var click = Rx.Observable.fromEvent(document.body, &#39;click&#39;);\nvar source = click.map(e =&gt; Rx.Observable.interval(1000));\nvar example = source.switch();\n</code></pre>\n<pre><code>click  : ---------c-c------------------c--.. \n      map(e =&gt; Rx.Observable.interval(1000))\nsource : ---------o-o------------------o--..\n                 \\ \\                  \\----0----1--...\n                  \\ ----0----1----2----3----4--...\n                   ----0----1----2----3----4--...\n                   switch()\nexample: -----------------0----1----2--------0----1--...\n</code></pre></li>\n</ul>\n<h4 id=\"Utility-Operators\"><a href=\"#Utility-Operators\" class=\"headerlink\" title=\"Utility Operators\"></a><code>Utility Operators</code></h4><ul>\n<li><p><code>delay</code>: 延迟源<code>Obs</code>发出的第一个元素的时间点</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300).take(5);\nvar example = source.delay(500);\n</code></pre>\n<pre><code>source : --0--1--2--3--4|\n      delay(500)\nexample: -------0--1--2--3--4|\n</code></pre></li>\n<li><p><code>delayWhen</code>: <code>delayWhen</code> 会响每个元素，调用的时候需要设置 <code>delayDurationSelector</code> 函数，该函数的返回值是 <code>Observable</code> 对象</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300).take(5);\nvar example = source.delayWhen( x =&gt; Rx.Observable.interval(100 * x).take(1));\n</code></pre>\n<pre><code>source : --0--1--2--3--4|\n  .delayWhen(x =&gt; Rx.Observable.interval(100 * x).take(1));\nexample: --0---1----2-----3------4|\n</code></pre></li>\n</ul>\n<h4 id=\"Multicasting-Operators\"><a href=\"#Multicasting-Operators\" class=\"headerlink\" title=\"Multicasting Operators\"></a><code>Multicasting Operators</code></h4><ul>\n<li><code>multicast</code>: 用于挂载<code>Subject</code>，并返回一个可链接的<code>Obs</code>对象<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .take(3)\n           .multicast(new Rx.Subject());\nvar observerA = {\n  next: value =&gt; console.log(&#39;A next: &#39; + value),\n  error: error =&gt; console.log(&#39;A error: &#39; + error),\n  complete: () =&gt; console.log(&#39;A complete!&#39;)\n};\nvar observerB = {\n  next: value =&gt; console.log(&#39;B next: &#39; + value),\n  error: error =&gt; console.log(&#39;B error: &#39; + error),\n  complete: () =&gt; console.log(&#39;B complete!&#39;)\n};\nsource.subscribe(observerA); // subject.subscribe(observerA)\nsource.connect(); // source.subscribe(subject)\nsetTimeout(() =&gt; {\n  source.subscribe(observerB); // subject.subscribe(observerA)\n}, 1000);\n</code></pre>\n</li>\n<li><p><code>refCount</code>: 使 <code>multicast Observalbe</code>可以在第一个<code>subscriber</code>到达时自动执行，并在最后一个<code>subscriber</code>离开时结束。<br><code>refCount()</code>存在于<code>ConnectableObservable</code>上，并返回一个新的<code>Observalbe</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .do(x =&gt; console.log(&#39;send: &#39; + x))\n           .multicast(new Rx.Subject())\n           .refCount();\nvar observerA = {\n  next: value =&gt; console.log(&#39;A next: &#39; + value),\n  error: error =&gt; console.log(&#39;A error: &#39; + error),\n  complete: () =&gt; console.log(&#39;A complete!&#39;)\n};\nvar observerB = {\n  next: value =&gt; console.log(&#39;B next: &#39; + value),\n  error: error =&gt; console.log(&#39;B error: &#39; + error),\n  complete: () =&gt; console.log(&#39;B complete!&#39;)\n}\nvar subscriptionA = source.subscribe(observerA);\n// 订阅数 0 =&gt; 1\nvar subscriptionB;\nsetTimeout(() =&gt; {\n  subscriptionB = source.subscribe(observerB);\n  // 订阅数 1 =&gt; 2\n}, 1000);\nsetTimeout(() =&gt; {\n  subscriptionA.unsubscribe(); // 订阅数 2 =&gt; 1\n  subscriptionB.unsubscribe(); // 订阅数 1 =&gt; 0，source 停止发送元素\n}, 5000);\n</code></pre>\n</li>\n<li><p><code>publish</code>: 用于挂载 <code>Subject</code> 对象，并返回一个可链接 (connectable) 的 <code>Obs</code>, <code>publish</code> <code>multicast(new Rx.Subject())</code> 等价</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .publish() \n           .refCount();        \nvar source = Rx.Observable.interval(1000)\n           .multicast(new Rx.Subject()) \n           .refCount();\n</code></pre>\n</li>\n<li><p><code>publishReplay</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .publishReplay(1) \n           .refCount();          \nvar source = Rx.Observable.interval(1000)\n          .multicast(new Rx.ReplaySubject(1)) \n          .refCount();\n</code></pre>\n</li>\n<li><p><code>publishBehavior</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .publishBehavior(0) \n           .refCount();           \nvar source = Rx.Observable.interval(1000)\n           .multicast(new Rx.BehaviorSubject(0)) \n           .refCount();\n</code></pre>\n</li>\n<li><p><code>publishLast</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .publishLast() \n           .refCount();          \nvar source = Rx.Observable.interval(1000)\n           .multicast(new Rx.AsyncSubject(1)) \n           .refCount();\n</code></pre>\n</li>\n<li><p><code>share</code>: <code>publish</code> + <code>refCount</code> 的简写</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .share();          \nvar source = Rx.Observable.interval(1000)\n           .publish()\n           .refCount();\nvar source = Rx.Observable.interval(1000)\n           .multicast(new Rx.Subject()) \n           .refCount();\n</code></pre>\n</li>\n</ul>\n<h4 id=\"Error-Handling-Operators\"><a href=\"#Error-Handling-Operators\" class=\"headerlink\" title=\"Error Handling Operators\"></a><code>Error Handling Operators</code></h4><ul>\n<li><code>catch</code>: 捕获异常，同时返回一个 <code>Obs</code>，用于发出新的值<pre><code class=\"js\">var source = Rx.Observable.from([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,2])\n             .zip(Rx.Observable.interval(500), (x,y) =&gt; x);\nvar example = source.map(x =&gt; x.toUpperCase())\n                  .catch(error =&gt; Rx.Observable.of(&#39;h&#39;));\n</code></pre>\n<pre><code>source : ----a----b----c----d----2|\n      map(x =&gt; x.toUpperCase())\n       ----a----b----c----d----X|\n      catch(error =&gt; Rx.Observable.of(&#39;h&#39;))\nexample: ----A----B----C----D----h|\n</code></pre></li>\n<li><p><code>retry</code>: 发生错误后，重试 <code>count</code> 次数</p>\n<pre><code class=\"js\">var source = Rx.Observable.from([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,2])\n             .zip(Rx.Observable.interval(500), (x,y) =&gt; x);\nvar example = source.map(x =&gt; x.toUpperCase())\n                  .retry(1);\n</code></pre>\n<pre><code>source : ----a----b----c----d----2|\n      map(x =&gt; x.toUpperCase())\n       ----a----b----c----d----X|\n              retry(1)\nexample: ----A----B----C----D--------A----B----C----D----X|\n</code></pre></li>\n<li><p><code>retryWhen</code>: 捕获异常 <code>Obs</code>, 处理后可以重新订阅源<code>Obs</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.from([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,2])\n             .zip(Rx.Observable.interval(500), (x,y) =&gt; x);\nvar example = source.map(x =&gt; x.toUpperCase())\n                  .retryWhen(errorObs =&gt; errorObs.delay(1000));\n</code></pre>\n<pre><code>source : ----a----b----c----d----2|\n      map(x =&gt; x.toUpperCase())\n       ----a----b----c----d----X|\n      retryWhen(errorObs =&gt; errorObs.delay(1000))\nexample: ----A----B----C----D-------------------A----B----C----D----...\n</code></pre></li>\n</ul>\n<h3 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h3><ul>\n<li><code>Subject</code>: 继承于<code>Observable</code>的 <code>Observer Pattern</code> 的实例<br><code>Subject</code> 既是 <code>Observable</code> 又是 <code>Observer</code><br><code>Subject</code> 会对內部的 <code>observers</code> 列表进行组播(multicast)</li>\n</ul>\n<pre><code class=\"js\">var subject = new Rx.Subject();\nvar observerA = {\n    next: value =&gt; console.log(&#39;A next: &#39; + value),\n    error: error =&gt; console.log(&#39;A error: &#39; + error),\n    complete: () =&gt; console.log(&#39;A complete!&#39;)\n}\nvar observerB = {\n    next: value =&gt; console.log(&#39;B next: &#39; + value),\n    error: error =&gt; console.log(&#39;B error: &#39; + error),\n    complete: () =&gt; console.log(&#39;B complete!&#39;)\n}\nsubject.subscribe(observerA);\nsubject.subscribe(observerB);\nsubject.next(1);\n// &quot;A next: 1&quot;\n// &quot;B next: 1&quot;\nsubject.next(2);\n// &quot;A next: 2&quot;\n// &quot;B next: 2&quot;\n</code></pre>\n<ul>\n<li><p><code>BehaviorSubject</code>: 会记住最新一次推送的元素，并把该元素当做当前值推送（建立时需给定状态）</p>\n<pre><code class=\"js\">var subject = new Rx.BehaviorSubject(0); // 0 為起始值\nvar observerA = {\n  next: value =&gt; console.log(&#39;A next: &#39; + value),\n  error: error =&gt; console.log(&#39;A error: &#39; + error),\n  complete: () =&gt; console.log(&#39;A complete!&#39;)\n}\nvar observerB = {\n  next: value =&gt; console.log(&#39;B next: &#39; + value),\n  error: error =&gt; console.log(&#39;B error: &#39; + error),\n  complete: () =&gt; console.log(&#39;B complete!&#39;)\n}\nsubject.subscribe(observerA);\n// &quot;A next: 0&quot;\nsubject.next(1);\n// &quot;A next: 1&quot;\nsubject.next(2);\n// &quot;A next: 2&quot;\nsubject.next(3);\n// &quot;A next: 3&quot;\nsetTimeout(() =&gt; {\n  subject.subscribe(observerB); \n  // &quot;B next: 3&quot;\n},3000)\n</code></pre>\n</li>\n<li><p><code>ReplaySubject</code>: 在新订阅后重新发送最后几个元素</p>\n<pre><code class=\"js\">var subject = new Rx.ReplaySubject(2); // 重複發送最後 2 個元素\nvar observerA = {\n  next: value =&gt; console.log(&#39;A next: &#39; + value),\n  error: error =&gt; console.log(&#39;A error: &#39; + error),\n  complete: () =&gt; console.log(&#39;A complete!&#39;)\n}\nvar observerB = {\n  next: value =&gt; console.log(&#39;B next: &#39; + value),\n  error: error =&gt; console.log(&#39;B error: &#39; + error),\n  complete: () =&gt; console.log(&#39;B complete!&#39;)\n}\nsubject.subscribe(observerA);\nsubject.next(1);\n// &quot;A next: 1&quot;\nsubject.next(2);\n// &quot;A next: 2&quot;\nsubject.next(3);\n// &quot;A next: 3&quot;\nsetTimeout(() =&gt; {\n  subject.subscribe(observerB);\n  // &quot;B next: 2&quot;\n  // &quot;B next: 3&quot;\n},3000)\n</code></pre>\n</li>\n<li><p><code>AsyncSubject</code>: 在<code>subject</code>结束后送出最后一个值并结束</p>\n<pre><code class=\"js\">var subject = new Rx.AsyncSubject();\nvar observerA = {\n  next: value =&gt; console.log(&#39;A next: &#39; + value),\n  error: error =&gt; console.log(&#39;A error: &#39; + error),\n  complete: () =&gt; console.log(&#39;A complete!&#39;)\n}\nvar observerB = {\n  next: value =&gt; console.log(&#39;B next: &#39; + value),\n  error: error =&gt; console.log(&#39;B error: &#39; + error),\n  complete: () =&gt; console.log(&#39;B complete!&#39;)\n}\nsubject.subscribe(observerA);\nsubject.next(1);\nsubject.next(2);\nsubject.next(3);\nsubject.complete();\n// &quot;A next: 3&quot;\n// &quot;A complete!&quot;\nsetTimeout(() =&gt; {\n  subject.subscribe(observerB);\n  // &quot;B next: 3&quot;\n  // &quot;B complete!&quot;\n},3000)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Observer\"><a href=\"#Observer\" class=\"headerlink\" title=\"Observer\"></a>Observer</h3><ul>\n<li><code>next</code>: 当Observable推送新值时调用</li>\n<li><code>complete</code>: 当Observable所有值调用完毕之后，调用后next将不再起作用</li>\n<li><code>error</code>: 报错时<pre><code class=\"js\">var observer = {\n next: function(value) {\n     console.log(value);\n },\n error: function(error) {\n     console.log(error)\n },\n complete: function() {\n     console.log(&#39;complete&#39;)\n }\n}\n//  使用之前定义的观察者来订阅\nobservable.subscribe(observer)\n// Jerry\n// Anna\n// complete\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Scheduler\"><a href=\"#Scheduler\" class=\"headerlink\" title=\"Scheduler\"></a>Scheduler</h3><ul>\n<li>数据结构，知道如何根据优先级或其他标准来执行并列任务</li>\n<li>执行环境，知道事件何时何处执行</li>\n<li>虚拟时钟，可以让事件在特定时间执行</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"RXjs\"><a href=\"#RXjs\" class=\"headerlink\" title=\"RXjs\"></a>RXjs</h2><h3 id=\"Functional-Programming\"><a href=\"#Functional-Programming\" class=\"headerlink\" title=\"Functional Programming\"></a>Functional Programming</h3><ul>\n<li>Expression, no Statement</li>\n<li>Pure Function</li>\n<li>利用参数保存状态</li>\n</ul>\n<h3 id=\"建立Observable\"><a href=\"#建立Observable\" class=\"headerlink\" title=\"建立Observable\"></a>建立Observable</h3><p>统一订阅</p>\n<pre><code class=\"js\">observable.subscribe({\n    next: function(value) {\n        console.log(value)\n    },\n    complete: function() {\n        console.log(&#39;complete!&#39;);\n    },\n    error: function(error) {\n        console.log(error)\n    }\n});\n</code></pre>\n<ul>\n<li><p><code>create</code></p>\n<pre><code class=\"js\">/**\n@param: `callback function`\n*/\nvar observable = Rx.Observable\n.create(function(observer) {\n  observer.next(&#39;Jerry&#39;); // RxJS 4.x 以前的版本用 onNext\n  observer.next(&#39;Anna&#39;);\n})\n</code></pre>\n</li>\n<li><p><code>of</code><br>多个传递值</p>\n<pre><code class=\"js\">var observable = Rx.Observable.of(&#39;Jerry&#39;, &#39;Anna&#39;);\n</code></pre>\n</li>\n<li><p><code>from</code><br>数组，字符串，promise对象</p>\n<pre><code class=\"js\">var params = [&#39;Jerry&#39;, &#39;Anna&#39;]  // 数组\nvar params = &#39;Jerry&#39; // 字符串\nvar params = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n      resolve(&#39;hi&#39;)\n  }, 300)\n})                  // promise对象\nvar observable = Rx.Observable.from(params)\n</code></pre>\n</li>\n<li><p><code>fromEvent</code><br>为DOM元素添加监听事件<br>param1: DOM对象，param2: 监听事件</p>\n<pre><code class=\"js\">var observable = Rx.Observable.fromEvent($DOM, $event);\n</code></pre>\n</li>\n<li><p><code>fromEventPattern</code><br>同时具有注册移除监听的类事件使用</p>\n<pre><code class=\"js\">class Producer {\n  constructor() {\n      this.listeners = [];\n  }\n  addListener(listener) {\n      if(typeof listener === &#39;function&#39;) {\n          this.listeners.push(listener)\n      } else {\n          throw new Error(&#39;listener 必須是 function&#39;)\n      }\n  }\n  removeListener(listener) {\n      this.listeners.splice(this.listeners.indexOf(listener), 1)\n  }\n  notify(message) {\n      this.listeners.forEach(listener =&gt; {\n          listener(message);\n      })\n  }\n}\nvar egghead = new Producer(); \nvar source = Rx.Observable\n  .fromEventPattern(\n      (handler) =&gt; egghead.addListener(handler), \n      (handler) =&gt; egghead.removeListener(handler)\n  ); \nsource.subscribe({\n  next: function(value) {\n      console.log(value)\n  },\n  complete: function() {\n      console.log(&#39;complete!&#39;);\n  },\n  error: function(error) {\n      console.log(error)\n  }\n})\negghead.notify(&#39;Hello! Can you hear me?&#39;);\n// Hello! Can you hear me?\n</code></pre>\n</li>\n</ul>\n<ul>\n<li><p><code>empty</code><br>给出一个空的Observable，如果订阅这个Observable则会立即push出complete</p>\n<pre><code class=\"js\">var source = Rx.Observable.empty()\n</code></pre>\n</li>\n<li><p><code>never</code><br>给出一个无穷的Observable，订阅后将什么都不发生，但存在</p>\n<pre><code class=\"js\">var source = Rx.Observable.never()\n</code></pre>\n</li>\n<li><p><code>throw</code><br>给出一个错误的Observable，订阅后将直接抛出错误</p>\n<pre><code class=\"js\">var source = Rx.Observable.throw()\n</code></pre>\n</li>\n<li><p><code>interval</code><br>每隔一段时间推送出一个从零开始递增的整数</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(666)\n</code></pre>\n</li>\n<li><p><code>timer</code><br><code>param_one</code>: 发出第一个值的等待时间(number)/等待到的日期(Date)<br><code>param_two</code>: 第一个值发出之后发送每个值的间隔时间<br>如果只有一个参数，发出第一个值之后触发complete</p>\n<pre><code class=\"js\">var source = Rx.Observable.timer(5000, 1000)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Subscription\"><a href=\"#Subscription\" class=\"headerlink\" title=\"Subscription\"></a>Subscription</h3><p>订阅Observable后会回传一个subscription对象，这个对象含有释放资源的<code>unsubscribe</code>方法，可以停止订阅</p>\n<pre><code class=\"js\">var source = Rx.Observable.timer(1000, 1000);\n// 取得 subscription\nvar subscription = source.subscribe({\n    next: function(value) {\n        console.log(value)\n    },\n    complete: function() {\n        console.log(&#39;complete!&#39;);\n    },\n    error: function(error) {\n    console.log(&#39;Throw Error: &#39; + error)\n    }\n});\nsetTimeout(() =&gt; {\n    subscription.unsubscribe()\n}, 5000)\n// 输出: 0,1,2,3,4\n</code></pre>\n<h3 id=\"Operator\"><a href=\"#Operator\" class=\"headerlink\" title=\"Operator\"></a>Operator</h3><p><code>Operators</code>是一个个被附加到<code>Observable</code>上的方法，经过这些方法传递出一个新的<code>observable</code></p>\n<h4 id=\"Transformation-Operators\"><a href=\"#Transformation-Operators\" class=\"headerlink\" title=\"Transformation Operators\"></a>Transformation Operators</h4><ul>\n<li><code>map</code>: 对 <code>Observable</code> 对象发出的每个值，使用指定的 <code>project</code> 函数，进行映射处理<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar newest = source.map(x =&gt; x + 2); \nnewest.subscribe(console.log);\n</code></pre>\n<pre><code>source: -----0-----1-----2-----3--...\n          map(x =&gt; x + 2)\nnewest: -----2-----3-----4-----5--...\n</code></pre></li>\n<li><code>mapTo</code>: 对 <code>Observable</code> 对象发出的每个值，映射成固定的值<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar newest = source.mapTo(2); \nnewest.subscribe(console.log);\n</code></pre>\n<pre><code>source: -----0-----1-----2-----3--...\n              mapTo(2)\nnewest: -----2-----2-----2-----2--...\n</code></pre></li>\n<li><p><code>scan</code>: 对 <code>Observable</code> 发出值，执行 <code>accumulator</code> 指定的运算，类似于 <code>reduce</code> </p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\nvar newest = source.scan( count =&gt; count + 5, &#39;2&#39;)\nnewest.subscribe(console.log);\n</code></pre>\n<pre><code>source: -----0------1------2------3--...\n      scan( x =&gt; x + 5, 0)\nnewest: -----5-----10-----15-----20--...\n</code></pre></li>\n<li><p><code>buffer</code>: 缓冲源 <code>Observable</code> 对象已发出的值，直到 <code>closingNotifier</code> 触发后，统一输出缓存的元素</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300);\nvar source2 = Rx.Observable.interval(1000);\nvar example = source.buffer(source2);\nexample.subscribe(...);\n</code></pre>\n<pre><code>source : --0--1--2--3--4--5--6--7..\nsource2: ---------0---------1--------...\n          buffer(source2)\nexample: ---------([0,1,2])---------([3,4,5])\n</code></pre></li>\n<li><p><code>bufferTime</code>: 设定源 <code>Observable</code> 对象已发出的值的缓冲时间</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300);\nvar example = source.bufferTime(1000);\nexample.subscribe(...);\n</code></pre>\n<pre><code>source : --0--1--2--3--4--5--6--7..\n          bufferTime(1000)\nexample: ---------([0,1,2])---------([3,4,5])\n</code></pre></li>\n<li><p><code>bufferCount</code>: 缓冲源 <code>Observable</code> 对象已发出的值，直到大小达到给定的最大 <code>bufferSize</code> </p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300);\nvar example = source.bufferCount(3);\nexample.subscribe(...);\n</code></pre>\n<pre><code>source : --0--1--2--3--4--5--6--7..\n          bufferCount(3)\nexample: ---------([0,1,2])---------([3,4,5])\n</code></pre></li>\n<li><p><code>concatMap</code>: 对每个 <code>Observable</code> 对象发出的值，进行映射处理，并进行合并。该操作符也会依序所有<code>Observable</code> 对象</p>\n<pre><code class=\"js\">var source = Rx.Observable.fromEvent(document.body, &#39;click&#39;);\nvar example = source.concatMap(e =&gt; Rx.Observable.interval(100).take(3));\nexample.subscribe(...);\n</code></pre>\n<pre><code>source : -----------c--c------------------...\n      concatMap(c =&gt; Rx.Observable.interval(100).take(3))\nexample: -------------0-1-2-0-1-2---------...\n</code></pre></li>\n<li><p><code>switchMap</code>: 对源 <code>Observable</code> 对象发出的值，做映射处理。若有新的 <code>Observable</code> 对象出现，会在新的 <code>Observable</code> 对象发出新值后，退订前一个未处理完的 <code>Observable</code> 对象</p>\n<pre><code class=\"js\">var source = Rx.Observable.fromEvent(document.body, &#39;click&#39;);\nvar example = source.switchMap(e =&gt; Rx.Observable.interval(100).take(3));\nexample.subscribe(...);\n</code></pre>\n<pre><code>source : -----------c--c-----------------...\n      concatMap(c =&gt; Rx.Observable.interval(100).take(3))\nexample: -------------0--0-1-2-----------...\n</code></pre></li>\n</ul>\n<h4 id=\"Filtering-Operators\"><a href=\"#Filtering-Operators\" class=\"headerlink\" title=\"Filtering Operators\"></a>Filtering Operators</h4><ul>\n<li><p><code>filter</code>: 过滤值</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar newest = source.filter(x =&gt; x % 2 === 0);\n</code></pre>\n<pre><code>source: -----0-----1-----2-----3-----4-...\n          filter(x =&gt; x % 2 === 0)\nnewest: -----0-----------2-----------4-...\n</code></pre></li>\n<li><p><code>take</code>: 获取 <code>Observable</code> 对象发出的前n项值，取完结束。</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar example = source.take(3);\n</code></pre>\n<pre><code>source : -----0-----1-----2-----3--..\n              take(3)\nexample: -----0-----1-----2|\n</code></pre></li>\n<li><p><code>first</code>: 获取 <code>Observable</code> 对象发出的第一个元素，取完结束。</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar example = source.first();\n</code></pre>\n<pre><code>source : -----0-----1-----2-----3--..\n              first()\nexample: -----0|\n</code></pre></li>\n<li><p><code>takeUntil</code>: 当 <code>takeUntil</code> 传入的 <code>notifier</code> 发出值时，源 <code>Observable</code> 对象就会直接进入完成状态</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar click = Rx.Observable.fromEvent(document.body, &#39;click&#39;);\nvar example = source.takeUntil(click);\n</code></pre>\n<pre><code>source : -----0-----1-----2------3--\nclick  : ----------------------c----\n              takeUntil(click)\nexample: -----0-----1-----2----|\n</code></pre></li>\n<li><p><code>skip</code>: 跳过 源<code>Observable</code>的前n项，并返回新的<code>Observable</code>对象</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar example = source.skip(3);\n</code></pre>\n<pre><code>source : ----0----1----2----3----4----5--....\n                  skip(3)\nexample: -------------------3----4----5--...\n</code></pre></li>\n<li><p><code>takeLast</code>: 获取 源<code>Observable</code>发出的后n项</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000).take(6);\nvar example = source.takeLast(2);\n</code></pre>\n<pre><code>source : ----0----1----2----3----4----5|\n              takeLast(2)\nexample: ------------------------------(45)|\n</code></pre></li>\n<li><p><code>last</code>: 获取 源<code>Observable</code>发出的最后一项</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000).take(6);\nvar example = source.last();\n</code></pre>\n<pre><code>source : ----0----1----2----3----4----5|\n                  last()\nexample: ------------------------------(5)|\n</code></pre></li>\n<li><p><code>debounceTime</code>: 在设定的时间跨度内，若源 <code>Observable</code> 对象没有再发出新值，则返回最近一次发出的值</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300).take(5);\nvar example = source.debounceTime(1000);\n</code></pre>\n<pre><code>source : --0--1--2--3--4|\n      debounceTime(1000)\nexample: --------------4|\n</code></pre></li>\n<li><p><code>throttleTime</code>: 节流，从 源<code>Observable</code>对象发出的第一个值开始，忽略等待时间内发出的值</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300).take(5);\nvar example = source.throttleTime(1000);\n</code></pre>\n<pre><code>source : --0--1--2--3--4|\n      throttleTime(1000)\nexample: --0------------4|\n</code></pre></li>\n<li><p><code>distinct</code>: 去重</p>\n<pre><code class=\"js\">var source = Rx.Observable.from([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;])\nvar example = source.distinct()\n</code></pre>\n<pre><code>source : --a--b--c--a--b|\n          distinct()\nexample: --a--b--c------|\n</code></pre></li>\n<li><p><code>distinctUntilChanged</code>: 过滤 <code>Observable</code>发出的值，若当前值与上一次值不一致，则发出该值。</p>\n<pre><code class=\"js\">var source = Rx.Observable.from([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;b&#39;])\nvar example = source.distinctUntilChanged()\n</code></pre>\n<pre><code>source : --a--b--c--c--b|\n          distinctUntilChanged()\nexample: --a--b--c-----b|\n</code></pre><h4 id=\"Combination-Operators\"><a href=\"#Combination-Operators\" class=\"headerlink\" title=\"Combination Operators\"></a><code>Combination Operators</code></h4></li>\n<li><p><code>concat</code>: 合并多个<code>Observable</code>对象，并依次执行</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000).take(3);\nvar source2 = Rx.Observable.of(3)\nvar source3 = Rx.Observable.of(4,5,6)\nvar example = source.concat(source2, source3);\n</code></pre>\n<pre><code>source : ----0----1----2|\nsource2: (3)|\nsource3: (456)|\n          concat()\nexample: ----0----1----2(3456)|\n</code></pre></li>\n<li><p><code>concatAll</code>: 合并多个<code>Observable</code>对象，并在上一个<code>Obs</code>完成订阅后订阅下一个<code>Obs</code></p>\n<pre><code class=\"js\">var obs1 = Rx.Observable.interval(1000).take(5);\nvar obs2 = Rx.Observable.interval(500).take(2);\nvar obs3 = Rx.Observable.interval(2000).take(1);\nvar source = Rx.Observable.of(obs1, obs2, obs3);\nvar example = source.concatAll();\n</code></pre>\n<pre><code>source : (o1                 o2      o3)|\n         \\                  \\       \\\n          --0--1--2--3--4|   -0-1|   ----0|               \n              concatAll()        \nexample: --0--1--2--3--4-0-1----0|\n</code></pre></li>\n<li><p><code>startWith</code>: 在开始发出<code>Obs</code>对象的数据之前发出已经设置的参数</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000);\nvar example = source.startWith(222);\n</code></pre>\n<pre><code>source : ----0----1----2----3--...\n              startWith(222)\nexample: (222)----0----1----2----3--...\n</code></pre></li>\n<li><p><code>merage</code>: 合并 <code>Obs</code>对象，并按给定的时序发出对应值</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(500).take(3);\nvar source2 = Rx.Observable.interval(300).take(6);\nvar example = source.merge(source2);\n</code></pre>\n<pre><code>source : ----0----1----2|\nsource2: --0--1--2--3--4--5|\n          merge()\nexample: --0-01--21-3--(24)--5|\n</code></pre></li>\n<li><p><code>merageAll</code>: 将高阶<code>Obs</code>转换为一阶<code>Obs</code>，并同时处理所有<code>Obs</code></p>\n<pre><code class=\"js\">var click = Rx.Observable.fromEvent(document.body, &#39;click&#39;);\nvar source = click.map(e =&gt; Rx.Observable.interval(1000));\nvar example = source.mergeAll();\n</code></pre>\n<pre><code>click  : ---------c-c------------------c--.. \n      map(e =&gt; Rx.Observable.interval(1000))\nsource : ---------o-o------------------o--..\n                 \\ \\                  \\----0----1--...\n                  \\ ----0----1----2----3----4--...\n                   ----0----1----2----3----4--...\n                   mergeAll()\nexample: ----------------00---11---22---33---(04)4--...\n</code></pre></li>\n<li><p><code>combineLatest</code>: 合并输入的<code>Obs</code>对象，当源<code>Obs</code>和其他<code>Obs</code>都发出值后，才会调用<code>project</code>函数</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(500).take(3);\nvar newest = Rx.Observable.interval(300).take(6);\nvar example = source.combineLatest(newest, (x, y) =&gt; x + y);\n</code></pre>\n<pre><code>source : ----0----1----2|\nnewest : --0--1--2--3--4--5|\n  combineLatest(newest, (x, y) =&gt; x + y);\nexample: ----01--23-4--(56)--7|\n</code></pre></li>\n<li><p><code>zip</code>: 根据所有的<code>Obs</code>对象的输入顺序，产生一个新<code>Obs</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(500).take(3);\nvar newest = Rx.Observable.interval(300).take(6);\nvar example = source.zip(newest, (x, y) =&gt; x + y);\n</code></pre>\n<pre><code>source : ----0----1----2|\nnewest : --0--1--2--3--4--5|\n  zip(newest, (x, y) =&gt; x + y)\nexample: ----0----2----4|\n</code></pre></li>\n<li><p><code>withLatestFrom</code>: 当源<code>Obs</code>发出新值时，根据<code>project</code>函数，合并其他<code>Obs</code>之前发出的最新值</p>\n<pre><code class=\"js\">var main = Rx.Observable.from(&#39;hello&#39;).zip(Rx.Observable.interval(500), \n  (x, y) =&gt; x);\nvar some = Rx.Observable.from([0,1,0,0,0,1]).zip(Rx.Observable.interval(300), \n  (x, y) =&gt; x);\nvar example = main.withLatestFrom(some, (x, y) =&gt; {\n  return y === 1 ? x.toUpperCase() : x;\n});\n</code></pre>\n<pre><code>main   : ----h----e----l----l----o|\nsome   : --0--1--0--0--0--1|\nwithLatestFrom(some, (x, y) =&gt;  y === 1 ? x.toUpperCase() : x);\nexample: ----h----e----l----L----O|\n</code></pre></li>\n<li><p><code>switch</code>: 切换为最新的<code>Obs</code>数据源，并退订之前的<code>Obs</code></p>\n<pre><code class=\"js\">var click = Rx.Observable.fromEvent(document.body, &#39;click&#39;);\nvar source = click.map(e =&gt; Rx.Observable.interval(1000));\nvar example = source.switch();\n</code></pre>\n<pre><code>click  : ---------c-c------------------c--.. \n      map(e =&gt; Rx.Observable.interval(1000))\nsource : ---------o-o------------------o--..\n                 \\ \\                  \\----0----1--...\n                  \\ ----0----1----2----3----4--...\n                   ----0----1----2----3----4--...\n                   switch()\nexample: -----------------0----1----2--------0----1--...\n</code></pre></li>\n</ul>\n<h4 id=\"Utility-Operators\"><a href=\"#Utility-Operators\" class=\"headerlink\" title=\"Utility Operators\"></a><code>Utility Operators</code></h4><ul>\n<li><p><code>delay</code>: 延迟源<code>Obs</code>发出的第一个元素的时间点</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300).take(5);\nvar example = source.delay(500);\n</code></pre>\n<pre><code>source : --0--1--2--3--4|\n      delay(500)\nexample: -------0--1--2--3--4|\n</code></pre></li>\n<li><p><code>delayWhen</code>: <code>delayWhen</code> 会响每个元素，调用的时候需要设置 <code>delayDurationSelector</code> 函数，该函数的返回值是 <code>Observable</code> 对象</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(300).take(5);\nvar example = source.delayWhen( x =&gt; Rx.Observable.interval(100 * x).take(1));\n</code></pre>\n<pre><code>source : --0--1--2--3--4|\n  .delayWhen(x =&gt; Rx.Observable.interval(100 * x).take(1));\nexample: --0---1----2-----3------4|\n</code></pre></li>\n</ul>\n<h4 id=\"Multicasting-Operators\"><a href=\"#Multicasting-Operators\" class=\"headerlink\" title=\"Multicasting Operators\"></a><code>Multicasting Operators</code></h4><ul>\n<li><code>multicast</code>: 用于挂载<code>Subject</code>，并返回一个可链接的<code>Obs</code>对象<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .take(3)\n           .multicast(new Rx.Subject());\nvar observerA = {\n  next: value =&gt; console.log(&#39;A next: &#39; + value),\n  error: error =&gt; console.log(&#39;A error: &#39; + error),\n  complete: () =&gt; console.log(&#39;A complete!&#39;)\n};\nvar observerB = {\n  next: value =&gt; console.log(&#39;B next: &#39; + value),\n  error: error =&gt; console.log(&#39;B error: &#39; + error),\n  complete: () =&gt; console.log(&#39;B complete!&#39;)\n};\nsource.subscribe(observerA); // subject.subscribe(observerA)\nsource.connect(); // source.subscribe(subject)\nsetTimeout(() =&gt; {\n  source.subscribe(observerB); // subject.subscribe(observerA)\n}, 1000);\n</code></pre>\n</li>\n<li><p><code>refCount</code>: 使 <code>multicast Observalbe</code>可以在第一个<code>subscriber</code>到达时自动执行，并在最后一个<code>subscriber</code>离开时结束。<br><code>refCount()</code>存在于<code>ConnectableObservable</code>上，并返回一个新的<code>Observalbe</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .do(x =&gt; console.log(&#39;send: &#39; + x))\n           .multicast(new Rx.Subject())\n           .refCount();\nvar observerA = {\n  next: value =&gt; console.log(&#39;A next: &#39; + value),\n  error: error =&gt; console.log(&#39;A error: &#39; + error),\n  complete: () =&gt; console.log(&#39;A complete!&#39;)\n};\nvar observerB = {\n  next: value =&gt; console.log(&#39;B next: &#39; + value),\n  error: error =&gt; console.log(&#39;B error: &#39; + error),\n  complete: () =&gt; console.log(&#39;B complete!&#39;)\n}\nvar subscriptionA = source.subscribe(observerA);\n// 订阅数 0 =&gt; 1\nvar subscriptionB;\nsetTimeout(() =&gt; {\n  subscriptionB = source.subscribe(observerB);\n  // 订阅数 1 =&gt; 2\n}, 1000);\nsetTimeout(() =&gt; {\n  subscriptionA.unsubscribe(); // 订阅数 2 =&gt; 1\n  subscriptionB.unsubscribe(); // 订阅数 1 =&gt; 0，source 停止发送元素\n}, 5000);\n</code></pre>\n</li>\n<li><p><code>publish</code>: 用于挂载 <code>Subject</code> 对象，并返回一个可链接 (connectable) 的 <code>Obs</code>, <code>publish</code> <code>multicast(new Rx.Subject())</code> 等价</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .publish() \n           .refCount();        \nvar source = Rx.Observable.interval(1000)\n           .multicast(new Rx.Subject()) \n           .refCount();\n</code></pre>\n</li>\n<li><p><code>publishReplay</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .publishReplay(1) \n           .refCount();          \nvar source = Rx.Observable.interval(1000)\n          .multicast(new Rx.ReplaySubject(1)) \n          .refCount();\n</code></pre>\n</li>\n<li><p><code>publishBehavior</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .publishBehavior(0) \n           .refCount();           \nvar source = Rx.Observable.interval(1000)\n           .multicast(new Rx.BehaviorSubject(0)) \n           .refCount();\n</code></pre>\n</li>\n<li><p><code>publishLast</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .publishLast() \n           .refCount();          \nvar source = Rx.Observable.interval(1000)\n           .multicast(new Rx.AsyncSubject(1)) \n           .refCount();\n</code></pre>\n</li>\n<li><p><code>share</code>: <code>publish</code> + <code>refCount</code> 的简写</p>\n<pre><code class=\"js\">var source = Rx.Observable.interval(1000)\n           .share();          \nvar source = Rx.Observable.interval(1000)\n           .publish()\n           .refCount();\nvar source = Rx.Observable.interval(1000)\n           .multicast(new Rx.Subject()) \n           .refCount();\n</code></pre>\n</li>\n</ul>\n<h4 id=\"Error-Handling-Operators\"><a href=\"#Error-Handling-Operators\" class=\"headerlink\" title=\"Error Handling Operators\"></a><code>Error Handling Operators</code></h4><ul>\n<li><code>catch</code>: 捕获异常，同时返回一个 <code>Obs</code>，用于发出新的值<pre><code class=\"js\">var source = Rx.Observable.from([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,2])\n             .zip(Rx.Observable.interval(500), (x,y) =&gt; x);\nvar example = source.map(x =&gt; x.toUpperCase())\n                  .catch(error =&gt; Rx.Observable.of(&#39;h&#39;));\n</code></pre>\n<pre><code>source : ----a----b----c----d----2|\n      map(x =&gt; x.toUpperCase())\n       ----a----b----c----d----X|\n      catch(error =&gt; Rx.Observable.of(&#39;h&#39;))\nexample: ----A----B----C----D----h|\n</code></pre></li>\n<li><p><code>retry</code>: 发生错误后，重试 <code>count</code> 次数</p>\n<pre><code class=\"js\">var source = Rx.Observable.from([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,2])\n             .zip(Rx.Observable.interval(500), (x,y) =&gt; x);\nvar example = source.map(x =&gt; x.toUpperCase())\n                  .retry(1);\n</code></pre>\n<pre><code>source : ----a----b----c----d----2|\n      map(x =&gt; x.toUpperCase())\n       ----a----b----c----d----X|\n              retry(1)\nexample: ----A----B----C----D--------A----B----C----D----X|\n</code></pre></li>\n<li><p><code>retryWhen</code>: 捕获异常 <code>Obs</code>, 处理后可以重新订阅源<code>Obs</code></p>\n<pre><code class=\"js\">var source = Rx.Observable.from([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,2])\n             .zip(Rx.Observable.interval(500), (x,y) =&gt; x);\nvar example = source.map(x =&gt; x.toUpperCase())\n                  .retryWhen(errorObs =&gt; errorObs.delay(1000));\n</code></pre>\n<pre><code>source : ----a----b----c----d----2|\n      map(x =&gt; x.toUpperCase())\n       ----a----b----c----d----X|\n      retryWhen(errorObs =&gt; errorObs.delay(1000))\nexample: ----A----B----C----D-------------------A----B----C----D----...\n</code></pre></li>\n</ul>\n<h3 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h3><ul>\n<li><code>Subject</code>: 继承于<code>Observable</code>的 <code>Observer Pattern</code> 的实例<br><code>Subject</code> 既是 <code>Observable</code> 又是 <code>Observer</code><br><code>Subject</code> 会对內部的 <code>observers</code> 列表进行组播(multicast)</li>\n</ul>\n<pre><code class=\"js\">var subject = new Rx.Subject();\nvar observerA = {\n    next: value =&gt; console.log(&#39;A next: &#39; + value),\n    error: error =&gt; console.log(&#39;A error: &#39; + error),\n    complete: () =&gt; console.log(&#39;A complete!&#39;)\n}\nvar observerB = {\n    next: value =&gt; console.log(&#39;B next: &#39; + value),\n    error: error =&gt; console.log(&#39;B error: &#39; + error),\n    complete: () =&gt; console.log(&#39;B complete!&#39;)\n}\nsubject.subscribe(observerA);\nsubject.subscribe(observerB);\nsubject.next(1);\n// &quot;A next: 1&quot;\n// &quot;B next: 1&quot;\nsubject.next(2);\n// &quot;A next: 2&quot;\n// &quot;B next: 2&quot;\n</code></pre>\n<ul>\n<li><p><code>BehaviorSubject</code>: 会记住最新一次推送的元素，并把该元素当做当前值推送（建立时需给定状态）</p>\n<pre><code class=\"js\">var subject = new Rx.BehaviorSubject(0); // 0 為起始值\nvar observerA = {\n  next: value =&gt; console.log(&#39;A next: &#39; + value),\n  error: error =&gt; console.log(&#39;A error: &#39; + error),\n  complete: () =&gt; console.log(&#39;A complete!&#39;)\n}\nvar observerB = {\n  next: value =&gt; console.log(&#39;B next: &#39; + value),\n  error: error =&gt; console.log(&#39;B error: &#39; + error),\n  complete: () =&gt; console.log(&#39;B complete!&#39;)\n}\nsubject.subscribe(observerA);\n// &quot;A next: 0&quot;\nsubject.next(1);\n// &quot;A next: 1&quot;\nsubject.next(2);\n// &quot;A next: 2&quot;\nsubject.next(3);\n// &quot;A next: 3&quot;\nsetTimeout(() =&gt; {\n  subject.subscribe(observerB); \n  // &quot;B next: 3&quot;\n},3000)\n</code></pre>\n</li>\n<li><p><code>ReplaySubject</code>: 在新订阅后重新发送最后几个元素</p>\n<pre><code class=\"js\">var subject = new Rx.ReplaySubject(2); // 重複發送最後 2 個元素\nvar observerA = {\n  next: value =&gt; console.log(&#39;A next: &#39; + value),\n  error: error =&gt; console.log(&#39;A error: &#39; + error),\n  complete: () =&gt; console.log(&#39;A complete!&#39;)\n}\nvar observerB = {\n  next: value =&gt; console.log(&#39;B next: &#39; + value),\n  error: error =&gt; console.log(&#39;B error: &#39; + error),\n  complete: () =&gt; console.log(&#39;B complete!&#39;)\n}\nsubject.subscribe(observerA);\nsubject.next(1);\n// &quot;A next: 1&quot;\nsubject.next(2);\n// &quot;A next: 2&quot;\nsubject.next(3);\n// &quot;A next: 3&quot;\nsetTimeout(() =&gt; {\n  subject.subscribe(observerB);\n  // &quot;B next: 2&quot;\n  // &quot;B next: 3&quot;\n},3000)\n</code></pre>\n</li>\n<li><p><code>AsyncSubject</code>: 在<code>subject</code>结束后送出最后一个值并结束</p>\n<pre><code class=\"js\">var subject = new Rx.AsyncSubject();\nvar observerA = {\n  next: value =&gt; console.log(&#39;A next: &#39; + value),\n  error: error =&gt; console.log(&#39;A error: &#39; + error),\n  complete: () =&gt; console.log(&#39;A complete!&#39;)\n}\nvar observerB = {\n  next: value =&gt; console.log(&#39;B next: &#39; + value),\n  error: error =&gt; console.log(&#39;B error: &#39; + error),\n  complete: () =&gt; console.log(&#39;B complete!&#39;)\n}\nsubject.subscribe(observerA);\nsubject.next(1);\nsubject.next(2);\nsubject.next(3);\nsubject.complete();\n// &quot;A next: 3&quot;\n// &quot;A complete!&quot;\nsetTimeout(() =&gt; {\n  subject.subscribe(observerB);\n  // &quot;B next: 3&quot;\n  // &quot;B complete!&quot;\n},3000)\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Observer\"><a href=\"#Observer\" class=\"headerlink\" title=\"Observer\"></a>Observer</h3><ul>\n<li><code>next</code>: 当Observable推送新值时调用</li>\n<li><code>complete</code>: 当Observable所有值调用完毕之后，调用后next将不再起作用</li>\n<li><code>error</code>: 报错时<pre><code class=\"js\">var observer = {\n next: function(value) {\n     console.log(value);\n },\n error: function(error) {\n     console.log(error)\n },\n complete: function() {\n     console.log(&#39;complete&#39;)\n }\n}\n//  使用之前定义的观察者来订阅\nobservable.subscribe(observer)\n// Jerry\n// Anna\n// complete\n</code></pre>\n</li>\n</ul>\n<h3 id=\"Scheduler\"><a href=\"#Scheduler\" class=\"headerlink\" title=\"Scheduler\"></a>Scheduler</h3><ul>\n<li>数据结构，知道如何根据优先级或其他标准来执行并列任务</li>\n<li>执行环境，知道事件何时何处执行</li>\n<li>虚拟时钟，可以让事件在特定时间执行</li>\n</ul>\n"},{"title":"Vuex与Redux与Mobx","date":"2017-05-25T14:11:12.000Z","_content":"\n分析理解一下\n<!-- more -->\n\n\n## 三种状态管理方案\n\n\n### MobX\n任何源自应用状态的东西都应该自动地获得。\n在 React + MobX 组合中，MobX 提供 机制来存储更新应用状态。\nReact 将应用状态渲染。\n#### 核心概念\n- 可观测状态 （Observable state）\n  通过 `@observable`装饰器，为类属性添加注解。\n\n```js\n// es.next\nclass Todo {\n    id = Math.random();\n    @observable title = \"\";\n    @observable finished = false;\n}\n\n// es5\nfunction Todo() {\n    this.id = Math.random()\n    extendObservable(this, {\n        title: \"\",\n        finished: false\n    })\n}\n```\n\n- 计算值 （Computed values）\n  通过`@computed`装饰器在相关数据发生变化时自动更新\n  产生一个二次加工的新值。\n\n```js\nclass TodoList {\n    @observable todos = [];\n    @computed get unfinishedTodoCount() {\n      return this.todos.filter(todo => !todo.finished).length;\n    }\n}\n```\n\n- 反应 （Reactions）\n  类似于Computed，产生与计算无关的动作，例如打印日志，网络请求，更新界面等\n\n```jsx\n import React from 'react';\n import React from 'react-dom';\n import {observer} from 'mobx-react';\n\n @observer\n // 监听\n class TodoListView extends React.Component {\n   render () {\n     rerurn {\n       <div>\n        <ul>\n          {this.props.todoList.todos.map(todo =>\n            <TodoView todo={todo} key={todo.id} />\n          )}\n        </ul>\n        Tasks left: {this.props.todoList.unfinishedTodoCount}\n      </div>\n     }\n   }\n }\n\n // 注册store\n const TodoView = observer(({todo}) => {\n   <li>\n        <input\n        type=\"checkbox\"\n        checked={todo.finished}\n        onClick={() => todo.finished = !todo.finished}\n        />{todo.title}\n    </li>\n })\n const store = new TodoList();\n\nReactDOM.render(<TodoListView todoList={store} />, document.getElementById('mount'));\n```\n\n - 动作（Actions）\n 更新状态的方式\n\n```js\nstore.todos.push(\n    new Todo(\"Get Coffee\"),\n    new Todo(\"Write simpler code\")\n);\nstore.todos[0].finished = true;\n```\n- 原则\n单项数据流\nAction -> State -> Views\n所有衍生值都会自动同步更新。\n\n\n#### 使用方法\n\n```jsx\nimport React from 'react';\nimport React from 'react-dom';\nimport {observable} from 'mobx';\nimport {observer} from 'mobx-react';\n\n// 定义状态数据结构\nvar appState = ovservable({\n  timer: 0\n})\n// 定义动作\nappState.TimerAdd = action(()=> {\n  appState.timer += 1;\n})\n\n// 创建视图响应状态变化\n@observer\nclass TimerView extends React.Component {\n  onReset()\n  render() {\n    timerAdd() {\n      this.props.appState.TimerAdd();\n    }\n    return (\n      <div>\n      <!--获取状态-->\n      {this.props.appState.timer}\n      <button onClick=\"timerAdd\">+</button>\n    )\n  }\n}\nReactDOM.render(<TimerView appState={appState} />, document.body);\n```\n\n| MobX自始至终只有一份数据引用，没有额外的复制对象的开销，但没有中间件机制，适用于数据流简单的项目。\n\n\n### Vuex\n Vue专用的状态管理模式。\n Vuex将所有组件共享的状态数据抽取出来，作为一个全局的单例模式管理。这就构建了一个巨大的”视图“树，因此不论视图组件在树的哪个位置，都可以获取状态或触发行为。\n\n #### 核心概念\n\n - State 单一状态树\n 每个应用仅仅包含一个store实例。","source":"_posts/Vuex与Redux与Mobx.md","raw":"---\ntitle: Vuex与Redux与Mobx\ndate: 2017-05-25 22:11:12\ntags:\n  - Redux\n  - Vuex\n  - MobX\n---\n\n分析理解一下\n<!-- more -->\n\n\n## 三种状态管理方案\n\n\n### MobX\n任何源自应用状态的东西都应该自动地获得。\n在 React + MobX 组合中，MobX 提供 机制来存储更新应用状态。\nReact 将应用状态渲染。\n#### 核心概念\n- 可观测状态 （Observable state）\n  通过 `@observable`装饰器，为类属性添加注解。\n\n```js\n// es.next\nclass Todo {\n    id = Math.random();\n    @observable title = \"\";\n    @observable finished = false;\n}\n\n// es5\nfunction Todo() {\n    this.id = Math.random()\n    extendObservable(this, {\n        title: \"\",\n        finished: false\n    })\n}\n```\n\n- 计算值 （Computed values）\n  通过`@computed`装饰器在相关数据发生变化时自动更新\n  产生一个二次加工的新值。\n\n```js\nclass TodoList {\n    @observable todos = [];\n    @computed get unfinishedTodoCount() {\n      return this.todos.filter(todo => !todo.finished).length;\n    }\n}\n```\n\n- 反应 （Reactions）\n  类似于Computed，产生与计算无关的动作，例如打印日志，网络请求，更新界面等\n\n```jsx\n import React from 'react';\n import React from 'react-dom';\n import {observer} from 'mobx-react';\n\n @observer\n // 监听\n class TodoListView extends React.Component {\n   render () {\n     rerurn {\n       <div>\n        <ul>\n          {this.props.todoList.todos.map(todo =>\n            <TodoView todo={todo} key={todo.id} />\n          )}\n        </ul>\n        Tasks left: {this.props.todoList.unfinishedTodoCount}\n      </div>\n     }\n   }\n }\n\n // 注册store\n const TodoView = observer(({todo}) => {\n   <li>\n        <input\n        type=\"checkbox\"\n        checked={todo.finished}\n        onClick={() => todo.finished = !todo.finished}\n        />{todo.title}\n    </li>\n })\n const store = new TodoList();\n\nReactDOM.render(<TodoListView todoList={store} />, document.getElementById('mount'));\n```\n\n - 动作（Actions）\n 更新状态的方式\n\n```js\nstore.todos.push(\n    new Todo(\"Get Coffee\"),\n    new Todo(\"Write simpler code\")\n);\nstore.todos[0].finished = true;\n```\n- 原则\n单项数据流\nAction -> State -> Views\n所有衍生值都会自动同步更新。\n\n\n#### 使用方法\n\n```jsx\nimport React from 'react';\nimport React from 'react-dom';\nimport {observable} from 'mobx';\nimport {observer} from 'mobx-react';\n\n// 定义状态数据结构\nvar appState = ovservable({\n  timer: 0\n})\n// 定义动作\nappState.TimerAdd = action(()=> {\n  appState.timer += 1;\n})\n\n// 创建视图响应状态变化\n@observer\nclass TimerView extends React.Component {\n  onReset()\n  render() {\n    timerAdd() {\n      this.props.appState.TimerAdd();\n    }\n    return (\n      <div>\n      <!--获取状态-->\n      {this.props.appState.timer}\n      <button onClick=\"timerAdd\">+</button>\n    )\n  }\n}\nReactDOM.render(<TimerView appState={appState} />, document.body);\n```\n\n| MobX自始至终只有一份数据引用，没有额外的复制对象的开销，但没有中间件机制，适用于数据流简单的项目。\n\n\n### Vuex\n Vue专用的状态管理模式。\n Vuex将所有组件共享的状态数据抽取出来，作为一个全局的单例模式管理。这就构建了一个巨大的”视图“树，因此不论视图组件在树的哪个位置，都可以获取状态或触发行为。\n\n #### 核心概念\n\n - State 单一状态树\n 每个应用仅仅包含一个store实例。","slug":"Vuex与Redux与Mobx","published":1,"updated":"2017-06-02T11:46:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl1y0007ttwpfbchxii0","content":"<p>分析理解一下<br><a id=\"more\"></a></p>\n<h2 id=\"三种状态管理方案\"><a href=\"#三种状态管理方案\" class=\"headerlink\" title=\"三种状态管理方案\"></a>三种状态管理方案</h2><h3 id=\"MobX\"><a href=\"#MobX\" class=\"headerlink\" title=\"MobX\"></a>MobX</h3><p>任何源自应用状态的东西都应该自动地获得。<br>在 React + MobX 组合中，MobX 提供 机制来存储更新应用状态。<br>React 将应用状态渲染。</p>\n<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4><ul>\n<li>可观测状态 （Observable state）<br>通过 <code>@observable</code>装饰器，为类属性添加注解。</li>\n</ul>\n<pre><code class=\"js\">// es.next\nclass Todo {\n    id = Math.random();\n    @observable title = &quot;&quot;;\n    @observable finished = false;\n}\n\n// es5\nfunction Todo() {\n    this.id = Math.random()\n    extendObservable(this, {\n        title: &quot;&quot;,\n        finished: false\n    })\n}\n</code></pre>\n<ul>\n<li>计算值 （Computed values）<br>通过<code>@computed</code>装饰器在相关数据发生变化时自动更新<br>产生一个二次加工的新值。</li>\n</ul>\n<pre><code class=\"js\">class TodoList {\n    @observable todos = [];\n    @computed get unfinishedTodoCount() {\n      return this.todos.filter(todo =&gt; !todo.finished).length;\n    }\n}\n</code></pre>\n<ul>\n<li>反应 （Reactions）<br>类似于Computed，产生与计算无关的动作，例如打印日志，网络请求，更新界面等</li>\n</ul>\n<pre><code class=\"jsx\"> import React from &#39;react&#39;;\n import React from &#39;react-dom&#39;;\n import {observer} from &#39;mobx-react&#39;;\n\n @observer\n // 监听\n class TodoListView extends React.Component {\n   render () {\n     rerurn {\n       &lt;div&gt;\n        &lt;ul&gt;\n          {this.props.todoList.todos.map(todo =&gt;\n            &lt;TodoView todo={todo} key={todo.id} /&gt;\n          )}\n        &lt;/ul&gt;\n        Tasks left: {this.props.todoList.unfinishedTodoCount}\n      &lt;/div&gt;\n     }\n   }\n }\n\n // 注册store\n const TodoView = observer(({todo}) =&gt; {\n   &lt;li&gt;\n        &lt;input\n        type=&quot;checkbox&quot;\n        checked={todo.finished}\n        onClick={() =&gt; todo.finished = !todo.finished}\n        /&gt;{todo.title}\n    &lt;/li&gt;\n })\n const store = new TodoList();\n\nReactDOM.render(&lt;TodoListView todoList={store} /&gt;, document.getElementById(&#39;mount&#39;));\n</code></pre>\n<ul>\n<li>动作（Actions）<br>更新状态的方式</li>\n</ul>\n<pre><code class=\"js\">store.todos.push(\n    new Todo(&quot;Get Coffee&quot;),\n    new Todo(&quot;Write simpler code&quot;)\n);\nstore.todos[0].finished = true;\n</code></pre>\n<ul>\n<li>原则<br>单项数据流<br>Action -&gt; State -&gt; Views<br>所有衍生值都会自动同步更新。</li>\n</ul>\n<h4 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h4><pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport React from &#39;react-dom&#39;;\nimport {observable} from &#39;mobx&#39;;\nimport {observer} from &#39;mobx-react&#39;;\n\n// 定义状态数据结构\nvar appState = ovservable({\n  timer: 0\n})\n// 定义动作\nappState.TimerAdd = action(()=&gt; {\n  appState.timer += 1;\n})\n\n// 创建视图响应状态变化\n@observer\nclass TimerView extends React.Component {\n  onReset()\n  render() {\n    timerAdd() {\n      this.props.appState.TimerAdd();\n    }\n    return (\n      &lt;div&gt;\n      &lt;!--获取状态--&gt;\n      {this.props.appState.timer}\n      &lt;button onClick=&quot;timerAdd&quot;&gt;+&lt;/button&gt;\n    )\n  }\n}\nReactDOM.render(&lt;TimerView appState={appState} /&gt;, document.body);\n</code></pre>\n<p>| MobX自始至终只有一份数据引用，没有额外的复制对象的开销，但没有中间件机制，适用于数据流简单的项目。</p>\n<h3 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h3><p> Vue专用的状态管理模式。<br> Vuex将所有组件共享的状态数据抽取出来，作为一个全局的单例模式管理。这就构建了一个巨大的”视图“树，因此不论视图组件在树的哪个位置，都可以获取状态或触发行为。</p>\n<h4 id=\"核心概念-1\"><a href=\"#核心概念-1\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4><ul>\n<li>State 单一状态树<br>每个应用仅仅包含一个store实例。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>分析理解一下<br>","more":"</p>\n<h2 id=\"三种状态管理方案\"><a href=\"#三种状态管理方案\" class=\"headerlink\" title=\"三种状态管理方案\"></a>三种状态管理方案</h2><h3 id=\"MobX\"><a href=\"#MobX\" class=\"headerlink\" title=\"MobX\"></a>MobX</h3><p>任何源自应用状态的东西都应该自动地获得。<br>在 React + MobX 组合中，MobX 提供 机制来存储更新应用状态。<br>React 将应用状态渲染。</p>\n<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4><ul>\n<li>可观测状态 （Observable state）<br>通过 <code>@observable</code>装饰器，为类属性添加注解。</li>\n</ul>\n<pre><code class=\"js\">// es.next\nclass Todo {\n    id = Math.random();\n    @observable title = &quot;&quot;;\n    @observable finished = false;\n}\n\n// es5\nfunction Todo() {\n    this.id = Math.random()\n    extendObservable(this, {\n        title: &quot;&quot;,\n        finished: false\n    })\n}\n</code></pre>\n<ul>\n<li>计算值 （Computed values）<br>通过<code>@computed</code>装饰器在相关数据发生变化时自动更新<br>产生一个二次加工的新值。</li>\n</ul>\n<pre><code class=\"js\">class TodoList {\n    @observable todos = [];\n    @computed get unfinishedTodoCount() {\n      return this.todos.filter(todo =&gt; !todo.finished).length;\n    }\n}\n</code></pre>\n<ul>\n<li>反应 （Reactions）<br>类似于Computed，产生与计算无关的动作，例如打印日志，网络请求，更新界面等</li>\n</ul>\n<pre><code class=\"jsx\"> import React from &#39;react&#39;;\n import React from &#39;react-dom&#39;;\n import {observer} from &#39;mobx-react&#39;;\n\n @observer\n // 监听\n class TodoListView extends React.Component {\n   render () {\n     rerurn {\n       &lt;div&gt;\n        &lt;ul&gt;\n          {this.props.todoList.todos.map(todo =&gt;\n            &lt;TodoView todo={todo} key={todo.id} /&gt;\n          )}\n        &lt;/ul&gt;\n        Tasks left: {this.props.todoList.unfinishedTodoCount}\n      &lt;/div&gt;\n     }\n   }\n }\n\n // 注册store\n const TodoView = observer(({todo}) =&gt; {\n   &lt;li&gt;\n        &lt;input\n        type=&quot;checkbox&quot;\n        checked={todo.finished}\n        onClick={() =&gt; todo.finished = !todo.finished}\n        /&gt;{todo.title}\n    &lt;/li&gt;\n })\n const store = new TodoList();\n\nReactDOM.render(&lt;TodoListView todoList={store} /&gt;, document.getElementById(&#39;mount&#39;));\n</code></pre>\n<ul>\n<li>动作（Actions）<br>更新状态的方式</li>\n</ul>\n<pre><code class=\"js\">store.todos.push(\n    new Todo(&quot;Get Coffee&quot;),\n    new Todo(&quot;Write simpler code&quot;)\n);\nstore.todos[0].finished = true;\n</code></pre>\n<ul>\n<li>原则<br>单项数据流<br>Action -&gt; State -&gt; Views<br>所有衍生值都会自动同步更新。</li>\n</ul>\n<h4 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h4><pre><code class=\"jsx\">import React from &#39;react&#39;;\nimport React from &#39;react-dom&#39;;\nimport {observable} from &#39;mobx&#39;;\nimport {observer} from &#39;mobx-react&#39;;\n\n// 定义状态数据结构\nvar appState = ovservable({\n  timer: 0\n})\n// 定义动作\nappState.TimerAdd = action(()=&gt; {\n  appState.timer += 1;\n})\n\n// 创建视图响应状态变化\n@observer\nclass TimerView extends React.Component {\n  onReset()\n  render() {\n    timerAdd() {\n      this.props.appState.TimerAdd();\n    }\n    return (\n      &lt;div&gt;\n      &lt;!--获取状态--&gt;\n      {this.props.appState.timer}\n      &lt;button onClick=&quot;timerAdd&quot;&gt;+&lt;/button&gt;\n    )\n  }\n}\nReactDOM.render(&lt;TimerView appState={appState} /&gt;, document.body);\n</code></pre>\n<p>| MobX自始至终只有一份数据引用，没有额外的复制对象的开销，但没有中间件机制，适用于数据流简单的项目。</p>\n<h3 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h3><p> Vue专用的状态管理模式。<br> Vuex将所有组件共享的状态数据抽取出来，作为一个全局的单例模式管理。这就构建了一个巨大的”视图“树，因此不论视图组件在树的哪个位置，都可以获取状态或触发行为。</p>\n<h4 id=\"核心概念-1\"><a href=\"#核心概念-1\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4><ul>\n<li>State 单一状态树<br>每个应用仅仅包含一个store实例。</li>\n</ul>"},{"title":"TypeScript的学习","date":"2017-03-23T14:27:15.000Z","_content":"学习TypeScript...\n\n<!--more-->\n\n### SOLID原则\n|en    |     en      |ch   |\n| ------------- |:-------------:| -----:|\n| SRP | The Single Responsibility Principle | 单一责任原则 |\n| OCP | The Open Closed Principle | 开放封闭原则 |\n| LSP | The Liskov Substitution Principle | 里氏替换原则 |\n| DIP | The Dependency Inversion Principle | 依赖倒置原则 |\n| ISP | The Interface Segregation Principle | 接口分离原则 |\n\n- 单一职责原则\n表明软件组件（函数，类，模块）必须专注于单一的任务，当这个类需要承当其他类型的责任的时候，就需要分解这个类。\n- 开放封闭原则\n表明软件设计时必须时刻考虑到（代码）可能的发展（扩展性），但是程序的发展必须最少地修改已有的代码。也就是扩展开放，修改封闭。\n- 里氏替换原则\n表明只要继承的是同一个接口，程序里任意一个类都可以被其他的类替换。替换后不需要其他额外的工作程序就能像原来一样运行。\n- 依赖倒置原则\n表明一个方法应该遵从依赖于抽象（接口）而不是一个实例（类）的概念。\n高层模块不应该依赖于低层模块，二者都应该依赖于抽象\n抽象不应该依赖于细节，细节应该依赖于抽象\n- 接口隔离原则\n不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。\n\n\n### 基础类型 强类型\n\n#### 基础类型\n```ts\n// 布尔值\nlet isDone: boolean = false;\n// 数字 支持二、八、十、十六进制\nlet isNumber: number = 10;\n// 字符串\nlet isString: string = \"string\";\n// 模板字符串\nlet isExpr: string = `hello, ${isString}`;\n// 数组\nlet isArr: number[] = [1, 2, 3];\n// 数组泛型\nlet isList: Array<number> = [1, 2, 3];\n// 元组 Tuple（可以定义一个已知元素数量的数组，各个元素类型不必相同\nlet x: [string, number];\nx = ['string', 0];\nx = [0, 'string']; // error\n// 当访问一个越界的元素，会使用联合类型替代\nx[3] = 'world'; // x[3] 可以被赋值为（string | number）类型\n```\n\n#### 枚举\n`enum`\n```ts\nenum Color {Red, Green, Blue};\nconsole.log(Color);\n// {0: \"Red\", 1: \"Green\", 2: \"Blue\", Red: 0, Green: 1, Blue: 2}\nlet c:Color = Color.Green;\nconsole.log(c); // 1\n```\n#### 任意值 any\n```ts\nlet notSure: any = 'any';\nnotSure = 1;\nnotSure = false;\nlet list: any[] = [1, true ,'any'];\n```\n#### 空值 void\n```ts\nfunction returnVoid():void {\n  alert('is null');\n}\nlet unusable: void = null;\nlet unu:void = undefined;\n```\n\n#### 类型断言\nany值的指定猜测\n```ts\nlet someValue: any = \"some strings\";\n\nlet strLength: number = (<string>someValue).length;\nlet strLength: number = (someValue as string).length;\n```\n\n### 接口 interface\n\n```ts\n// 自定义的属性检查\ninterface LabelledValue {\n  label: string;\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = {size: 10, label: \"Size 10 Object\"};\nprintLabel(myObj);\n```\n#### 属性\n```ts\ninterface userInfo {\n  name?: string;  // 可选属性\n  readonly age: number; // 只读属性\n  [propName: string]: any; // 额外属性定义\n}\n```\n#### 函数类型\n```ts\ninterface searchFunc {\n    (src: string, sub: string): boolean;\n}\n\nlet mySearch: searchFunc;\nmySearch = (srcb, sub) => {\n    let res = srcb.search(sub);\n    if (res === -1) {\n        console.log('false');\n        return false;\n    } else {\n        console.log('true');\n        return true;\n    }\n}\nmySearch('aaaa', 'a'); // true\n```\n#### 可索引的类型\n```ts\ninterface StringArray {\n  [index: number]: string;\n}\n// 当使用 number 去索引 StringArray 时，会返回 string 类型的值。\n\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;\n  name: string;   //error `name`的类型不是索引类型的子类型\n}\n```\n\n#### 类类型\n```ts\ninterface IsTime {\n  currentTime: Date;\n  setTime(d: Date);\n}\nclass Clock implements IsTime {\n  currentTime: Date;\n  setTime(d: Date) {\n        this.currentTime = d;\n    }\n  constructor(h: number, m: number) { }\n}\n// 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n```\n\n#### 扩展接口\n```ts\ninterface Shape {\n  color: string;\n}\ninterface Square extends Shape {\n  sideLength: number;\n}\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\n// 一个接口可以继承多个接口，创建出多个接口的合成接口。\n```\n\n#### 混合类型\n```ts\n// 一个对象可以同时作为函数和对象使用,并带有额外属性。\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = <Counter>function (start: number) {};\n  counter.interval = 123;\n  counter.reset = function () {};\n  return counter;\n}\n```\n\n#### 接口继承类\n```ts\nclass Control {\n    private state: any;\n}\n\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\nclass Button extends Control {\n    select() { }\n}\n\nclass TextBox extends Control {\n    select() { }\n}\n\nclass Image {\n    select() { }\n}\n\nclass Location {\n    select() { }\n}\n```\n在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。\n\n在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl就像Control一样，并拥有一个select方法。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。\n\n\n\n### 类 Class\n\n#### 继承 extends\n```ts\nclass People {\n    name: string;\n    work: string;\n    constructor(theName: string, theWork: string) {\n        this.name = theName;\n        this.work = theWork;\n    }\n    getWork() {\n        console.log(`${this.name} is ${this.work}`);\n        \n    }\n}\n\nclass Student extends People {\n    constructor(name: string) {\n        super(name);\n        this.work = \"student\";\n    }\n    getWork() {\n        console.log('extend');\n        super.getWork();\n    }\n}\n\nlet sam = new Student(\"sam\")\nsam.getWork()\n```\n\n#### 公共，私有与受保护的修饰符\n默认为： public\n\n私有：private，不能在声明此类的外部访问\n```ts\n  private name: string;\n```\n\nprotected， 在派生类中仍然可以访问\n```ts\n  protected name: string;\n```\nreadonly 只读\n```ts\n  readonly name: string;\n```\n\n#### 存取器\n支持使用 get / set 截取对象成员的访问\n\n```ts\nclass Employee {\n  private _fullName: string;\n  get fullName(): string {\n    return this._fullName;\n  }\n  set fullName(newName: string) {\n    if (true) {\n      this._fullName = newName;\n    }\n  }\n}\n\nlet employee =new Employee();\nemployee.fullName = \"name\";\n ```\n\n#### 静态属性 static\n存在于类本身上面而不是类的实例上。\n```ts\nclass Grid {\n    static origin = {x: 0, y: 0};\n    calculateDistanceFromOrigin(point: {x: number; y: number;}) {\n        let xDist = (point.x - Grid.origin.x);\n        let yDist = (point.y - Grid.origin.y);\n        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n    }\n    constructor (public scale: number) { }\n}\n\nlet grid1 = new Grid(1.0);  // 1x scale\nlet grid2 = new Grid(5.0);  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));\nconsole.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));\n```\n\n#### 抽象类\n抽象类做为其它派生类的基类使用。 \n它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。\n``` ts\nabstract class Department {\n\n    constructor(public name: string) {\n    }\n\n    printName(): void {\n        console.log('Department name: ' + this.name);\n    }\n\n    abstract printMeeting(): void; // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n\n    constructor() {\n        super('Accounting and Auditing'); // constructors in derived classes must call super()\n    }\n\n    printMeeting(): void {\n        console.log('The Accounting Department meets each Monday at 10am.');\n    }\n\n    generateReports(): void {\n        console.log('Generating accounting reports...');\n    }\n}\n\nlet department: Department; // ok to create a reference to an abstract type\ndepartment = new Department(); // error: cannot create an instance of an abstract class\ndepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclass\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // error: method doesn't exist on declared abstract type\n```\n\n### 函数\n\n#### 函数定义类型\n```ts\nlet myAdd = (x: number, y: number): number => {\n    return x + y;\n}\n// 设定返回值为 number型\n```\n#### 可选参数和默认参数\n```ts\nfunction buildUser(firstName: string = \"you\", lastName?: string) {\n  if(lastName) {\n    return firstName + \" \" +lastName;\n  } else {\n    return firstName;\n  }\n}\n// 可选参数必须跟在必须参数后面。\n```\n\n### 泛型","source":"_posts/TypeScript中的OOP.md","raw":"---\ntitle: TypeScript的学习\ndate: 2017-03-23 22:27:15\ntags:\n---\n学习TypeScript...\n\n<!--more-->\n\n### SOLID原则\n|en    |     en      |ch   |\n| ------------- |:-------------:| -----:|\n| SRP | The Single Responsibility Principle | 单一责任原则 |\n| OCP | The Open Closed Principle | 开放封闭原则 |\n| LSP | The Liskov Substitution Principle | 里氏替换原则 |\n| DIP | The Dependency Inversion Principle | 依赖倒置原则 |\n| ISP | The Interface Segregation Principle | 接口分离原则 |\n\n- 单一职责原则\n表明软件组件（函数，类，模块）必须专注于单一的任务，当这个类需要承当其他类型的责任的时候，就需要分解这个类。\n- 开放封闭原则\n表明软件设计时必须时刻考虑到（代码）可能的发展（扩展性），但是程序的发展必须最少地修改已有的代码。也就是扩展开放，修改封闭。\n- 里氏替换原则\n表明只要继承的是同一个接口，程序里任意一个类都可以被其他的类替换。替换后不需要其他额外的工作程序就能像原来一样运行。\n- 依赖倒置原则\n表明一个方法应该遵从依赖于抽象（接口）而不是一个实例（类）的概念。\n高层模块不应该依赖于低层模块，二者都应该依赖于抽象\n抽象不应该依赖于细节，细节应该依赖于抽象\n- 接口隔离原则\n不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。\n\n\n### 基础类型 强类型\n\n#### 基础类型\n```ts\n// 布尔值\nlet isDone: boolean = false;\n// 数字 支持二、八、十、十六进制\nlet isNumber: number = 10;\n// 字符串\nlet isString: string = \"string\";\n// 模板字符串\nlet isExpr: string = `hello, ${isString}`;\n// 数组\nlet isArr: number[] = [1, 2, 3];\n// 数组泛型\nlet isList: Array<number> = [1, 2, 3];\n// 元组 Tuple（可以定义一个已知元素数量的数组，各个元素类型不必相同\nlet x: [string, number];\nx = ['string', 0];\nx = [0, 'string']; // error\n// 当访问一个越界的元素，会使用联合类型替代\nx[3] = 'world'; // x[3] 可以被赋值为（string | number）类型\n```\n\n#### 枚举\n`enum`\n```ts\nenum Color {Red, Green, Blue};\nconsole.log(Color);\n// {0: \"Red\", 1: \"Green\", 2: \"Blue\", Red: 0, Green: 1, Blue: 2}\nlet c:Color = Color.Green;\nconsole.log(c); // 1\n```\n#### 任意值 any\n```ts\nlet notSure: any = 'any';\nnotSure = 1;\nnotSure = false;\nlet list: any[] = [1, true ,'any'];\n```\n#### 空值 void\n```ts\nfunction returnVoid():void {\n  alert('is null');\n}\nlet unusable: void = null;\nlet unu:void = undefined;\n```\n\n#### 类型断言\nany值的指定猜测\n```ts\nlet someValue: any = \"some strings\";\n\nlet strLength: number = (<string>someValue).length;\nlet strLength: number = (someValue as string).length;\n```\n\n### 接口 interface\n\n```ts\n// 自定义的属性检查\ninterface LabelledValue {\n  label: string;\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = {size: 10, label: \"Size 10 Object\"};\nprintLabel(myObj);\n```\n#### 属性\n```ts\ninterface userInfo {\n  name?: string;  // 可选属性\n  readonly age: number; // 只读属性\n  [propName: string]: any; // 额外属性定义\n}\n```\n#### 函数类型\n```ts\ninterface searchFunc {\n    (src: string, sub: string): boolean;\n}\n\nlet mySearch: searchFunc;\nmySearch = (srcb, sub) => {\n    let res = srcb.search(sub);\n    if (res === -1) {\n        console.log('false');\n        return false;\n    } else {\n        console.log('true');\n        return true;\n    }\n}\nmySearch('aaaa', 'a'); // true\n```\n#### 可索引的类型\n```ts\ninterface StringArray {\n  [index: number]: string;\n}\n// 当使用 number 去索引 StringArray 时，会返回 string 类型的值。\n\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;\n  name: string;   //error `name`的类型不是索引类型的子类型\n}\n```\n\n#### 类类型\n```ts\ninterface IsTime {\n  currentTime: Date;\n  setTime(d: Date);\n}\nclass Clock implements IsTime {\n  currentTime: Date;\n  setTime(d: Date) {\n        this.currentTime = d;\n    }\n  constructor(h: number, m: number) { }\n}\n// 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n```\n\n#### 扩展接口\n```ts\ninterface Shape {\n  color: string;\n}\ninterface Square extends Shape {\n  sideLength: number;\n}\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\n// 一个接口可以继承多个接口，创建出多个接口的合成接口。\n```\n\n#### 混合类型\n```ts\n// 一个对象可以同时作为函数和对象使用,并带有额外属性。\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = <Counter>function (start: number) {};\n  counter.interval = 123;\n  counter.reset = function () {};\n  return counter;\n}\n```\n\n#### 接口继承类\n```ts\nclass Control {\n    private state: any;\n}\n\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\nclass Button extends Control {\n    select() { }\n}\n\nclass TextBox extends Control {\n    select() { }\n}\n\nclass Image {\n    select() { }\n}\n\nclass Location {\n    select() { }\n}\n```\n在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。\n\n在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl就像Control一样，并拥有一个select方法。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。\n\n\n\n### 类 Class\n\n#### 继承 extends\n```ts\nclass People {\n    name: string;\n    work: string;\n    constructor(theName: string, theWork: string) {\n        this.name = theName;\n        this.work = theWork;\n    }\n    getWork() {\n        console.log(`${this.name} is ${this.work}`);\n        \n    }\n}\n\nclass Student extends People {\n    constructor(name: string) {\n        super(name);\n        this.work = \"student\";\n    }\n    getWork() {\n        console.log('extend');\n        super.getWork();\n    }\n}\n\nlet sam = new Student(\"sam\")\nsam.getWork()\n```\n\n#### 公共，私有与受保护的修饰符\n默认为： public\n\n私有：private，不能在声明此类的外部访问\n```ts\n  private name: string;\n```\n\nprotected， 在派生类中仍然可以访问\n```ts\n  protected name: string;\n```\nreadonly 只读\n```ts\n  readonly name: string;\n```\n\n#### 存取器\n支持使用 get / set 截取对象成员的访问\n\n```ts\nclass Employee {\n  private _fullName: string;\n  get fullName(): string {\n    return this._fullName;\n  }\n  set fullName(newName: string) {\n    if (true) {\n      this._fullName = newName;\n    }\n  }\n}\n\nlet employee =new Employee();\nemployee.fullName = \"name\";\n ```\n\n#### 静态属性 static\n存在于类本身上面而不是类的实例上。\n```ts\nclass Grid {\n    static origin = {x: 0, y: 0};\n    calculateDistanceFromOrigin(point: {x: number; y: number;}) {\n        let xDist = (point.x - Grid.origin.x);\n        let yDist = (point.y - Grid.origin.y);\n        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n    }\n    constructor (public scale: number) { }\n}\n\nlet grid1 = new Grid(1.0);  // 1x scale\nlet grid2 = new Grid(5.0);  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));\nconsole.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));\n```\n\n#### 抽象类\n抽象类做为其它派生类的基类使用。 \n它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。\n``` ts\nabstract class Department {\n\n    constructor(public name: string) {\n    }\n\n    printName(): void {\n        console.log('Department name: ' + this.name);\n    }\n\n    abstract printMeeting(): void; // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n\n    constructor() {\n        super('Accounting and Auditing'); // constructors in derived classes must call super()\n    }\n\n    printMeeting(): void {\n        console.log('The Accounting Department meets each Monday at 10am.');\n    }\n\n    generateReports(): void {\n        console.log('Generating accounting reports...');\n    }\n}\n\nlet department: Department; // ok to create a reference to an abstract type\ndepartment = new Department(); // error: cannot create an instance of an abstract class\ndepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclass\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // error: method doesn't exist on declared abstract type\n```\n\n### 函数\n\n#### 函数定义类型\n```ts\nlet myAdd = (x: number, y: number): number => {\n    return x + y;\n}\n// 设定返回值为 number型\n```\n#### 可选参数和默认参数\n```ts\nfunction buildUser(firstName: string = \"you\", lastName?: string) {\n  if(lastName) {\n    return firstName + \" \" +lastName;\n  } else {\n    return firstName;\n  }\n}\n// 可选参数必须跟在必须参数后面。\n```\n\n### 泛型","slug":"TypeScript中的OOP","published":1,"updated":"2017-10-15T02:54:44.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl210008ttwp9d6mxp4c","content":"<p>学习TypeScript…</p>\n<a id=\"more\"></a>\n<h3 id=\"SOLID原则\"><a href=\"#SOLID原则\" class=\"headerlink\" title=\"SOLID原则\"></a>SOLID原则</h3><table>\n<thead>\n<tr>\n<th>en</th>\n<th style=\"text-align:center\">en</th>\n<th style=\"text-align:right\">ch</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SRP</td>\n<td style=\"text-align:center\">The Single Responsibility Principle</td>\n<td style=\"text-align:right\">单一责任原则</td>\n</tr>\n<tr>\n<td>OCP</td>\n<td style=\"text-align:center\">The Open Closed Principle</td>\n<td style=\"text-align:right\">开放封闭原则</td>\n</tr>\n<tr>\n<td>LSP</td>\n<td style=\"text-align:center\">The Liskov Substitution Principle</td>\n<td style=\"text-align:right\">里氏替换原则</td>\n</tr>\n<tr>\n<td>DIP</td>\n<td style=\"text-align:center\">The Dependency Inversion Principle</td>\n<td style=\"text-align:right\">依赖倒置原则</td>\n</tr>\n<tr>\n<td>ISP</td>\n<td style=\"text-align:center\">The Interface Segregation Principle</td>\n<td style=\"text-align:right\">接口分离原则</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>单一职责原则<br>表明软件组件（函数，类，模块）必须专注于单一的任务，当这个类需要承当其他类型的责任的时候，就需要分解这个类。</li>\n<li>开放封闭原则<br>表明软件设计时必须时刻考虑到（代码）可能的发展（扩展性），但是程序的发展必须最少地修改已有的代码。也就是扩展开放，修改封闭。</li>\n<li>里氏替换原则<br>表明只要继承的是同一个接口，程序里任意一个类都可以被其他的类替换。替换后不需要其他额外的工作程序就能像原来一样运行。</li>\n<li>依赖倒置原则<br>表明一个方法应该遵从依赖于抽象（接口）而不是一个实例（类）的概念。<br>高层模块不应该依赖于低层模块，二者都应该依赖于抽象<br>抽象不应该依赖于细节，细节应该依赖于抽象</li>\n<li>接口隔离原则<br>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。</li>\n</ul>\n<h3 id=\"基础类型-强类型\"><a href=\"#基础类型-强类型\" class=\"headerlink\" title=\"基础类型 强类型\"></a>基础类型 强类型</h3><h4 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h4><pre><code class=\"ts\">// 布尔值\nlet isDone: boolean = false;\n// 数字 支持二、八、十、十六进制\nlet isNumber: number = 10;\n// 字符串\nlet isString: string = &quot;string&quot;;\n// 模板字符串\nlet isExpr: string = `hello, ${isString}`;\n// 数组\nlet isArr: number[] = [1, 2, 3];\n// 数组泛型\nlet isList: Array&lt;number&gt; = [1, 2, 3];\n// 元组 Tuple（可以定义一个已知元素数量的数组，各个元素类型不必相同\nlet x: [string, number];\nx = [&#39;string&#39;, 0];\nx = [0, &#39;string&#39;]; // error\n// 当访问一个越界的元素，会使用联合类型替代\nx[3] = &#39;world&#39;; // x[3] 可以被赋值为（string | number）类型\n</code></pre>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><p><code>enum</code></p>\n<pre><code class=\"ts\">enum Color {Red, Green, Blue};\nconsole.log(Color);\n// {0: &quot;Red&quot;, 1: &quot;Green&quot;, 2: &quot;Blue&quot;, Red: 0, Green: 1, Blue: 2}\nlet c:Color = Color.Green;\nconsole.log(c); // 1\n</code></pre>\n<h4 id=\"任意值-any\"><a href=\"#任意值-any\" class=\"headerlink\" title=\"任意值 any\"></a>任意值 any</h4><pre><code class=\"ts\">let notSure: any = &#39;any&#39;;\nnotSure = 1;\nnotSure = false;\nlet list: any[] = [1, true ,&#39;any&#39;];\n</code></pre>\n<h4 id=\"空值-void\"><a href=\"#空值-void\" class=\"headerlink\" title=\"空值 void\"></a>空值 void</h4><pre><code class=\"ts\">function returnVoid():void {\n  alert(&#39;is null&#39;);\n}\nlet unusable: void = null;\nlet unu:void = undefined;\n</code></pre>\n<h4 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h4><p>any值的指定猜测</p>\n<pre><code class=\"ts\">let someValue: any = &quot;some strings&quot;;\n\nlet strLength: number = (&lt;string&gt;someValue).length;\nlet strLength: number = (someValue as string).length;\n</code></pre>\n<h3 id=\"接口-interface\"><a href=\"#接口-interface\" class=\"headerlink\" title=\"接口 interface\"></a>接口 interface</h3><pre><code class=\"ts\">// 自定义的属性检查\ninterface LabelledValue {\n  label: string;\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = {size: 10, label: &quot;Size 10 Object&quot;};\nprintLabel(myObj);\n</code></pre>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><pre><code class=\"ts\">interface userInfo {\n  name?: string;  // 可选属性\n  readonly age: number; // 只读属性\n  [propName: string]: any; // 额外属性定义\n}\n</code></pre>\n<h4 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h4><pre><code class=\"ts\">interface searchFunc {\n    (src: string, sub: string): boolean;\n}\n\nlet mySearch: searchFunc;\nmySearch = (srcb, sub) =&gt; {\n    let res = srcb.search(sub);\n    if (res === -1) {\n        console.log(&#39;false&#39;);\n        return false;\n    } else {\n        console.log(&#39;true&#39;);\n        return true;\n    }\n}\nmySearch(&#39;aaaa&#39;, &#39;a&#39;); // true\n</code></pre>\n<h4 id=\"可索引的类型\"><a href=\"#可索引的类型\" class=\"headerlink\" title=\"可索引的类型\"></a>可索引的类型</h4><pre><code class=\"ts\">interface StringArray {\n  [index: number]: string;\n}\n// 当使用 number 去索引 StringArray 时，会返回 string 类型的值。\n\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;\n  name: string;   //error `name`的类型不是索引类型的子类型\n}\n</code></pre>\n<h4 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a>类类型</h4><pre><code class=\"ts\">interface IsTime {\n  currentTime: Date;\n  setTime(d: Date);\n}\nclass Clock implements IsTime {\n  currentTime: Date;\n  setTime(d: Date) {\n        this.currentTime = d;\n    }\n  constructor(h: number, m: number) { }\n}\n// 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n</code></pre>\n<h4 id=\"扩展接口\"><a href=\"#扩展接口\" class=\"headerlink\" title=\"扩展接口\"></a>扩展接口</h4><pre><code class=\"ts\">interface Shape {\n  color: string;\n}\ninterface Square extends Shape {\n  sideLength: number;\n}\nlet square = &lt;Square&gt;{};\nsquare.color = &quot;blue&quot;;\nsquare.sideLength = 10;\n// 一个接口可以继承多个接口，创建出多个接口的合成接口。\n</code></pre>\n<h4 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型</h4><pre><code class=\"ts\">// 一个对象可以同时作为函数和对象使用,并带有额外属性。\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = &lt;Counter&gt;function (start: number) {};\n  counter.interval = 123;\n  counter.reset = function () {};\n  return counter;\n}\n</code></pre>\n<h4 id=\"接口继承类\"><a href=\"#接口继承类\" class=\"headerlink\" title=\"接口继承类\"></a>接口继承类</h4><pre><code class=\"ts\">class Control {\n    private state: any;\n}\n\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\nclass Button extends Control {\n    select() { }\n}\n\nclass TextBox extends Control {\n    select() { }\n}\n\nclass Image {\n    select() { }\n}\n\nclass Location {\n    select() { }\n}\n</code></pre>\n<p>在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。</p>\n<p>在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl就像Control一样，并拥有一个select方法。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。</p>\n<h3 id=\"类-Class\"><a href=\"#类-Class\" class=\"headerlink\" title=\"类 Class\"></a>类 Class</h3><h4 id=\"继承-extends\"><a href=\"#继承-extends\" class=\"headerlink\" title=\"继承 extends\"></a>继承 extends</h4><pre><code class=\"ts\">class People {\n    name: string;\n    work: string;\n    constructor(theName: string, theWork: string) {\n        this.name = theName;\n        this.work = theWork;\n    }\n    getWork() {\n        console.log(`${this.name} is ${this.work}`);\n\n    }\n}\n\nclass Student extends People {\n    constructor(name: string) {\n        super(name);\n        this.work = &quot;student&quot;;\n    }\n    getWork() {\n        console.log(&#39;extend&#39;);\n        super.getWork();\n    }\n}\n\nlet sam = new Student(&quot;sam&quot;)\nsam.getWork()\n</code></pre>\n<h4 id=\"公共，私有与受保护的修饰符\"><a href=\"#公共，私有与受保护的修饰符\" class=\"headerlink\" title=\"公共，私有与受保护的修饰符\"></a>公共，私有与受保护的修饰符</h4><p>默认为： public</p>\n<p>私有：private，不能在声明此类的外部访问</p>\n<pre><code class=\"ts\">  private name: string;\n</code></pre>\n<p>protected， 在派生类中仍然可以访问</p>\n<pre><code class=\"ts\">  protected name: string;\n</code></pre>\n<p>readonly 只读</p>\n<pre><code class=\"ts\">  readonly name: string;\n</code></pre>\n<h4 id=\"存取器\"><a href=\"#存取器\" class=\"headerlink\" title=\"存取器\"></a>存取器</h4><p>支持使用 get / set 截取对象成员的访问</p>\n<pre><code class=\"ts\">class Employee {\n  private _fullName: string;\n  get fullName(): string {\n    return this._fullName;\n  }\n  set fullName(newName: string) {\n    if (true) {\n      this._fullName = newName;\n    }\n  }\n}\n\nlet employee =new Employee();\nemployee.fullName = &quot;name&quot;;\n</code></pre>\n<h4 id=\"静态属性-static\"><a href=\"#静态属性-static\" class=\"headerlink\" title=\"静态属性 static\"></a>静态属性 static</h4><p>存在于类本身上面而不是类的实例上。</p>\n<pre><code class=\"ts\">class Grid {\n    static origin = {x: 0, y: 0};\n    calculateDistanceFromOrigin(point: {x: number; y: number;}) {\n        let xDist = (point.x - Grid.origin.x);\n        let yDist = (point.y - Grid.origin.y);\n        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n    }\n    constructor (public scale: number) { }\n}\n\nlet grid1 = new Grid(1.0);  // 1x scale\nlet grid2 = new Grid(5.0);  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));\nconsole.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));\n</code></pre>\n<h4 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h4><p>抽象类做为其它派生类的基类使用。<br>它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。</p>\n<pre><code class=\"ts\">abstract class Department {\n\n    constructor(public name: string) {\n    }\n\n    printName(): void {\n        console.log(&#39;Department name: &#39; + this.name);\n    }\n\n    abstract printMeeting(): void; // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n\n    constructor() {\n        super(&#39;Accounting and Auditing&#39;); // constructors in derived classes must call super()\n    }\n\n    printMeeting(): void {\n        console.log(&#39;The Accounting Department meets each Monday at 10am.&#39;);\n    }\n\n    generateReports(): void {\n        console.log(&#39;Generating accounting reports...&#39;);\n    }\n}\n\nlet department: Department; // ok to create a reference to an abstract type\ndepartment = new Department(); // error: cannot create an instance of an abstract class\ndepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclass\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // error: method doesn&#39;t exist on declared abstract type\n</code></pre>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"函数定义类型\"><a href=\"#函数定义类型\" class=\"headerlink\" title=\"函数定义类型\"></a>函数定义类型</h4><pre><code class=\"ts\">let myAdd = (x: number, y: number): number =&gt; {\n    return x + y;\n}\n// 设定返回值为 number型\n</code></pre>\n<h4 id=\"可选参数和默认参数\"><a href=\"#可选参数和默认参数\" class=\"headerlink\" title=\"可选参数和默认参数\"></a>可选参数和默认参数</h4><pre><code class=\"ts\">function buildUser(firstName: string = &quot;you&quot;, lastName?: string) {\n  if(lastName) {\n    return firstName + &quot; &quot; +lastName;\n  } else {\n    return firstName;\n  }\n}\n// 可选参数必须跟在必须参数后面。\n</code></pre>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3>","site":{"data":{}},"excerpt":"<p>学习TypeScript…</p>","more":"<h3 id=\"SOLID原则\"><a href=\"#SOLID原则\" class=\"headerlink\" title=\"SOLID原则\"></a>SOLID原则</h3><table>\n<thead>\n<tr>\n<th>en</th>\n<th style=\"text-align:center\">en</th>\n<th style=\"text-align:right\">ch</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SRP</td>\n<td style=\"text-align:center\">The Single Responsibility Principle</td>\n<td style=\"text-align:right\">单一责任原则</td>\n</tr>\n<tr>\n<td>OCP</td>\n<td style=\"text-align:center\">The Open Closed Principle</td>\n<td style=\"text-align:right\">开放封闭原则</td>\n</tr>\n<tr>\n<td>LSP</td>\n<td style=\"text-align:center\">The Liskov Substitution Principle</td>\n<td style=\"text-align:right\">里氏替换原则</td>\n</tr>\n<tr>\n<td>DIP</td>\n<td style=\"text-align:center\">The Dependency Inversion Principle</td>\n<td style=\"text-align:right\">依赖倒置原则</td>\n</tr>\n<tr>\n<td>ISP</td>\n<td style=\"text-align:center\">The Interface Segregation Principle</td>\n<td style=\"text-align:right\">接口分离原则</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>单一职责原则<br>表明软件组件（函数，类，模块）必须专注于单一的任务，当这个类需要承当其他类型的责任的时候，就需要分解这个类。</li>\n<li>开放封闭原则<br>表明软件设计时必须时刻考虑到（代码）可能的发展（扩展性），但是程序的发展必须最少地修改已有的代码。也就是扩展开放，修改封闭。</li>\n<li>里氏替换原则<br>表明只要继承的是同一个接口，程序里任意一个类都可以被其他的类替换。替换后不需要其他额外的工作程序就能像原来一样运行。</li>\n<li>依赖倒置原则<br>表明一个方法应该遵从依赖于抽象（接口）而不是一个实例（类）的概念。<br>高层模块不应该依赖于低层模块，二者都应该依赖于抽象<br>抽象不应该依赖于细节，细节应该依赖于抽象</li>\n<li>接口隔离原则<br>不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。</li>\n</ul>\n<h3 id=\"基础类型-强类型\"><a href=\"#基础类型-强类型\" class=\"headerlink\" title=\"基础类型 强类型\"></a>基础类型 强类型</h3><h4 id=\"基础类型\"><a href=\"#基础类型\" class=\"headerlink\" title=\"基础类型\"></a>基础类型</h4><pre><code class=\"ts\">// 布尔值\nlet isDone: boolean = false;\n// 数字 支持二、八、十、十六进制\nlet isNumber: number = 10;\n// 字符串\nlet isString: string = &quot;string&quot;;\n// 模板字符串\nlet isExpr: string = `hello, ${isString}`;\n// 数组\nlet isArr: number[] = [1, 2, 3];\n// 数组泛型\nlet isList: Array&lt;number&gt; = [1, 2, 3];\n// 元组 Tuple（可以定义一个已知元素数量的数组，各个元素类型不必相同\nlet x: [string, number];\nx = [&#39;string&#39;, 0];\nx = [0, &#39;string&#39;]; // error\n// 当访问一个越界的元素，会使用联合类型替代\nx[3] = &#39;world&#39;; // x[3] 可以被赋值为（string | number）类型\n</code></pre>\n<h4 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h4><p><code>enum</code></p>\n<pre><code class=\"ts\">enum Color {Red, Green, Blue};\nconsole.log(Color);\n// {0: &quot;Red&quot;, 1: &quot;Green&quot;, 2: &quot;Blue&quot;, Red: 0, Green: 1, Blue: 2}\nlet c:Color = Color.Green;\nconsole.log(c); // 1\n</code></pre>\n<h4 id=\"任意值-any\"><a href=\"#任意值-any\" class=\"headerlink\" title=\"任意值 any\"></a>任意值 any</h4><pre><code class=\"ts\">let notSure: any = &#39;any&#39;;\nnotSure = 1;\nnotSure = false;\nlet list: any[] = [1, true ,&#39;any&#39;];\n</code></pre>\n<h4 id=\"空值-void\"><a href=\"#空值-void\" class=\"headerlink\" title=\"空值 void\"></a>空值 void</h4><pre><code class=\"ts\">function returnVoid():void {\n  alert(&#39;is null&#39;);\n}\nlet unusable: void = null;\nlet unu:void = undefined;\n</code></pre>\n<h4 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h4><p>any值的指定猜测</p>\n<pre><code class=\"ts\">let someValue: any = &quot;some strings&quot;;\n\nlet strLength: number = (&lt;string&gt;someValue).length;\nlet strLength: number = (someValue as string).length;\n</code></pre>\n<h3 id=\"接口-interface\"><a href=\"#接口-interface\" class=\"headerlink\" title=\"接口 interface\"></a>接口 interface</h3><pre><code class=\"ts\">// 自定义的属性检查\ninterface LabelledValue {\n  label: string;\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = {size: 10, label: &quot;Size 10 Object&quot;};\nprintLabel(myObj);\n</code></pre>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><pre><code class=\"ts\">interface userInfo {\n  name?: string;  // 可选属性\n  readonly age: number; // 只读属性\n  [propName: string]: any; // 额外属性定义\n}\n</code></pre>\n<h4 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h4><pre><code class=\"ts\">interface searchFunc {\n    (src: string, sub: string): boolean;\n}\n\nlet mySearch: searchFunc;\nmySearch = (srcb, sub) =&gt; {\n    let res = srcb.search(sub);\n    if (res === -1) {\n        console.log(&#39;false&#39;);\n        return false;\n    } else {\n        console.log(&#39;true&#39;);\n        return true;\n    }\n}\nmySearch(&#39;aaaa&#39;, &#39;a&#39;); // true\n</code></pre>\n<h4 id=\"可索引的类型\"><a href=\"#可索引的类型\" class=\"headerlink\" title=\"可索引的类型\"></a>可索引的类型</h4><pre><code class=\"ts\">interface StringArray {\n  [index: number]: string;\n}\n// 当使用 number 去索引 StringArray 时，会返回 string 类型的值。\n\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;\n  name: string;   //error `name`的类型不是索引类型的子类型\n}\n</code></pre>\n<h4 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a>类类型</h4><pre><code class=\"ts\">interface IsTime {\n  currentTime: Date;\n  setTime(d: Date);\n}\nclass Clock implements IsTime {\n  currentTime: Date;\n  setTime(d: Date) {\n        this.currentTime = d;\n    }\n  constructor(h: number, m: number) { }\n}\n// 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n</code></pre>\n<h4 id=\"扩展接口\"><a href=\"#扩展接口\" class=\"headerlink\" title=\"扩展接口\"></a>扩展接口</h4><pre><code class=\"ts\">interface Shape {\n  color: string;\n}\ninterface Square extends Shape {\n  sideLength: number;\n}\nlet square = &lt;Square&gt;{};\nsquare.color = &quot;blue&quot;;\nsquare.sideLength = 10;\n// 一个接口可以继承多个接口，创建出多个接口的合成接口。\n</code></pre>\n<h4 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型</h4><pre><code class=\"ts\">// 一个对象可以同时作为函数和对象使用,并带有额外属性。\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = &lt;Counter&gt;function (start: number) {};\n  counter.interval = 123;\n  counter.reset = function () {};\n  return counter;\n}\n</code></pre>\n<h4 id=\"接口继承类\"><a href=\"#接口继承类\" class=\"headerlink\" title=\"接口继承类\"></a>接口继承类</h4><pre><code class=\"ts\">class Control {\n    private state: any;\n}\n\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\nclass Button extends Control {\n    select() { }\n}\n\nclass TextBox extends Control {\n    select() { }\n}\n\nclass Image {\n    select() { }\n}\n\nclass Location {\n    select() { }\n}\n</code></pre>\n<p>在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。</p>\n<p>在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl就像Control一样，并拥有一个select方法。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。</p>\n<h3 id=\"类-Class\"><a href=\"#类-Class\" class=\"headerlink\" title=\"类 Class\"></a>类 Class</h3><h4 id=\"继承-extends\"><a href=\"#继承-extends\" class=\"headerlink\" title=\"继承 extends\"></a>继承 extends</h4><pre><code class=\"ts\">class People {\n    name: string;\n    work: string;\n    constructor(theName: string, theWork: string) {\n        this.name = theName;\n        this.work = theWork;\n    }\n    getWork() {\n        console.log(`${this.name} is ${this.work}`);\n\n    }\n}\n\nclass Student extends People {\n    constructor(name: string) {\n        super(name);\n        this.work = &quot;student&quot;;\n    }\n    getWork() {\n        console.log(&#39;extend&#39;);\n        super.getWork();\n    }\n}\n\nlet sam = new Student(&quot;sam&quot;)\nsam.getWork()\n</code></pre>\n<h4 id=\"公共，私有与受保护的修饰符\"><a href=\"#公共，私有与受保护的修饰符\" class=\"headerlink\" title=\"公共，私有与受保护的修饰符\"></a>公共，私有与受保护的修饰符</h4><p>默认为： public</p>\n<p>私有：private，不能在声明此类的外部访问</p>\n<pre><code class=\"ts\">  private name: string;\n</code></pre>\n<p>protected， 在派生类中仍然可以访问</p>\n<pre><code class=\"ts\">  protected name: string;\n</code></pre>\n<p>readonly 只读</p>\n<pre><code class=\"ts\">  readonly name: string;\n</code></pre>\n<h4 id=\"存取器\"><a href=\"#存取器\" class=\"headerlink\" title=\"存取器\"></a>存取器</h4><p>支持使用 get / set 截取对象成员的访问</p>\n<pre><code class=\"ts\">class Employee {\n  private _fullName: string;\n  get fullName(): string {\n    return this._fullName;\n  }\n  set fullName(newName: string) {\n    if (true) {\n      this._fullName = newName;\n    }\n  }\n}\n\nlet employee =new Employee();\nemployee.fullName = &quot;name&quot;;\n</code></pre>\n<h4 id=\"静态属性-static\"><a href=\"#静态属性-static\" class=\"headerlink\" title=\"静态属性 static\"></a>静态属性 static</h4><p>存在于类本身上面而不是类的实例上。</p>\n<pre><code class=\"ts\">class Grid {\n    static origin = {x: 0, y: 0};\n    calculateDistanceFromOrigin(point: {x: number; y: number;}) {\n        let xDist = (point.x - Grid.origin.x);\n        let yDist = (point.y - Grid.origin.y);\n        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n    }\n    constructor (public scale: number) { }\n}\n\nlet grid1 = new Grid(1.0);  // 1x scale\nlet grid2 = new Grid(5.0);  // 5x scale\n\nconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));\nconsole.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));\n</code></pre>\n<h4 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h4><p>抽象类做为其它派生类的基类使用。<br>它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。</p>\n<pre><code class=\"ts\">abstract class Department {\n\n    constructor(public name: string) {\n    }\n\n    printName(): void {\n        console.log(&#39;Department name: &#39; + this.name);\n    }\n\n    abstract printMeeting(): void; // 必须在派生类中实现\n}\n\nclass AccountingDepartment extends Department {\n\n    constructor() {\n        super(&#39;Accounting and Auditing&#39;); // constructors in derived classes must call super()\n    }\n\n    printMeeting(): void {\n        console.log(&#39;The Accounting Department meets each Monday at 10am.&#39;);\n    }\n\n    generateReports(): void {\n        console.log(&#39;Generating accounting reports...&#39;);\n    }\n}\n\nlet department: Department; // ok to create a reference to an abstract type\ndepartment = new Department(); // error: cannot create an instance of an abstract class\ndepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclass\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // error: method doesn&#39;t exist on declared abstract type\n</code></pre>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><h4 id=\"函数定义类型\"><a href=\"#函数定义类型\" class=\"headerlink\" title=\"函数定义类型\"></a>函数定义类型</h4><pre><code class=\"ts\">let myAdd = (x: number, y: number): number =&gt; {\n    return x + y;\n}\n// 设定返回值为 number型\n</code></pre>\n<h4 id=\"可选参数和默认参数\"><a href=\"#可选参数和默认参数\" class=\"headerlink\" title=\"可选参数和默认参数\"></a>可选参数和默认参数</h4><pre><code class=\"ts\">function buildUser(firstName: string = &quot;you&quot;, lastName?: string) {\n  if(lastName) {\n    return firstName + &quot; &quot; +lastName;\n  } else {\n    return firstName;\n  }\n}\n// 可选参数必须跟在必须参数后面。\n</code></pre>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3>"},{"title":"WebGL-study","date":"2017-11-19T08:27:17.000Z","_content":"<!--more-->\n\n","source":"_posts/WebGL-study.md","raw":"---\ntitle: WebGL-study\ndate: 2017-11-19 16:27:17\ntags:\n---\n<!--more-->\n\n","slug":"WebGL-study","published":1,"updated":"2017-11-19T08:28:18.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl24000bttwp52ita96c","content":"<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"","more":""},{"title":"js中的arguments","date":"2016-12-09T07:42:27.000Z","_content":"开始复习javascript的一些基础。\n\n<!--more-->\n# argument\n  是当前函数的一个内置属性，在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。\n\n- 无需明确参数即可重写函数\n- 可检测调用参数的个数\n- arguments对象的长度是由实参个数而不是形参个数决定的，没有调用的参数不能被获取\n```\n\t\tvar arr= function(a,b,c){\n\t\t\t a+=5;\n\t\t\t b+=1;\n\t\t\t console.log(arguments[0]);\t\t\t\t\t//输出 10\n\t\t\t console.log(arguments[1]);\t\t\t\t\t//输出undefined\t\n\t\t\t console.log(arguments);\t\t\t\t\t   //输出[10]\t\t\t\t\n\t\t\t console.log(arguments.length);\t\t\t\t//输出1\n\t\t};\n\t\tarr(5);\n```\n- 函数重载：函数返回值不同或形参个数不同。\njs的函数声明没有返回值类型\nJavaScript中形参的个数严格意义上来讲只是为了方便在函数中的变量操作，实际上实参已经存储在arguments对象中了\n用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载\n```\n\t\tvar arr= function(a,b,c){\n\t\t\tif(arguments.length==1){\n\t\t\t\tconsole.log(arguments[0]+1);\n\t\t\t}\n\t\t\telse if(arguments.length>1){\n\t\t\t\tfor(var i=0;i<arguments.length;i++){\n\t\t\t\t\tconsole.log(i+\":\"+arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tarr(5);        //输出6\n\t\tarr(5,6,7);  //输出0：5，1：6，2：7\n```\n- arguments.callee\n返回此arguments对象所在的当前函数引用,递归中代替函数本身\n```\n\t\tvar arr= function(a){\n\t\t\tif(a==1){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn  a + arguments.callee(--a);\n\t\t\t}\n\t};\n\t\tb=arr(6);\n\t\tconsole.log(b); //输出21\n```","source":"_posts/js中的arguments.md","raw":"---\ntitle: js中的arguments\ndate: 2016-12-09 15:42:27\ntags:\n  - javascript\n---\n开始复习javascript的一些基础。\n\n<!--more-->\n# argument\n  是当前函数的一个内置属性，在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。\n\n- 无需明确参数即可重写函数\n- 可检测调用参数的个数\n- arguments对象的长度是由实参个数而不是形参个数决定的，没有调用的参数不能被获取\n```\n\t\tvar arr= function(a,b,c){\n\t\t\t a+=5;\n\t\t\t b+=1;\n\t\t\t console.log(arguments[0]);\t\t\t\t\t//输出 10\n\t\t\t console.log(arguments[1]);\t\t\t\t\t//输出undefined\t\n\t\t\t console.log(arguments);\t\t\t\t\t   //输出[10]\t\t\t\t\n\t\t\t console.log(arguments.length);\t\t\t\t//输出1\n\t\t};\n\t\tarr(5);\n```\n- 函数重载：函数返回值不同或形参个数不同。\njs的函数声明没有返回值类型\nJavaScript中形参的个数严格意义上来讲只是为了方便在函数中的变量操作，实际上实参已经存储在arguments对象中了\n用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载\n```\n\t\tvar arr= function(a,b,c){\n\t\t\tif(arguments.length==1){\n\t\t\t\tconsole.log(arguments[0]+1);\n\t\t\t}\n\t\t\telse if(arguments.length>1){\n\t\t\t\tfor(var i=0;i<arguments.length;i++){\n\t\t\t\t\tconsole.log(i+\":\"+arguments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tarr(5);        //输出6\n\t\tarr(5,6,7);  //输出0：5，1：6，2：7\n```\n- arguments.callee\n返回此arguments对象所在的当前函数引用,递归中代替函数本身\n```\n\t\tvar arr= function(a){\n\t\t\tif(a==1){\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn  a + arguments.callee(--a);\n\t\t\t}\n\t};\n\t\tb=arr(6);\n\t\tconsole.log(b); //输出21\n```","slug":"js中的arguments","published":1,"updated":"2017-01-23T11:10:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl27000cttwps3w1mr3c","content":"<p>开始复习javascript的一些基础。</p>\n<a id=\"more\"></a>\n<h1 id=\"argument\"><a href=\"#argument\" class=\"headerlink\" title=\"argument\"></a>argument</h1><p>  是当前函数的一个内置属性，在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。</p>\n<ul>\n<li>无需明确参数即可重写函数</li>\n<li>可检测调用参数的个数</li>\n<li>arguments对象的长度是由实参个数而不是形参个数决定的，没有调用的参数不能被获取<pre><code>      var arr= function(a,b,c){\n           a+=5;\n           b+=1;\n           console.log(arguments[0]);                    //输出 10\n           console.log(arguments[1]);                    //输出undefined    \n           console.log(arguments);                       //输出[10]                \n           console.log(arguments.length);                //输出1\n      };\n      arr(5);\n</code></pre></li>\n<li>函数重载：函数返回值不同或形参个数不同。<br>js的函数声明没有返回值类型<br>JavaScript中形参的个数严格意义上来讲只是为了方便在函数中的变量操作，实际上实参已经存储在arguments对象中了<br>用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载<pre><code>      var arr= function(a,b,c){\n          if(arguments.length==1){\n              console.log(arguments[0]+1);\n          }\n          else if(arguments.length&gt;1){\n              for(var i=0;i&lt;arguments.length;i++){\n                  console.log(i+&quot;:&quot;+arguments[i]);\n              }\n          }\n      };\n      arr(5);        //输出6\n      arr(5,6,7);  //输出0：5，1：6，2：7\n</code></pre></li>\n<li>arguments.callee<br>返回此arguments对象所在的当前函数引用,递归中代替函数本身<pre><code>      var arr= function(a){\n          if(a==1){\n              return 1;\n          }\n          else {\n              return  a + arguments.callee(--a);\n          }\n  };\n      b=arr(6);\n      console.log(b); //输出21\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>开始复习javascript的一些基础。</p>","more":"<h1 id=\"argument\"><a href=\"#argument\" class=\"headerlink\" title=\"argument\"></a>argument</h1><p>  是当前函数的一个内置属性，在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。</p>\n<ul>\n<li>无需明确参数即可重写函数</li>\n<li>可检测调用参数的个数</li>\n<li>arguments对象的长度是由实参个数而不是形参个数决定的，没有调用的参数不能被获取<pre><code>      var arr= function(a,b,c){\n           a+=5;\n           b+=1;\n           console.log(arguments[0]);                    //输出 10\n           console.log(arguments[1]);                    //输出undefined    \n           console.log(arguments);                       //输出[10]                \n           console.log(arguments.length);                //输出1\n      };\n      arr(5);\n</code></pre></li>\n<li>函数重载：函数返回值不同或形参个数不同。<br>js的函数声明没有返回值类型<br>JavaScript中形参的个数严格意义上来讲只是为了方便在函数中的变量操作，实际上实参已经存储在arguments对象中了<br>用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载<pre><code>      var arr= function(a,b,c){\n          if(arguments.length==1){\n              console.log(arguments[0]+1);\n          }\n          else if(arguments.length&gt;1){\n              for(var i=0;i&lt;arguments.length;i++){\n                  console.log(i+&quot;:&quot;+arguments[i]);\n              }\n          }\n      };\n      arr(5);        //输出6\n      arr(5,6,7);  //输出0：5，1：6，2：7\n</code></pre></li>\n<li>arguments.callee<br>返回此arguments对象所在的当前函数引用,递归中代替函数本身<pre><code>      var arr= function(a){\n          if(a==1){\n              return 1;\n          }\n          else {\n              return  a + arguments.callee(--a);\n          }\n  };\n      b=arr(6);\n      console.log(b); //输出21\n</code></pre></li>\n</ul>"},{"title":"angular4 directive入场动画","date":"2017-11-24T00:39:38.000Z","_content":"<!--more -->\n\n## 通过Directive实现入场动画\n\n### 创建指令并引入所需\n\n```ts\nimport { Directive, ElementRef, HostListener, HostBinding  } from '@angular/core';\n\n@Directive({\n  selector: '[VisualIn]'\n})\nexport class VisualInDirective {\n  finished: boolean;\n  constructor(\n    private el: ElementRef,\n  ) {\n    this.finished = false;\n  }\n```\n### 使用`HostListener`为宿主元素添加`window`监听\n\n```ts\n// scroll 监听\n@HostListener('window: scroll') elementShowIn() {}\n// load 监听\n@HostListener('window: load') elementLoadIn() {}\n```\n\n### 使用`HostBinding`为宿主元素绑定动画类名\n```ts\n  @HostBinding('class.bounceInRight') isAnimate: boolean;\n```\n```css\n@keyframes bounceInRight {\n  from, 60%, 75%, 90%, to {\n    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);\n  }\n\n  from {\n    opacity: 0;\n    transform: translate3d(3000px, 0, 0);\n  }\n\n  60% {\n    opacity: 1;\n    transform: translate3d(-25px, 0, 0);\n  }\n\n  75% {\n    transform: translate3d(10px, 0, 0);\n  }\n\n  90% {\n    transform: translate3d(-5px, 0, 0);\n  }\n\n  to {\n    transform: none;\n  }\n}\n\n.bounceInRight {\n  animation-duration: .5s;\n  animation-fill-mode: both;\n  animation-name: bounceInRight;\n}\n```\n### 获取元素相对于`body`标签的高度\n`documentElement.offsetTop`会获取标签到`offsetParent`的相对偏移高度\n默认的`offsetParent`返回一个指向最近的包含该元素的定位元素\n如果没有定位元素则返回最近的`table, table sell`或根元素\n因此我们需要遍历父级元素，从基元素获取所有父级定位元素，并累加相对偏移高度\n```ts\nprivate getOffsetBodyTop(el) {\n    let offsetBodyTop = 0;\n    function _getOffsetBodyTop(el) {\n      offsetBodyTop += el.offsetTop;\n      if (el.offsetParent.tagName != 'BODY') {\n        return _getOffsetBodyTop(el.offsetParent);\n      } else if (el.offsetParent.tagName == 'BODY') {\n        return false;\n      }\n    }\n    _getOffsetBodyTop(el);\n    return offsetBodyTop;\n  }\n```\n\n### 定位元素进入窗口的高度，并执行动画\n当 元素相对根元素的偏移高度 - 当前滚动高度 - 窗口高度 < 0 时，元素开始进入页面\n此时执行动画\n```ts\nprivate showAnimate(): Promise<any> {\n    return new Promise((resolve, reject) => {\n    const offsetBodyTop = this.getOffsetBodyTop(this.el.nativeElement); // 元素距离顶部高度\n    let _dst: number;   // 滚动高度\n    if (this.myPhone() === 'iPhone') {\n      _dst = document.body.scrollTop;\n    } else {\n      _dst = document.documentElement.scrollTop;\n    }\n    const _wsh = window.innerHeight;   // 屏幕高度\n    if (offsetBodyTop - _dst - _wsh < -30) {\n      if (this.finished) {\n        resolve('isFinished');\n      } else {\n        this.isAnimate = true;\n        this.finished = true;\n        resolve('show');\n      }\n    } else {\n      resolve('noShow');\n    }\n  });\n}\n\nprivate myPhone() {\n  const userAgent = navigator.userAgent;\n  if (userAgent.indexOf('iPhone') > -1) {\n    return 'iPhone';\n  }\n```\n\n### 修改HostListener\n```ts\n @HostListener('window:scroll') elementShowIn() {\n    this.showAnimate().then(res => {});\n  }\n  @HostListener('window:load') elementLoadIn() {\n    this.showAnimate().then(res => {});\n  }\n```\n\n### 添加指令\n在你需要的元素标签上添加\n```html\n<div  VisualIn></div>\n```\n[This is demo](http://blog.xuncs.cn)\n\n","source":"_posts/angular4-directive入场动画.md","raw":"---\ntitle: angular4 directive入场动画\ndate: 2017-11-24 08:39:38\ntags:\n  - JavaScript\n  - Angular4\n---\n<!--more -->\n\n## 通过Directive实现入场动画\n\n### 创建指令并引入所需\n\n```ts\nimport { Directive, ElementRef, HostListener, HostBinding  } from '@angular/core';\n\n@Directive({\n  selector: '[VisualIn]'\n})\nexport class VisualInDirective {\n  finished: boolean;\n  constructor(\n    private el: ElementRef,\n  ) {\n    this.finished = false;\n  }\n```\n### 使用`HostListener`为宿主元素添加`window`监听\n\n```ts\n// scroll 监听\n@HostListener('window: scroll') elementShowIn() {}\n// load 监听\n@HostListener('window: load') elementLoadIn() {}\n```\n\n### 使用`HostBinding`为宿主元素绑定动画类名\n```ts\n  @HostBinding('class.bounceInRight') isAnimate: boolean;\n```\n```css\n@keyframes bounceInRight {\n  from, 60%, 75%, 90%, to {\n    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);\n  }\n\n  from {\n    opacity: 0;\n    transform: translate3d(3000px, 0, 0);\n  }\n\n  60% {\n    opacity: 1;\n    transform: translate3d(-25px, 0, 0);\n  }\n\n  75% {\n    transform: translate3d(10px, 0, 0);\n  }\n\n  90% {\n    transform: translate3d(-5px, 0, 0);\n  }\n\n  to {\n    transform: none;\n  }\n}\n\n.bounceInRight {\n  animation-duration: .5s;\n  animation-fill-mode: both;\n  animation-name: bounceInRight;\n}\n```\n### 获取元素相对于`body`标签的高度\n`documentElement.offsetTop`会获取标签到`offsetParent`的相对偏移高度\n默认的`offsetParent`返回一个指向最近的包含该元素的定位元素\n如果没有定位元素则返回最近的`table, table sell`或根元素\n因此我们需要遍历父级元素，从基元素获取所有父级定位元素，并累加相对偏移高度\n```ts\nprivate getOffsetBodyTop(el) {\n    let offsetBodyTop = 0;\n    function _getOffsetBodyTop(el) {\n      offsetBodyTop += el.offsetTop;\n      if (el.offsetParent.tagName != 'BODY') {\n        return _getOffsetBodyTop(el.offsetParent);\n      } else if (el.offsetParent.tagName == 'BODY') {\n        return false;\n      }\n    }\n    _getOffsetBodyTop(el);\n    return offsetBodyTop;\n  }\n```\n\n### 定位元素进入窗口的高度，并执行动画\n当 元素相对根元素的偏移高度 - 当前滚动高度 - 窗口高度 < 0 时，元素开始进入页面\n此时执行动画\n```ts\nprivate showAnimate(): Promise<any> {\n    return new Promise((resolve, reject) => {\n    const offsetBodyTop = this.getOffsetBodyTop(this.el.nativeElement); // 元素距离顶部高度\n    let _dst: number;   // 滚动高度\n    if (this.myPhone() === 'iPhone') {\n      _dst = document.body.scrollTop;\n    } else {\n      _dst = document.documentElement.scrollTop;\n    }\n    const _wsh = window.innerHeight;   // 屏幕高度\n    if (offsetBodyTop - _dst - _wsh < -30) {\n      if (this.finished) {\n        resolve('isFinished');\n      } else {\n        this.isAnimate = true;\n        this.finished = true;\n        resolve('show');\n      }\n    } else {\n      resolve('noShow');\n    }\n  });\n}\n\nprivate myPhone() {\n  const userAgent = navigator.userAgent;\n  if (userAgent.indexOf('iPhone') > -1) {\n    return 'iPhone';\n  }\n```\n\n### 修改HostListener\n```ts\n @HostListener('window:scroll') elementShowIn() {\n    this.showAnimate().then(res => {});\n  }\n  @HostListener('window:load') elementLoadIn() {\n    this.showAnimate().then(res => {});\n  }\n```\n\n### 添加指令\n在你需要的元素标签上添加\n```html\n<div  VisualIn></div>\n```\n[This is demo](http://blog.xuncs.cn)\n\n","slug":"angular4-directive入场动画","published":1,"updated":"2017-11-24T02:51:27.278Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2e000ettwpvfk9edrx","content":"<a id=\"more\"></a>\n<h2 id=\"通过Directive实现入场动画\"><a href=\"#通过Directive实现入场动画\" class=\"headerlink\" title=\"通过Directive实现入场动画\"></a>通过Directive实现入场动画</h2><h3 id=\"创建指令并引入所需\"><a href=\"#创建指令并引入所需\" class=\"headerlink\" title=\"创建指令并引入所需\"></a>创建指令并引入所需</h3><pre><code class=\"ts\">import { Directive, ElementRef, HostListener, HostBinding  } from &#39;@angular/core&#39;;\n\n@Directive({\n  selector: &#39;[VisualIn]&#39;\n})\nexport class VisualInDirective {\n  finished: boolean;\n  constructor(\n    private el: ElementRef,\n  ) {\n    this.finished = false;\n  }\n</code></pre>\n<h3 id=\"使用HostListener为宿主元素添加window监听\"><a href=\"#使用HostListener为宿主元素添加window监听\" class=\"headerlink\" title=\"使用HostListener为宿主元素添加window监听\"></a>使用<code>HostListener</code>为宿主元素添加<code>window</code>监听</h3><pre><code class=\"ts\">// scroll 监听\n@HostListener(&#39;window: scroll&#39;) elementShowIn() {}\n// load 监听\n@HostListener(&#39;window: load&#39;) elementLoadIn() {}\n</code></pre>\n<h3 id=\"使用HostBinding为宿主元素绑定动画类名\"><a href=\"#使用HostBinding为宿主元素绑定动画类名\" class=\"headerlink\" title=\"使用HostBinding为宿主元素绑定动画类名\"></a>使用<code>HostBinding</code>为宿主元素绑定动画类名</h3><pre><code class=\"ts\">  @HostBinding(&#39;class.bounceInRight&#39;) isAnimate: boolean;\n</code></pre>\n<pre><code class=\"css\">@keyframes bounceInRight {\n  from, 60%, 75%, 90%, to {\n    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);\n  }\n\n  from {\n    opacity: 0;\n    transform: translate3d(3000px, 0, 0);\n  }\n\n  60% {\n    opacity: 1;\n    transform: translate3d(-25px, 0, 0);\n  }\n\n  75% {\n    transform: translate3d(10px, 0, 0);\n  }\n\n  90% {\n    transform: translate3d(-5px, 0, 0);\n  }\n\n  to {\n    transform: none;\n  }\n}\n\n.bounceInRight {\n  animation-duration: .5s;\n  animation-fill-mode: both;\n  animation-name: bounceInRight;\n}\n</code></pre>\n<h3 id=\"获取元素相对于body标签的高度\"><a href=\"#获取元素相对于body标签的高度\" class=\"headerlink\" title=\"获取元素相对于body标签的高度\"></a>获取元素相对于<code>body</code>标签的高度</h3><p><code>documentElement.offsetTop</code>会获取标签到<code>offsetParent</code>的相对偏移高度<br>默认的<code>offsetParent</code>返回一个指向最近的包含该元素的定位元素<br>如果没有定位元素则返回最近的<code>table, table sell</code>或根元素<br>因此我们需要遍历父级元素，从基元素获取所有父级定位元素，并累加相对偏移高度</p>\n<pre><code class=\"ts\">private getOffsetBodyTop(el) {\n    let offsetBodyTop = 0;\n    function _getOffsetBodyTop(el) {\n      offsetBodyTop += el.offsetTop;\n      if (el.offsetParent.tagName != &#39;BODY&#39;) {\n        return _getOffsetBodyTop(el.offsetParent);\n      } else if (el.offsetParent.tagName == &#39;BODY&#39;) {\n        return false;\n      }\n    }\n    _getOffsetBodyTop(el);\n    return offsetBodyTop;\n  }\n</code></pre>\n<h3 id=\"定位元素进入窗口的高度，并执行动画\"><a href=\"#定位元素进入窗口的高度，并执行动画\" class=\"headerlink\" title=\"定位元素进入窗口的高度，并执行动画\"></a>定位元素进入窗口的高度，并执行动画</h3><p>当 元素相对根元素的偏移高度 - 当前滚动高度 - 窗口高度 &lt; 0 时，元素开始进入页面<br>此时执行动画</p>\n<pre><code class=\"ts\">private showAnimate(): Promise&lt;any&gt; {\n    return new Promise((resolve, reject) =&gt; {\n    const offsetBodyTop = this.getOffsetBodyTop(this.el.nativeElement); // 元素距离顶部高度\n    let _dst: number;   // 滚动高度\n    if (this.myPhone() === &#39;iPhone&#39;) {\n      _dst = document.body.scrollTop;\n    } else {\n      _dst = document.documentElement.scrollTop;\n    }\n    const _wsh = window.innerHeight;   // 屏幕高度\n    if (offsetBodyTop - _dst - _wsh &lt; -30) {\n      if (this.finished) {\n        resolve(&#39;isFinished&#39;);\n      } else {\n        this.isAnimate = true;\n        this.finished = true;\n        resolve(&#39;show&#39;);\n      }\n    } else {\n      resolve(&#39;noShow&#39;);\n    }\n  });\n}\n\nprivate myPhone() {\n  const userAgent = navigator.userAgent;\n  if (userAgent.indexOf(&#39;iPhone&#39;) &gt; -1) {\n    return &#39;iPhone&#39;;\n  }\n</code></pre>\n<h3 id=\"修改HostListener\"><a href=\"#修改HostListener\" class=\"headerlink\" title=\"修改HostListener\"></a>修改HostListener</h3><pre><code class=\"ts\"> @HostListener(&#39;window:scroll&#39;) elementShowIn() {\n    this.showAnimate().then(res =&gt; {});\n  }\n  @HostListener(&#39;window:load&#39;) elementLoadIn() {\n    this.showAnimate().then(res =&gt; {});\n  }\n</code></pre>\n<h3 id=\"添加指令\"><a href=\"#添加指令\" class=\"headerlink\" title=\"添加指令\"></a>添加指令</h3><p>在你需要的元素标签上添加</p>\n<pre><code class=\"html\">&lt;div  VisualIn&gt;&lt;/div&gt;\n</code></pre>\n<p><a href=\"http://blog.xuncs.cn\" target=\"_blank\" rel=\"external\">This is demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"通过Directive实现入场动画\"><a href=\"#通过Directive实现入场动画\" class=\"headerlink\" title=\"通过Directive实现入场动画\"></a>通过Directive实现入场动画</h2><h3 id=\"创建指令并引入所需\"><a href=\"#创建指令并引入所需\" class=\"headerlink\" title=\"创建指令并引入所需\"></a>创建指令并引入所需</h3><pre><code class=\"ts\">import { Directive, ElementRef, HostListener, HostBinding  } from &#39;@angular/core&#39;;\n\n@Directive({\n  selector: &#39;[VisualIn]&#39;\n})\nexport class VisualInDirective {\n  finished: boolean;\n  constructor(\n    private el: ElementRef,\n  ) {\n    this.finished = false;\n  }\n</code></pre>\n<h3 id=\"使用HostListener为宿主元素添加window监听\"><a href=\"#使用HostListener为宿主元素添加window监听\" class=\"headerlink\" title=\"使用HostListener为宿主元素添加window监听\"></a>使用<code>HostListener</code>为宿主元素添加<code>window</code>监听</h3><pre><code class=\"ts\">// scroll 监听\n@HostListener(&#39;window: scroll&#39;) elementShowIn() {}\n// load 监听\n@HostListener(&#39;window: load&#39;) elementLoadIn() {}\n</code></pre>\n<h3 id=\"使用HostBinding为宿主元素绑定动画类名\"><a href=\"#使用HostBinding为宿主元素绑定动画类名\" class=\"headerlink\" title=\"使用HostBinding为宿主元素绑定动画类名\"></a>使用<code>HostBinding</code>为宿主元素绑定动画类名</h3><pre><code class=\"ts\">  @HostBinding(&#39;class.bounceInRight&#39;) isAnimate: boolean;\n</code></pre>\n<pre><code class=\"css\">@keyframes bounceInRight {\n  from, 60%, 75%, 90%, to {\n    animation-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);\n  }\n\n  from {\n    opacity: 0;\n    transform: translate3d(3000px, 0, 0);\n  }\n\n  60% {\n    opacity: 1;\n    transform: translate3d(-25px, 0, 0);\n  }\n\n  75% {\n    transform: translate3d(10px, 0, 0);\n  }\n\n  90% {\n    transform: translate3d(-5px, 0, 0);\n  }\n\n  to {\n    transform: none;\n  }\n}\n\n.bounceInRight {\n  animation-duration: .5s;\n  animation-fill-mode: both;\n  animation-name: bounceInRight;\n}\n</code></pre>\n<h3 id=\"获取元素相对于body标签的高度\"><a href=\"#获取元素相对于body标签的高度\" class=\"headerlink\" title=\"获取元素相对于body标签的高度\"></a>获取元素相对于<code>body</code>标签的高度</h3><p><code>documentElement.offsetTop</code>会获取标签到<code>offsetParent</code>的相对偏移高度<br>默认的<code>offsetParent</code>返回一个指向最近的包含该元素的定位元素<br>如果没有定位元素则返回最近的<code>table, table sell</code>或根元素<br>因此我们需要遍历父级元素，从基元素获取所有父级定位元素，并累加相对偏移高度</p>\n<pre><code class=\"ts\">private getOffsetBodyTop(el) {\n    let offsetBodyTop = 0;\n    function _getOffsetBodyTop(el) {\n      offsetBodyTop += el.offsetTop;\n      if (el.offsetParent.tagName != &#39;BODY&#39;) {\n        return _getOffsetBodyTop(el.offsetParent);\n      } else if (el.offsetParent.tagName == &#39;BODY&#39;) {\n        return false;\n      }\n    }\n    _getOffsetBodyTop(el);\n    return offsetBodyTop;\n  }\n</code></pre>\n<h3 id=\"定位元素进入窗口的高度，并执行动画\"><a href=\"#定位元素进入窗口的高度，并执行动画\" class=\"headerlink\" title=\"定位元素进入窗口的高度，并执行动画\"></a>定位元素进入窗口的高度，并执行动画</h3><p>当 元素相对根元素的偏移高度 - 当前滚动高度 - 窗口高度 &lt; 0 时，元素开始进入页面<br>此时执行动画</p>\n<pre><code class=\"ts\">private showAnimate(): Promise&lt;any&gt; {\n    return new Promise((resolve, reject) =&gt; {\n    const offsetBodyTop = this.getOffsetBodyTop(this.el.nativeElement); // 元素距离顶部高度\n    let _dst: number;   // 滚动高度\n    if (this.myPhone() === &#39;iPhone&#39;) {\n      _dst = document.body.scrollTop;\n    } else {\n      _dst = document.documentElement.scrollTop;\n    }\n    const _wsh = window.innerHeight;   // 屏幕高度\n    if (offsetBodyTop - _dst - _wsh &lt; -30) {\n      if (this.finished) {\n        resolve(&#39;isFinished&#39;);\n      } else {\n        this.isAnimate = true;\n        this.finished = true;\n        resolve(&#39;show&#39;);\n      }\n    } else {\n      resolve(&#39;noShow&#39;);\n    }\n  });\n}\n\nprivate myPhone() {\n  const userAgent = navigator.userAgent;\n  if (userAgent.indexOf(&#39;iPhone&#39;) &gt; -1) {\n    return &#39;iPhone&#39;;\n  }\n</code></pre>\n<h3 id=\"修改HostListener\"><a href=\"#修改HostListener\" class=\"headerlink\" title=\"修改HostListener\"></a>修改HostListener</h3><pre><code class=\"ts\"> @HostListener(&#39;window:scroll&#39;) elementShowIn() {\n    this.showAnimate().then(res =&gt; {});\n  }\n  @HostListener(&#39;window:load&#39;) elementLoadIn() {\n    this.showAnimate().then(res =&gt; {});\n  }\n</code></pre>\n<h3 id=\"添加指令\"><a href=\"#添加指令\" class=\"headerlink\" title=\"添加指令\"></a>添加指令</h3><p>在你需要的元素标签上添加</p>\n<pre><code class=\"html\">&lt;div  VisualIn&gt;&lt;/div&gt;\n</code></pre>\n<p><a href=\"http://blog.xuncs.cn\" target=\"_blank\" rel=\"external\">This is demo</a></p>"},{"title":"mongodb安全认证","date":"2017-06-07T09:29:07.000Z","_content":"安全认证...\n\n<!--more-->\n\n### mongodb安全认证\nMongoDB默认是不认证的，可以直接连上服务并对数据库进行操作。\n\n#### 创建一个管理员用户\n在开启验证之前必须创建一个管理员用户,管理员用户拥有userAdminAnyDatabase角色.此角色拥有管理用户的权限,注意此角色并不是最大权限的角色.\n\n```js\n> use admin\n> db.createUser(\n  {\n    user: \"admin\",  \n    pwd: \"admin\",  \n    roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ]  \n  }\n)\n// 此时查询集合, 有了users\n```\n\n```shell\n> show collections\nsystem.users\nsystem.version\n\n> db.system.users.find();\n{ \"_id\" : \"admin.admin\", \"user\" : \"admin\", \"db\" : \"admin\", \"credentials\" : { \"SCRAM-SHA-1\" : { \"iterationCount\" : 10000, \"salt\" : \"5ERebAcl9LdKTIL516jalw==\", \"storedKey\" : \"bjKBgILU9djmwn8jibg4Uu54u9w=\", \"serverKey\" : \"iSTR/nMXjCv5pljY1hIPPOumCLU=\" } }, \"roles\" : [ { \"role\" : \"userAdminAnyDatabase\", \"db\" : \"admin\" } ] }\n>  db.system.version.find();\n{ \"_id\" : \"authSchema\", \"currentVersion\" : 5 }\n```\n\n#### 用管理员登录\n```shell\nmongo  -u admin -p admin --authenticationDatabase admin\n```\nuserAdminAnyDatabase拥有的权限\n```\nchangeCustomData\nchangePassword\ncreateRole\ncreateUser\ndropRole\ndropUser\ngrantRole\nrevokeRole\nviewRole\nviewUser\n```\n\n#### 超级管理员\n拥有在任何数据库中分配任何用户全选的能力\n```\n1. dbOwner\n2. userAdmin\n3. userAdminAnyDayabase\n```\n\n```shell\ndb.createUser(\n  {\n    user: \"suq\",\n    pwd: \"suq\",\n    roles: [\n       { role: \"dbOwner\", db: \"admin\" },\n       { role: \"userAdmin\", db: \"admin\" },\n       { role: \"userAdminAnyDatabase\", db: \"admin\" }\n    ]\n  }\n)\n\n/// mongodb还直接提供了一个超级管理员角色root,例如我们创建一个admin用户为超级管理员\nuse admin\ndb.createUser(\n  {\n    user: \"admin\",\n    pwd: \"admin\",\n    roles: [ { role: \"root\",db:\"admin\" }]\n \n  }\n)\n```\n\n#### 切换用户\n```sh\n> db.auth(\"admin\", \"admin\")\n```\n\n#### 创建角色\n方法： `db.createRole()`\n需求：\n  在数据库有createRole()权限\n  需要有授予指定权限的权限\n\n一般来说，内建角色`userAdmin`与`userAdminAnyDatabase`满足以上要求\n\n语法：\n```sh\n{\n  role: \"<name>\",\n  privileges: [\n     { resource: { <resource> }, actions: [ \"<action>\", ... ] },\n     ...\n  ],\n  roles: [\n     { role: \"<role>\", db: \"<database>\" } | \"<role>\",\n      ...\n  ]\n}\n```\nrole 是创建role的名字\nresource是你想授权所对应的对象\nactions是授权的动作\nroles是把某个角色授权给此角色\n\n实例：\n```sh\nuse admin\ndb.createRole(\n   {\n     role: \"myClusterwideAdmin\",\n     privileges: [\n       { resource: { cluster: true }, actions: [ \"addShard\" ] },\n       { resource: { db: \"config\", collection: \"\" }, actions: [ \"find\", \"update\", \"insert\", \"remove\" ] },\n       { resource: { db: \"users\", collection: \"usersCollection\" }, actions: [ \"update\", \"insert\", \"remove\" ] },\n       { resource: { db: \"\", collection: \"\" }, actions: [ \"find\" ] }\n     ],\n     roles: [\n       { role: \"read\", db: \"admin\" }\n     ]\n   },\n   { w: \"majority\" , wtimeout: 5000 }\n)\n```\n\n#### 查看角色权限\n方法： `db.getRole()`\n查看所有非内建角色: `db.getRoles()`\n\n#### 查看用户角色\n方法： `db.getUser()`\n查看所有用户: `db.getUsers()`\n\n#### 授予/收回角色权限\n收回: `db.revokePrivilegesFromRole()`\n授予: `db.grantPrivilegesToRole()`\n\n#### 授予/收回用户角色\n收回: `db.revokeRolesFromUser()`\n授予: `db.grantRolesToUser()`\n\n#### 修改用户密码\n```sh\n> db.changeUserPassword(\"name\", \"newpass\")\n```","source":"_posts/mongodb安全认证.md","raw":"---\ntitle: mongodb安全认证\ndate: 2017-06-07 17:29:07\ntags:\n  - mongodb\n---\n安全认证...\n\n<!--more-->\n\n### mongodb安全认证\nMongoDB默认是不认证的，可以直接连上服务并对数据库进行操作。\n\n#### 创建一个管理员用户\n在开启验证之前必须创建一个管理员用户,管理员用户拥有userAdminAnyDatabase角色.此角色拥有管理用户的权限,注意此角色并不是最大权限的角色.\n\n```js\n> use admin\n> db.createUser(\n  {\n    user: \"admin\",  \n    pwd: \"admin\",  \n    roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ]  \n  }\n)\n// 此时查询集合, 有了users\n```\n\n```shell\n> show collections\nsystem.users\nsystem.version\n\n> db.system.users.find();\n{ \"_id\" : \"admin.admin\", \"user\" : \"admin\", \"db\" : \"admin\", \"credentials\" : { \"SCRAM-SHA-1\" : { \"iterationCount\" : 10000, \"salt\" : \"5ERebAcl9LdKTIL516jalw==\", \"storedKey\" : \"bjKBgILU9djmwn8jibg4Uu54u9w=\", \"serverKey\" : \"iSTR/nMXjCv5pljY1hIPPOumCLU=\" } }, \"roles\" : [ { \"role\" : \"userAdminAnyDatabase\", \"db\" : \"admin\" } ] }\n>  db.system.version.find();\n{ \"_id\" : \"authSchema\", \"currentVersion\" : 5 }\n```\n\n#### 用管理员登录\n```shell\nmongo  -u admin -p admin --authenticationDatabase admin\n```\nuserAdminAnyDatabase拥有的权限\n```\nchangeCustomData\nchangePassword\ncreateRole\ncreateUser\ndropRole\ndropUser\ngrantRole\nrevokeRole\nviewRole\nviewUser\n```\n\n#### 超级管理员\n拥有在任何数据库中分配任何用户全选的能力\n```\n1. dbOwner\n2. userAdmin\n3. userAdminAnyDayabase\n```\n\n```shell\ndb.createUser(\n  {\n    user: \"suq\",\n    pwd: \"suq\",\n    roles: [\n       { role: \"dbOwner\", db: \"admin\" },\n       { role: \"userAdmin\", db: \"admin\" },\n       { role: \"userAdminAnyDatabase\", db: \"admin\" }\n    ]\n  }\n)\n\n/// mongodb还直接提供了一个超级管理员角色root,例如我们创建一个admin用户为超级管理员\nuse admin\ndb.createUser(\n  {\n    user: \"admin\",\n    pwd: \"admin\",\n    roles: [ { role: \"root\",db:\"admin\" }]\n \n  }\n)\n```\n\n#### 切换用户\n```sh\n> db.auth(\"admin\", \"admin\")\n```\n\n#### 创建角色\n方法： `db.createRole()`\n需求：\n  在数据库有createRole()权限\n  需要有授予指定权限的权限\n\n一般来说，内建角色`userAdmin`与`userAdminAnyDatabase`满足以上要求\n\n语法：\n```sh\n{\n  role: \"<name>\",\n  privileges: [\n     { resource: { <resource> }, actions: [ \"<action>\", ... ] },\n     ...\n  ],\n  roles: [\n     { role: \"<role>\", db: \"<database>\" } | \"<role>\",\n      ...\n  ]\n}\n```\nrole 是创建role的名字\nresource是你想授权所对应的对象\nactions是授权的动作\nroles是把某个角色授权给此角色\n\n实例：\n```sh\nuse admin\ndb.createRole(\n   {\n     role: \"myClusterwideAdmin\",\n     privileges: [\n       { resource: { cluster: true }, actions: [ \"addShard\" ] },\n       { resource: { db: \"config\", collection: \"\" }, actions: [ \"find\", \"update\", \"insert\", \"remove\" ] },\n       { resource: { db: \"users\", collection: \"usersCollection\" }, actions: [ \"update\", \"insert\", \"remove\" ] },\n       { resource: { db: \"\", collection: \"\" }, actions: [ \"find\" ] }\n     ],\n     roles: [\n       { role: \"read\", db: \"admin\" }\n     ]\n   },\n   { w: \"majority\" , wtimeout: 5000 }\n)\n```\n\n#### 查看角色权限\n方法： `db.getRole()`\n查看所有非内建角色: `db.getRoles()`\n\n#### 查看用户角色\n方法： `db.getUser()`\n查看所有用户: `db.getUsers()`\n\n#### 授予/收回角色权限\n收回: `db.revokePrivilegesFromRole()`\n授予: `db.grantPrivilegesToRole()`\n\n#### 授予/收回用户角色\n收回: `db.revokeRolesFromUser()`\n授予: `db.grantRolesToUser()`\n\n#### 修改用户密码\n```sh\n> db.changeUserPassword(\"name\", \"newpass\")\n```","slug":"mongodb安全认证","published":1,"updated":"2017-06-07T12:58:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2h000gttwp1y45fup1","content":"<p>安全认证…</p>\n<a id=\"more\"></a>\n<h3 id=\"mongodb安全认证\"><a href=\"#mongodb安全认证\" class=\"headerlink\" title=\"mongodb安全认证\"></a>mongodb安全认证</h3><p>MongoDB默认是不认证的，可以直接连上服务并对数据库进行操作。</p>\n<h4 id=\"创建一个管理员用户\"><a href=\"#创建一个管理员用户\" class=\"headerlink\" title=\"创建一个管理员用户\"></a>创建一个管理员用户</h4><p>在开启验证之前必须创建一个管理员用户,管理员用户拥有userAdminAnyDatabase角色.此角色拥有管理用户的权限,注意此角色并不是最大权限的角色.</p>\n<pre><code class=\"js\">&gt; use admin\n&gt; db.createUser(\n  {\n    user: &quot;admin&quot;,  \n    pwd: &quot;admin&quot;,  \n    roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ]  \n  }\n)\n// 此时查询集合, 有了users\n</code></pre>\n<pre><code class=\"shell\">&gt; show collections\nsystem.users\nsystem.version\n\n&gt; db.system.users.find();\n{ &quot;_id&quot; : &quot;admin.admin&quot;, &quot;user&quot; : &quot;admin&quot;, &quot;db&quot; : &quot;admin&quot;, &quot;credentials&quot; : { &quot;SCRAM-SHA-1&quot; : { &quot;iterationCount&quot; : 10000, &quot;salt&quot; : &quot;5ERebAcl9LdKTIL516jalw==&quot;, &quot;storedKey&quot; : &quot;bjKBgILU9djmwn8jibg4Uu54u9w=&quot;, &quot;serverKey&quot; : &quot;iSTR/nMXjCv5pljY1hIPPOumCLU=&quot; } }, &quot;roles&quot; : [ { &quot;role&quot; : &quot;userAdminAnyDatabase&quot;, &quot;db&quot; : &quot;admin&quot; } ] }\n&gt;  db.system.version.find();\n{ &quot;_id&quot; : &quot;authSchema&quot;, &quot;currentVersion&quot; : 5 }\n</code></pre>\n<h4 id=\"用管理员登录\"><a href=\"#用管理员登录\" class=\"headerlink\" title=\"用管理员登录\"></a>用管理员登录</h4><pre><code class=\"shell\">mongo  -u admin -p admin --authenticationDatabase admin\n</code></pre>\n<p>userAdminAnyDatabase拥有的权限</p>\n<pre><code>changeCustomData\nchangePassword\ncreateRole\ncreateUser\ndropRole\ndropUser\ngrantRole\nrevokeRole\nviewRole\nviewUser\n</code></pre><h4 id=\"超级管理员\"><a href=\"#超级管理员\" class=\"headerlink\" title=\"超级管理员\"></a>超级管理员</h4><p>拥有在任何数据库中分配任何用户全选的能力</p>\n<pre><code>1. dbOwner\n2. userAdmin\n3. userAdminAnyDayabase\n</code></pre><pre><code class=\"shell\">db.createUser(\n  {\n    user: &quot;suq&quot;,\n    pwd: &quot;suq&quot;,\n    roles: [\n       { role: &quot;dbOwner&quot;, db: &quot;admin&quot; },\n       { role: &quot;userAdmin&quot;, db: &quot;admin&quot; },\n       { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; }\n    ]\n  }\n)\n\n/// mongodb还直接提供了一个超级管理员角色root,例如我们创建一个admin用户为超级管理员\nuse admin\ndb.createUser(\n  {\n    user: &quot;admin&quot;,\n    pwd: &quot;admin&quot;,\n    roles: [ { role: &quot;root&quot;,db:&quot;admin&quot; }]\n\n  }\n)\n</code></pre>\n<h4 id=\"切换用户\"><a href=\"#切换用户\" class=\"headerlink\" title=\"切换用户\"></a>切换用户</h4><pre><code class=\"sh\">&gt; db.auth(&quot;admin&quot;, &quot;admin&quot;)\n</code></pre>\n<h4 id=\"创建角色\"><a href=\"#创建角色\" class=\"headerlink\" title=\"创建角色\"></a>创建角色</h4><p>方法： <code>db.createRole()</code><br>需求：<br>  在数据库有createRole()权限<br>  需要有授予指定权限的权限</p>\n<p>一般来说，内建角色<code>userAdmin</code>与<code>userAdminAnyDatabase</code>满足以上要求</p>\n<p>语法：</p>\n<pre><code class=\"sh\">{\n  role: &quot;&lt;name&gt;&quot;,\n  privileges: [\n     { resource: { &lt;resource&gt; }, actions: [ &quot;&lt;action&gt;&quot;, ... ] },\n     ...\n  ],\n  roles: [\n     { role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot; } | &quot;&lt;role&gt;&quot;,\n      ...\n  ]\n}\n</code></pre>\n<p>role 是创建role的名字<br>resource是你想授权所对应的对象<br>actions是授权的动作<br>roles是把某个角色授权给此角色</p>\n<p>实例：</p>\n<pre><code class=\"sh\">use admin\ndb.createRole(\n   {\n     role: &quot;myClusterwideAdmin&quot;,\n     privileges: [\n       { resource: { cluster: true }, actions: [ &quot;addShard&quot; ] },\n       { resource: { db: &quot;config&quot;, collection: &quot;&quot; }, actions: [ &quot;find&quot;, &quot;update&quot;, &quot;insert&quot;, &quot;remove&quot; ] },\n       { resource: { db: &quot;users&quot;, collection: &quot;usersCollection&quot; }, actions: [ &quot;update&quot;, &quot;insert&quot;, &quot;remove&quot; ] },\n       { resource: { db: &quot;&quot;, collection: &quot;&quot; }, actions: [ &quot;find&quot; ] }\n     ],\n     roles: [\n       { role: &quot;read&quot;, db: &quot;admin&quot; }\n     ]\n   },\n   { w: &quot;majority&quot; , wtimeout: 5000 }\n)\n</code></pre>\n<h4 id=\"查看角色权限\"><a href=\"#查看角色权限\" class=\"headerlink\" title=\"查看角色权限\"></a>查看角色权限</h4><p>方法： <code>db.getRole()</code><br>查看所有非内建角色: <code>db.getRoles()</code></p>\n<h4 id=\"查看用户角色\"><a href=\"#查看用户角色\" class=\"headerlink\" title=\"查看用户角色\"></a>查看用户角色</h4><p>方法： <code>db.getUser()</code><br>查看所有用户: <code>db.getUsers()</code></p>\n<h4 id=\"授予-收回角色权限\"><a href=\"#授予-收回角色权限\" class=\"headerlink\" title=\"授予/收回角色权限\"></a>授予/收回角色权限</h4><p>收回: <code>db.revokePrivilegesFromRole()</code><br>授予: <code>db.grantPrivilegesToRole()</code></p>\n<h4 id=\"授予-收回用户角色\"><a href=\"#授予-收回用户角色\" class=\"headerlink\" title=\"授予/收回用户角色\"></a>授予/收回用户角色</h4><p>收回: <code>db.revokeRolesFromUser()</code><br>授予: <code>db.grantRolesToUser()</code></p>\n<h4 id=\"修改用户密码\"><a href=\"#修改用户密码\" class=\"headerlink\" title=\"修改用户密码\"></a>修改用户密码</h4><pre><code class=\"sh\">&gt; db.changeUserPassword(&quot;name&quot;, &quot;newpass&quot;)\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>安全认证…</p>","more":"<h3 id=\"mongodb安全认证\"><a href=\"#mongodb安全认证\" class=\"headerlink\" title=\"mongodb安全认证\"></a>mongodb安全认证</h3><p>MongoDB默认是不认证的，可以直接连上服务并对数据库进行操作。</p>\n<h4 id=\"创建一个管理员用户\"><a href=\"#创建一个管理员用户\" class=\"headerlink\" title=\"创建一个管理员用户\"></a>创建一个管理员用户</h4><p>在开启验证之前必须创建一个管理员用户,管理员用户拥有userAdminAnyDatabase角色.此角色拥有管理用户的权限,注意此角色并不是最大权限的角色.</p>\n<pre><code class=\"js\">&gt; use admin\n&gt; db.createUser(\n  {\n    user: &quot;admin&quot;,  \n    pwd: &quot;admin&quot;,  \n    roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ]  \n  }\n)\n// 此时查询集合, 有了users\n</code></pre>\n<pre><code class=\"shell\">&gt; show collections\nsystem.users\nsystem.version\n\n&gt; db.system.users.find();\n{ &quot;_id&quot; : &quot;admin.admin&quot;, &quot;user&quot; : &quot;admin&quot;, &quot;db&quot; : &quot;admin&quot;, &quot;credentials&quot; : { &quot;SCRAM-SHA-1&quot; : { &quot;iterationCount&quot; : 10000, &quot;salt&quot; : &quot;5ERebAcl9LdKTIL516jalw==&quot;, &quot;storedKey&quot; : &quot;bjKBgILU9djmwn8jibg4Uu54u9w=&quot;, &quot;serverKey&quot; : &quot;iSTR/nMXjCv5pljY1hIPPOumCLU=&quot; } }, &quot;roles&quot; : [ { &quot;role&quot; : &quot;userAdminAnyDatabase&quot;, &quot;db&quot; : &quot;admin&quot; } ] }\n&gt;  db.system.version.find();\n{ &quot;_id&quot; : &quot;authSchema&quot;, &quot;currentVersion&quot; : 5 }\n</code></pre>\n<h4 id=\"用管理员登录\"><a href=\"#用管理员登录\" class=\"headerlink\" title=\"用管理员登录\"></a>用管理员登录</h4><pre><code class=\"shell\">mongo  -u admin -p admin --authenticationDatabase admin\n</code></pre>\n<p>userAdminAnyDatabase拥有的权限</p>\n<pre><code>changeCustomData\nchangePassword\ncreateRole\ncreateUser\ndropRole\ndropUser\ngrantRole\nrevokeRole\nviewRole\nviewUser\n</code></pre><h4 id=\"超级管理员\"><a href=\"#超级管理员\" class=\"headerlink\" title=\"超级管理员\"></a>超级管理员</h4><p>拥有在任何数据库中分配任何用户全选的能力</p>\n<pre><code>1. dbOwner\n2. userAdmin\n3. userAdminAnyDayabase\n</code></pre><pre><code class=\"shell\">db.createUser(\n  {\n    user: &quot;suq&quot;,\n    pwd: &quot;suq&quot;,\n    roles: [\n       { role: &quot;dbOwner&quot;, db: &quot;admin&quot; },\n       { role: &quot;userAdmin&quot;, db: &quot;admin&quot; },\n       { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; }\n    ]\n  }\n)\n\n/// mongodb还直接提供了一个超级管理员角色root,例如我们创建一个admin用户为超级管理员\nuse admin\ndb.createUser(\n  {\n    user: &quot;admin&quot;,\n    pwd: &quot;admin&quot;,\n    roles: [ { role: &quot;root&quot;,db:&quot;admin&quot; }]\n\n  }\n)\n</code></pre>\n<h4 id=\"切换用户\"><a href=\"#切换用户\" class=\"headerlink\" title=\"切换用户\"></a>切换用户</h4><pre><code class=\"sh\">&gt; db.auth(&quot;admin&quot;, &quot;admin&quot;)\n</code></pre>\n<h4 id=\"创建角色\"><a href=\"#创建角色\" class=\"headerlink\" title=\"创建角色\"></a>创建角色</h4><p>方法： <code>db.createRole()</code><br>需求：<br>  在数据库有createRole()权限<br>  需要有授予指定权限的权限</p>\n<p>一般来说，内建角色<code>userAdmin</code>与<code>userAdminAnyDatabase</code>满足以上要求</p>\n<p>语法：</p>\n<pre><code class=\"sh\">{\n  role: &quot;&lt;name&gt;&quot;,\n  privileges: [\n     { resource: { &lt;resource&gt; }, actions: [ &quot;&lt;action&gt;&quot;, ... ] },\n     ...\n  ],\n  roles: [\n     { role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot; } | &quot;&lt;role&gt;&quot;,\n      ...\n  ]\n}\n</code></pre>\n<p>role 是创建role的名字<br>resource是你想授权所对应的对象<br>actions是授权的动作<br>roles是把某个角色授权给此角色</p>\n<p>实例：</p>\n<pre><code class=\"sh\">use admin\ndb.createRole(\n   {\n     role: &quot;myClusterwideAdmin&quot;,\n     privileges: [\n       { resource: { cluster: true }, actions: [ &quot;addShard&quot; ] },\n       { resource: { db: &quot;config&quot;, collection: &quot;&quot; }, actions: [ &quot;find&quot;, &quot;update&quot;, &quot;insert&quot;, &quot;remove&quot; ] },\n       { resource: { db: &quot;users&quot;, collection: &quot;usersCollection&quot; }, actions: [ &quot;update&quot;, &quot;insert&quot;, &quot;remove&quot; ] },\n       { resource: { db: &quot;&quot;, collection: &quot;&quot; }, actions: [ &quot;find&quot; ] }\n     ],\n     roles: [\n       { role: &quot;read&quot;, db: &quot;admin&quot; }\n     ]\n   },\n   { w: &quot;majority&quot; , wtimeout: 5000 }\n)\n</code></pre>\n<h4 id=\"查看角色权限\"><a href=\"#查看角色权限\" class=\"headerlink\" title=\"查看角色权限\"></a>查看角色权限</h4><p>方法： <code>db.getRole()</code><br>查看所有非内建角色: <code>db.getRoles()</code></p>\n<h4 id=\"查看用户角色\"><a href=\"#查看用户角色\" class=\"headerlink\" title=\"查看用户角色\"></a>查看用户角色</h4><p>方法： <code>db.getUser()</code><br>查看所有用户: <code>db.getUsers()</code></p>\n<h4 id=\"授予-收回角色权限\"><a href=\"#授予-收回角色权限\" class=\"headerlink\" title=\"授予/收回角色权限\"></a>授予/收回角色权限</h4><p>收回: <code>db.revokePrivilegesFromRole()</code><br>授予: <code>db.grantPrivilegesToRole()</code></p>\n<h4 id=\"授予-收回用户角色\"><a href=\"#授予-收回用户角色\" class=\"headerlink\" title=\"授予/收回用户角色\"></a>授予/收回用户角色</h4><p>收回: <code>db.revokeRolesFromUser()</code><br>授予: <code>db.grantRolesToUser()</code></p>\n<h4 id=\"修改用户密码\"><a href=\"#修改用户密码\" class=\"headerlink\" title=\"修改用户密码\"></a>修改用户密码</h4><pre><code class=\"sh\">&gt; db.changeUserPassword(&quot;name&quot;, &quot;newpass&quot;)\n</code></pre>"},{"title":"mongodb初探","date":"2017-01-24T03:56:04.000Z","_content":"初探mongodb\n\n<!--more-->\n\n# mongodb\n基于分布式文件储存的数据库，支持的数据结构非常松散，类似json的bson格式，可以储存比较复杂的数据类型。\n\n### 特点\n- 面向集合存储，易存储对象类型的数据\n- 支持动态查询\n- 支持完全索引，包含内部对象，对任何属性都可索引\n- 支持复制和故障恢复\n- 使用高效的二进制数据存储，包括大型对象（如视频等）\n- 自动处理碎片，以支持云计算层次的扩展性\n\n### 应用平台\n- 大数据\n- 内容管理和交付\n- 移动和社交基础设施\n- 用户数据管理\n- 数据平台\n\n### Mac下安装mongodb\n- [官网](https://www.mongodb.com) 下载最新版本，我使用的是3.4.1\n- 解压后放倒/usr/local/mongodb目录下\n\n```\ncp -r mongodb-osx-x86_64-3.4.1 /usr/local/mongodb  \n```\n- 在该目录下建立子目录data/db存放数据，log存放日志\n\n```\nsudo mkdir data/db\nsudo mkdir log\n```\n- 进入子目录bin创建配置文件\n\n```\ncd bin\nvim mongodb.conf \n    // 编写配置文件\nport=27017    // 数据库服务使用端口\ndbpath=/usr/local/mongodb/data/db  // 数据存放的文件位置\nlogpath=/usr/local/mongodb/log/mongodb.log    // 日志文件的存放位置\nfork = true    // 后台守护进程运行\n```\n- 启动\n第一个窗口\n```\n./mongod -f mongodb.conf  \n```\n第二个窗口\n```\n./mongo\n```\n\n","source":"_posts/mongodb初探.md","raw":"---\ntitle: mongodb初探\ndate: 2017-01-24 11:56:04\ntags:\n---\n初探mongodb\n\n<!--more-->\n\n# mongodb\n基于分布式文件储存的数据库，支持的数据结构非常松散，类似json的bson格式，可以储存比较复杂的数据类型。\n\n### 特点\n- 面向集合存储，易存储对象类型的数据\n- 支持动态查询\n- 支持完全索引，包含内部对象，对任何属性都可索引\n- 支持复制和故障恢复\n- 使用高效的二进制数据存储，包括大型对象（如视频等）\n- 自动处理碎片，以支持云计算层次的扩展性\n\n### 应用平台\n- 大数据\n- 内容管理和交付\n- 移动和社交基础设施\n- 用户数据管理\n- 数据平台\n\n### Mac下安装mongodb\n- [官网](https://www.mongodb.com) 下载最新版本，我使用的是3.4.1\n- 解压后放倒/usr/local/mongodb目录下\n\n```\ncp -r mongodb-osx-x86_64-3.4.1 /usr/local/mongodb  \n```\n- 在该目录下建立子目录data/db存放数据，log存放日志\n\n```\nsudo mkdir data/db\nsudo mkdir log\n```\n- 进入子目录bin创建配置文件\n\n```\ncd bin\nvim mongodb.conf \n    // 编写配置文件\nport=27017    // 数据库服务使用端口\ndbpath=/usr/local/mongodb/data/db  // 数据存放的文件位置\nlogpath=/usr/local/mongodb/log/mongodb.log    // 日志文件的存放位置\nfork = true    // 后台守护进程运行\n```\n- 启动\n第一个窗口\n```\n./mongod -f mongodb.conf  \n```\n第二个窗口\n```\n./mongo\n```\n\n","slug":"mongodb初探","published":1,"updated":"2017-01-24T16:03:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2j000ittwprip20y4i","content":"<p>初探mongodb</p>\n<a id=\"more\"></a>\n<h1 id=\"mongodb\"><a href=\"#mongodb\" class=\"headerlink\" title=\"mongodb\"></a>mongodb</h1><p>基于分布式文件储存的数据库，支持的数据结构非常松散，类似json的bson格式，可以储存比较复杂的数据类型。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>面向集合存储，易存储对象类型的数据</li>\n<li>支持动态查询</li>\n<li>支持完全索引，包含内部对象，对任何属性都可索引</li>\n<li>支持复制和故障恢复</li>\n<li>使用高效的二进制数据存储，包括大型对象（如视频等）</li>\n<li>自动处理碎片，以支持云计算层次的扩展性</li>\n</ul>\n<h3 id=\"应用平台\"><a href=\"#应用平台\" class=\"headerlink\" title=\"应用平台\"></a>应用平台</h3><ul>\n<li>大数据</li>\n<li>内容管理和交付</li>\n<li>移动和社交基础设施</li>\n<li>用户数据管理</li>\n<li>数据平台</li>\n</ul>\n<h3 id=\"Mac下安装mongodb\"><a href=\"#Mac下安装mongodb\" class=\"headerlink\" title=\"Mac下安装mongodb\"></a>Mac下安装mongodb</h3><ul>\n<li><a href=\"https://www.mongodb.com\" target=\"_blank\" rel=\"external\">官网</a> 下载最新版本，我使用的是3.4.1</li>\n<li>解压后放倒/usr/local/mongodb目录下</li>\n</ul>\n<pre><code>cp -r mongodb-osx-x86_64-3.4.1 /usr/local/mongodb\n</code></pre><ul>\n<li>在该目录下建立子目录data/db存放数据，log存放日志</li>\n</ul>\n<pre><code>sudo mkdir data/db\nsudo mkdir log\n</code></pre><ul>\n<li>进入子目录bin创建配置文件</li>\n</ul>\n<pre><code>cd bin\nvim mongodb.conf \n    // 编写配置文件\nport=27017    // 数据库服务使用端口\ndbpath=/usr/local/mongodb/data/db  // 数据存放的文件位置\nlogpath=/usr/local/mongodb/log/mongodb.log    // 日志文件的存放位置\nfork = true    // 后台守护进程运行\n</code></pre><ul>\n<li>启动<br>第一个窗口<pre><code>./mongod -f mongodb.conf\n</code></pre>第二个窗口<pre><code>./mongo\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>初探mongodb</p>","more":"<h1 id=\"mongodb\"><a href=\"#mongodb\" class=\"headerlink\" title=\"mongodb\"></a>mongodb</h1><p>基于分布式文件储存的数据库，支持的数据结构非常松散，类似json的bson格式，可以储存比较复杂的数据类型。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><ul>\n<li>面向集合存储，易存储对象类型的数据</li>\n<li>支持动态查询</li>\n<li>支持完全索引，包含内部对象，对任何属性都可索引</li>\n<li>支持复制和故障恢复</li>\n<li>使用高效的二进制数据存储，包括大型对象（如视频等）</li>\n<li>自动处理碎片，以支持云计算层次的扩展性</li>\n</ul>\n<h3 id=\"应用平台\"><a href=\"#应用平台\" class=\"headerlink\" title=\"应用平台\"></a>应用平台</h3><ul>\n<li>大数据</li>\n<li>内容管理和交付</li>\n<li>移动和社交基础设施</li>\n<li>用户数据管理</li>\n<li>数据平台</li>\n</ul>\n<h3 id=\"Mac下安装mongodb\"><a href=\"#Mac下安装mongodb\" class=\"headerlink\" title=\"Mac下安装mongodb\"></a>Mac下安装mongodb</h3><ul>\n<li><a href=\"https://www.mongodb.com\" target=\"_blank\" rel=\"external\">官网</a> 下载最新版本，我使用的是3.4.1</li>\n<li>解压后放倒/usr/local/mongodb目录下</li>\n</ul>\n<pre><code>cp -r mongodb-osx-x86_64-3.4.1 /usr/local/mongodb\n</code></pre><ul>\n<li>在该目录下建立子目录data/db存放数据，log存放日志</li>\n</ul>\n<pre><code>sudo mkdir data/db\nsudo mkdir log\n</code></pre><ul>\n<li>进入子目录bin创建配置文件</li>\n</ul>\n<pre><code>cd bin\nvim mongodb.conf \n    // 编写配置文件\nport=27017    // 数据库服务使用端口\ndbpath=/usr/local/mongodb/data/db  // 数据存放的文件位置\nlogpath=/usr/local/mongodb/log/mongodb.log    // 日志文件的存放位置\nfork = true    // 后台守护进程运行\n</code></pre><ul>\n<li>启动<br>第一个窗口<pre><code>./mongod -f mongodb.conf\n</code></pre>第二个窗口<pre><code>./mongo\n</code></pre></li>\n</ul>"},{"title":"css布局","date":"2017-01-25T13:58:24.000Z","_content":"开始复习复习\n\n<!--more-->\n\n#### css盒子模型\n原理：padding,border,margin三者构成一个盒子。\n\n![图片来自网络](https://sfault-image.b0.upaiyun.com/291/448/2914489531-57d7e11741de5_articlex)\n\nMargin(外边距) - 清除边框外的区域，外边距是透明的。\nBorder(边框) - 围绕在内边距和内容外的边框。\nPadding(内边距) - 清除内容周围的区域，内边距是透明的。\nContent(内容) - 盒子的内容，显示文本和图像。\n\n w3c标准：总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right\n\n IE标准：总宽度 = margin-left + width + margin-right\n\n#### css定位机制\n\n##### 普通流\n  - 元素的位置由元素在HTML文档中的位置决定，从左到右，自上而下。\n  \n  - 块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。\n  \n  - 行内框在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。\n  \n##### 定位\n- 相对定位（reletive）\n\t\n\t元素保持其形状及其所占空间，相对于普通流中其他元素的偏移。\n\n- 绝对定位（absloute）\n\n\t相对于已定位的祖先元素，如果没有已定位的祖先元素则相对于最初的包含块。\n\t脱离普通流，覆盖在普通流定位之上\n\t\n- 固定定位（fixed）\n\n\t相对于浏览器窗口的绝对定位\n\t\n##### 浮动\n- 不在普通流中占据空间，但会对之后的浮动元素产生空间占位影响\n\n\n\t\n#### 布局\n\n##### 常见布局\n\n- 单列水平居中布局, 一列定宽一列自适应布局, 两列定宽一列自适应布局, 两侧定宽中间自适应三列布局。\n\n- 圣杯与双飞翼是常见的三列布局，左右两列宽度固定，中列自适应。\n\n##### 圣杯布局\n\n- 为了给两边侧栏空出位置，给container元素设置padding\n\n- 左右两个div用相对定位并分配left，right属性，用负边距消除占位\n\n- main div设置100%宽度\n\n\n```html\n<div class=\"container\">\n\t<div class=\"main\"></div>\n\t<div class=\"left\"></div>\n\t<div class=\"right\"></div>\n</div>\n```\n\n```css\nbody {\n\tpadding: 0;\n\tmargin: 0;\n    min-width: 600px; /* 2*left + right */\n}\n.container {\n    padding-left: 200px;\n    padding-right: 200px;\n}\n.main {\n    float: left;\n    width: 100%;\n    height: 300px;\n    background-color: red;\n}\n.left {\n    position: relative;\n    left: -200px;\n    float: left;\n    width: 190px;\n    height: 300px;\n    margin-left: -100%;\n    background-color: blue;\n}\n.right {\n    position: relative;\n    right: -210px;\n    float: left;\n    width: 190px;\n    height: 300px;\n    margin-left: -200px;\n    background-color: green;\n}\n```\n\n##### 双飞翼布局\n\n- 三列左浮动\n- 为了不让main内容被遮挡，给其设置padding\n- 用负边距给左右两列定位，消除占位\n\n```html\n<div class=\"main-con\">\n\t<div class=\"main\"></div>\n</div>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n```\n\n```css\n.main-con {\n\tfloat: left;\n\twidth: 100%;\n}\n\n.main {\n\theight: 300px;\n\tmargin-left: 210px;\n\tmargin-right: 210px;\n\tbackground-color: red;\n}\n\n.left {\n\tfloat: left;\n\twidth: 200px;\n\theight: 300px;\n\tmargin-left: -100%;\n\tbackground-color: blue;\n}\n\n.right {\n\tfloat: left;\n\twidth: 200px;\n\theight: 300px;\n\tmargin-left: -200px;\n\tbackground-color: green;\n}\n```\n\n##### 两者异同\n\n- 两者都把主栏放在文档流最前面，优先加载。\n \n- 两者都是三列浮动，然后通过负边距定位消除占位形成三列布局\n\n- 中列main处理不同：圣杯布局是利用父容器的左、右内边距定位；双飞翼布局是把主栏嵌套在div后利用主列的左、右外边距定位。","source":"_posts/css布局.md","raw":"---\ntitle: css布局\ndate: 2017-01-25 21:58:24\ntags:\n---\n开始复习复习\n\n<!--more-->\n\n#### css盒子模型\n原理：padding,border,margin三者构成一个盒子。\n\n![图片来自网络](https://sfault-image.b0.upaiyun.com/291/448/2914489531-57d7e11741de5_articlex)\n\nMargin(外边距) - 清除边框外的区域，外边距是透明的。\nBorder(边框) - 围绕在内边距和内容外的边框。\nPadding(内边距) - 清除内容周围的区域，内边距是透明的。\nContent(内容) - 盒子的内容，显示文本和图像。\n\n w3c标准：总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right\n\n IE标准：总宽度 = margin-left + width + margin-right\n\n#### css定位机制\n\n##### 普通流\n  - 元素的位置由元素在HTML文档中的位置决定，从左到右，自上而下。\n  \n  - 块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。\n  \n  - 行内框在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。\n  \n##### 定位\n- 相对定位（reletive）\n\t\n\t元素保持其形状及其所占空间，相对于普通流中其他元素的偏移。\n\n- 绝对定位（absloute）\n\n\t相对于已定位的祖先元素，如果没有已定位的祖先元素则相对于最初的包含块。\n\t脱离普通流，覆盖在普通流定位之上\n\t\n- 固定定位（fixed）\n\n\t相对于浏览器窗口的绝对定位\n\t\n##### 浮动\n- 不在普通流中占据空间，但会对之后的浮动元素产生空间占位影响\n\n\n\t\n#### 布局\n\n##### 常见布局\n\n- 单列水平居中布局, 一列定宽一列自适应布局, 两列定宽一列自适应布局, 两侧定宽中间自适应三列布局。\n\n- 圣杯与双飞翼是常见的三列布局，左右两列宽度固定，中列自适应。\n\n##### 圣杯布局\n\n- 为了给两边侧栏空出位置，给container元素设置padding\n\n- 左右两个div用相对定位并分配left，right属性，用负边距消除占位\n\n- main div设置100%宽度\n\n\n```html\n<div class=\"container\">\n\t<div class=\"main\"></div>\n\t<div class=\"left\"></div>\n\t<div class=\"right\"></div>\n</div>\n```\n\n```css\nbody {\n\tpadding: 0;\n\tmargin: 0;\n    min-width: 600px; /* 2*left + right */\n}\n.container {\n    padding-left: 200px;\n    padding-right: 200px;\n}\n.main {\n    float: left;\n    width: 100%;\n    height: 300px;\n    background-color: red;\n}\n.left {\n    position: relative;\n    left: -200px;\n    float: left;\n    width: 190px;\n    height: 300px;\n    margin-left: -100%;\n    background-color: blue;\n}\n.right {\n    position: relative;\n    right: -210px;\n    float: left;\n    width: 190px;\n    height: 300px;\n    margin-left: -200px;\n    background-color: green;\n}\n```\n\n##### 双飞翼布局\n\n- 三列左浮动\n- 为了不让main内容被遮挡，给其设置padding\n- 用负边距给左右两列定位，消除占位\n\n```html\n<div class=\"main-con\">\n\t<div class=\"main\"></div>\n</div>\n<div class=\"left\"></div>\n<div class=\"right\"></div>\n```\n\n```css\n.main-con {\n\tfloat: left;\n\twidth: 100%;\n}\n\n.main {\n\theight: 300px;\n\tmargin-left: 210px;\n\tmargin-right: 210px;\n\tbackground-color: red;\n}\n\n.left {\n\tfloat: left;\n\twidth: 200px;\n\theight: 300px;\n\tmargin-left: -100%;\n\tbackground-color: blue;\n}\n\n.right {\n\tfloat: left;\n\twidth: 200px;\n\theight: 300px;\n\tmargin-left: -200px;\n\tbackground-color: green;\n}\n```\n\n##### 两者异同\n\n- 两者都把主栏放在文档流最前面，优先加载。\n \n- 两者都是三列浮动，然后通过负边距定位消除占位形成三列布局\n\n- 中列main处理不同：圣杯布局是利用父容器的左、右内边距定位；双飞翼布局是把主栏嵌套在div后利用主列的左、右外边距定位。","slug":"css布局","published":1,"updated":"2017-10-15T02:52:28.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2n000jttwplcj9rlto","content":"<p>开始复习复习</p>\n<a id=\"more\"></a>\n<h4 id=\"css盒子模型\"><a href=\"#css盒子模型\" class=\"headerlink\" title=\"css盒子模型\"></a>css盒子模型</h4><p>原理：padding,border,margin三者构成一个盒子。</p>\n<p><img src=\"https://sfault-image.b0.upaiyun.com/291/448/2914489531-57d7e11741de5_articlex\" alt=\"图片来自网络\"></p>\n<p>Margin(外边距) - 清除边框外的区域，外边距是透明的。<br>Border(边框) - 围绕在内边距和内容外的边框。<br>Padding(内边距) - 清除内容周围的区域，内边距是透明的。<br>Content(内容) - 盒子的内容，显示文本和图像。</p>\n<p> w3c标准：总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</p>\n<p> IE标准：总宽度 = margin-left + width + margin-right</p>\n<h4 id=\"css定位机制\"><a href=\"#css定位机制\" class=\"headerlink\" title=\"css定位机制\"></a>css定位机制</h4><h5 id=\"普通流\"><a href=\"#普通流\" class=\"headerlink\" title=\"普通流\"></a>普通流</h5><ul>\n<li><p>元素的位置由元素在HTML文档中的位置决定，从左到右，自上而下。</p>\n</li>\n<li><p>块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。</p>\n</li>\n<li><p>行内框在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。</p>\n</li>\n</ul>\n<h5 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h5><ul>\n<li><p>相对定位（reletive）</p>\n<p>  元素保持其形状及其所占空间，相对于普通流中其他元素的偏移。</p>\n</li>\n<li><p>绝对定位（absloute）</p>\n<p>  相对于已定位的祖先元素，如果没有已定位的祖先元素则相对于最初的包含块。<br>  脱离普通流，覆盖在普通流定位之上</p>\n</li>\n<li><p>固定定位（fixed）</p>\n<p>  相对于浏览器窗口的绝对定位</p>\n</li>\n</ul>\n<h5 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h5><ul>\n<li>不在普通流中占据空间，但会对之后的浮动元素产生空间占位影响</li>\n</ul>\n<h4 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h4><h5 id=\"常见布局\"><a href=\"#常见布局\" class=\"headerlink\" title=\"常见布局\"></a>常见布局</h5><ul>\n<li><p>单列水平居中布局, 一列定宽一列自适应布局, 两列定宽一列自适应布局, 两侧定宽中间自适应三列布局。</p>\n</li>\n<li><p>圣杯与双飞翼是常见的三列布局，左右两列宽度固定，中列自适应。</p>\n</li>\n</ul>\n<h5 id=\"圣杯布局\"><a href=\"#圣杯布局\" class=\"headerlink\" title=\"圣杯布局\"></a>圣杯布局</h5><ul>\n<li><p>为了给两边侧栏空出位置，给container元素设置padding</p>\n</li>\n<li><p>左右两个div用相对定位并分配left，right属性，用负边距消除占位</p>\n</li>\n<li><p>main div设置100%宽度</p>\n</li>\n</ul>\n<pre><code class=\"html\">&lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class=\"css\">body {\n    padding: 0;\n    margin: 0;\n    min-width: 600px; /* 2*left + right */\n}\n.container {\n    padding-left: 200px;\n    padding-right: 200px;\n}\n.main {\n    float: left;\n    width: 100%;\n    height: 300px;\n    background-color: red;\n}\n.left {\n    position: relative;\n    left: -200px;\n    float: left;\n    width: 190px;\n    height: 300px;\n    margin-left: -100%;\n    background-color: blue;\n}\n.right {\n    position: relative;\n    right: -210px;\n    float: left;\n    width: 190px;\n    height: 300px;\n    margin-left: -200px;\n    background-color: green;\n}\n</code></pre>\n<h5 id=\"双飞翼布局\"><a href=\"#双飞翼布局\" class=\"headerlink\" title=\"双飞翼布局\"></a>双飞翼布局</h5><ul>\n<li>三列左浮动</li>\n<li>为了不让main内容被遮挡，给其设置padding</li>\n<li>用负边距给左右两列定位，消除占位</li>\n</ul>\n<pre><code class=\"html\">&lt;div class=&quot;main-con&quot;&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\n&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class=\"css\">.main-con {\n    float: left;\n    width: 100%;\n}\n\n.main {\n    height: 300px;\n    margin-left: 210px;\n    margin-right: 210px;\n    background-color: red;\n}\n\n.left {\n    float: left;\n    width: 200px;\n    height: 300px;\n    margin-left: -100%;\n    background-color: blue;\n}\n\n.right {\n    float: left;\n    width: 200px;\n    height: 300px;\n    margin-left: -200px;\n    background-color: green;\n}\n</code></pre>\n<h5 id=\"两者异同\"><a href=\"#两者异同\" class=\"headerlink\" title=\"两者异同\"></a>两者异同</h5><ul>\n<li><p>两者都把主栏放在文档流最前面，优先加载。</p>\n</li>\n<li><p>两者都是三列浮动，然后通过负边距定位消除占位形成三列布局</p>\n</li>\n<li><p>中列main处理不同：圣杯布局是利用父容器的左、右内边距定位；双飞翼布局是把主栏嵌套在div后利用主列的左、右外边距定位。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>开始复习复习</p>","more":"<h4 id=\"css盒子模型\"><a href=\"#css盒子模型\" class=\"headerlink\" title=\"css盒子模型\"></a>css盒子模型</h4><p>原理：padding,border,margin三者构成一个盒子。</p>\n<p><img src=\"https://sfault-image.b0.upaiyun.com/291/448/2914489531-57d7e11741de5_articlex\" alt=\"图片来自网络\"></p>\n<p>Margin(外边距) - 清除边框外的区域，外边距是透明的。<br>Border(边框) - 围绕在内边距和内容外的边框。<br>Padding(内边距) - 清除内容周围的区域，内边距是透明的。<br>Content(内容) - 盒子的内容，显示文本和图像。</p>\n<p> w3c标准：总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</p>\n<p> IE标准：总宽度 = margin-left + width + margin-right</p>\n<h4 id=\"css定位机制\"><a href=\"#css定位机制\" class=\"headerlink\" title=\"css定位机制\"></a>css定位机制</h4><h5 id=\"普通流\"><a href=\"#普通流\" class=\"headerlink\" title=\"普通流\"></a>普通流</h5><ul>\n<li><p>元素的位置由元素在HTML文档中的位置决定，从左到右，自上而下。</p>\n</li>\n<li><p>块级框从上到下一个接一个地排列，框之间的垂直距离是由框的垂直外边距计算出来。</p>\n</li>\n<li><p>行内框在一行中水平布置。可以使用水平内边距、边框和外边距调整它们的间距。但是，垂直内边距、边框和外边距不影响行内框的高度。由一行形成的水平框称为行框（Line Box），行框的高度总是足以容纳它包含的所有行内框。不过，设置行高可以增加这个框的高度。</p>\n</li>\n</ul>\n<h5 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h5><ul>\n<li><p>相对定位（reletive）</p>\n<p>  元素保持其形状及其所占空间，相对于普通流中其他元素的偏移。</p>\n</li>\n<li><p>绝对定位（absloute）</p>\n<p>  相对于已定位的祖先元素，如果没有已定位的祖先元素则相对于最初的包含块。<br>  脱离普通流，覆盖在普通流定位之上</p>\n</li>\n<li><p>固定定位（fixed）</p>\n<p>  相对于浏览器窗口的绝对定位</p>\n</li>\n</ul>\n<h5 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h5><ul>\n<li>不在普通流中占据空间，但会对之后的浮动元素产生空间占位影响</li>\n</ul>\n<h4 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h4><h5 id=\"常见布局\"><a href=\"#常见布局\" class=\"headerlink\" title=\"常见布局\"></a>常见布局</h5><ul>\n<li><p>单列水平居中布局, 一列定宽一列自适应布局, 两列定宽一列自适应布局, 两侧定宽中间自适应三列布局。</p>\n</li>\n<li><p>圣杯与双飞翼是常见的三列布局，左右两列宽度固定，中列自适应。</p>\n</li>\n</ul>\n<h5 id=\"圣杯布局\"><a href=\"#圣杯布局\" class=\"headerlink\" title=\"圣杯布局\"></a>圣杯布局</h5><ul>\n<li><p>为了给两边侧栏空出位置，给container元素设置padding</p>\n</li>\n<li><p>左右两个div用相对定位并分配left，right属性，用负边距消除占位</p>\n</li>\n<li><p>main div设置100%宽度</p>\n</li>\n</ul>\n<pre><code class=\"html\">&lt;div class=&quot;container&quot;&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<pre><code class=\"css\">body {\n    padding: 0;\n    margin: 0;\n    min-width: 600px; /* 2*left + right */\n}\n.container {\n    padding-left: 200px;\n    padding-right: 200px;\n}\n.main {\n    float: left;\n    width: 100%;\n    height: 300px;\n    background-color: red;\n}\n.left {\n    position: relative;\n    left: -200px;\n    float: left;\n    width: 190px;\n    height: 300px;\n    margin-left: -100%;\n    background-color: blue;\n}\n.right {\n    position: relative;\n    right: -210px;\n    float: left;\n    width: 190px;\n    height: 300px;\n    margin-left: -200px;\n    background-color: green;\n}\n</code></pre>\n<h5 id=\"双飞翼布局\"><a href=\"#双飞翼布局\" class=\"headerlink\" title=\"双飞翼布局\"></a>双飞翼布局</h5><ul>\n<li>三列左浮动</li>\n<li>为了不让main内容被遮挡，给其设置padding</li>\n<li>用负边距给左右两列定位，消除占位</li>\n</ul>\n<pre><code class=\"html\">&lt;div class=&quot;main-con&quot;&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;\n&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class=\"css\">.main-con {\n    float: left;\n    width: 100%;\n}\n\n.main {\n    height: 300px;\n    margin-left: 210px;\n    margin-right: 210px;\n    background-color: red;\n}\n\n.left {\n    float: left;\n    width: 200px;\n    height: 300px;\n    margin-left: -100%;\n    background-color: blue;\n}\n\n.right {\n    float: left;\n    width: 200px;\n    height: 300px;\n    margin-left: -200px;\n    background-color: green;\n}\n</code></pre>\n<h5 id=\"两者异同\"><a href=\"#两者异同\" class=\"headerlink\" title=\"两者异同\"></a>两者异同</h5><ul>\n<li><p>两者都把主栏放在文档流最前面，优先加载。</p>\n</li>\n<li><p>两者都是三列浮动，然后通过负边距定位消除占位形成三列布局</p>\n</li>\n<li><p>中列main处理不同：圣杯布局是利用父容器的左、右内边距定位；双飞翼布局是把主栏嵌套在div后利用主列的左、右外边距定位。</p>\n</li>\n</ul>"},{"title":"Angular4入门","date":"2017-08-02T02:49:44.000Z","_content":"## Angular4入门\n\n### Angular-cli\n\n#### 全局安装\n```shell\nsudo npm install @angular/cli -g\n\nng generate --help  // 查询帮助\n```\n#### 创建项目\n```sh\nng new <ProjectName>\n```\n相关配置\n```sh\n--dry-run           // boolean, 默认为 false, 若设置 dry-run 则不会创建任何文件\n--verbose           // boolean, 默认为 false\n--link-cli          // boolean, 默认为 false, 自动链接到 @angular/cli 包\n--skip-install      // boolean, 默认为 false, 表示跳过 npm install\n--skip-git          // boolean, 默认为 false, 表示该目录不初始化为 git 仓库\n--skip-tests        // boolean, 默认为 false, 表示不创建 tests 相关文件\n--skip-commit       // boolean, 默认为 false, 表示不进行初始提交\n--directory         // string, 用于设置创建的目录名，默认与应用程序的同名\n--source-dir        // string, 默认为 'src', 用于设置源文件目录的名称\n--style             // string, 默认为 'css', 用于设置选用的样式语法 ('css', 'less' or 'scss')\n--prefix            // string, 默认为 'app', 用于设置创建新组件时，组件选择器使用的前缀\n--mobile            // boolean, 默认为 false,表示是否生成 Progressive Web App 应用程序\n--routing           // boolean, 默认为 false, 表示新增带有路由信息的模块，并添加到根模块中\n--inline-style      // boolean, 默认为 false, 表示当创建新的应用程序时，使用内联样式\n--inline-template   // boolean, 默认为 false, 表示当创建新的应用程序时，使用内联模板\n```\n\n#### 启动项目\n```sh\ncd <ProjectName>\nnpm start -o\nng serve  --open   // 主动打开浏览器窗口\n```\n\n```sh\nng g cl <Name> --spec            // 新建 class\nng g c  <Name>                   // 新建组件\nng g d  <Name>                   // 新建指令\nng g e  <Name>                   // 新建枚举\nng g m  <Name> --routing --spec  // 新建模块\nng g p  <Name> --flat=false      // 新建管道\nng g s  <Name> --flat=false       // 新建服务\n```\n\n#### 单元测试\n```sh\nng test\nnpm test\n```\n\n#### e2e测试\n```sh\nng e2e\n```\n\n#### 构建压缩代码并实施监控变化的应用程序\n```sh\nng build --target=production --watch\n```\n\n#### 自定义构建webpack\n```sh\nng eject\n```\n\n### 实际开发\n\n#### 事件绑定\n\n```html\n<!--xun-com.component.html  -->\n<span>{{title}}</span>\n<!--dom绑定  -->\n<input #myInput type=\"text\">\n<!--鼠标事件  -->\n<button (click)=\"onClick($event, myInput.value)\">鼠标点击事件</button>\n<!--键盘事件  -->\n<input #keyBoard type=\"text\" (keydown.enter)=\"onEnter($event, keyBoard.value)\">\n```\n\n```ts\n<!--xun-com.component.ts  -->\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-xun-com',\n  templateUrl: './xun-com.component.html',\n  styleUrls: ['./xun-com.component.css']\n})\nexport class XunComComponent implements OnInit {\n  title: string;\n  constructor() {\n    this.title = 'title'\n  }\n\n  ngOnInit() {\n  }\n  // 事件方法\n  onClick(event, val) {\n    console.log(event)\n    console.log(val)\n  }\n  onEnter(event, val) {\n    console.log(event)\n    console.log(val)\n  }\n\n}\n```\n\n#### 新建服务\n\n```sh\nng g s mail\n\n// 输出\ninstalling service\n  create src/app/mail.service.spec.ts     // 用于单元测试\n  create src/app/mail.service.ts          // 新建的服务\n  WARNING Service is generated but not provided, it must be provided to be used\n```\n\n#### 配置服务\n```ts\nimport { MailService } from './mail.service';\n\n@NgModule({\n\n  providers: [\n    MailService,\n    {provide: 'apiUrl', useValue: 'https://jsonplaceholder.typicode.com/'}\n  ],     // 注入服务  \n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n#### 更新服务\n```ts\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class MailService {\n  message: string  ='该消息来自MailService';\n  constructor() { }\n}\n```\n\n#### 使用服务\n```ts\n<!--xun-com.component.ts  -->\nimport { MailService } from '../mail.service';\n...\nexport class AppComponent {\n\n  constructor(private mailService: MailService) {}\n  constructor(\n    @Inject(MailService) private mailService,\n    @Inject('apiUrl') private apiUrl) {}\n  <!--二选其一  -->\n  <!-- 不过对于 Type 类型(函数类型) 的对象，我们一般使用 constructor(private mailService: MailService) 方式进行注入。而 Inject 装饰器一般用来注入非 Type 类型的对象。 -->\n}\n```\n```html\n<!--xun-com.component.html  -->\n<p>{{mailService.message}}</p>\n```\n\n#### ngClass\n```html\n<div [ngClass]=\"{mousedown: isMousedown}\"></div>\n```\n\n#### ngStyle\n```html\n<!--font-size支持px % em  -->\n<div>\n   <span [ngStyle]=\"{color: 'red'}\" [style.font-size.px]=\"fontSize\" [style.background-color=\"'red'\"]>\n      Red Text\n   </span>\n</div>\n```\n\n#### ngModel\n- 单独使用ngModel\n需要给表单元素添加`name`，为`ngForm.value`对象添加`property`\n```html\n<input type='text' name='userName' placeholder='Input your userName' ngModel>\n```\n- 单向绑定[ngModel]\n将this.name 初始化绑定到`ngForm.value`上\n```html\n<input type='text' name='userName' placeholder='Input your userName' [ngModel]=\"name\" />\n```\n\n- 双向绑定[(ngModel)]\n```ts\n<!--module中  -->\nimport {FormsModule} from '@angular/forms';\n...\nimports: [\n    ...\n    FormsModule\n  ],\n<!--组件中  -->\nthis.inputValue = 'inputvalue'\n<!--模板中  -->\n<input #myInput type=\"text\" [(ngModel)]=\"inputValue\">\n```\n\n#### @Input\n相当于props 父组件==>子组件\n```ts\n<!--子组件 xun-com.component  -->\nimport { ..., Input } from '@angular/core';\n...\nexport class XunComComponent implements OnInit {\n\n  @Input() msg: string;\n}\n\n<!--父组件 app.component  -->\nexport class AppComponent {\n  msg = {\n    data: '数据'\n  };\n}\n```\n\n```html\n<!--父模板 app.component  -->\n<app-xun-com [msg]=\"msg\"></app-xun-com>\n\n<!--子模板 xun-com.component -->\n<span>msg: {{msg.data}}</span>\n```\n\n#### @Output\nOutput装饰器:  让子组件将信息通过事件的方式返回给父组件\n```ts\n<!--子组件  -->\nimport {Output, EventEmitter } from '@angular/core';\nexport class XunComComponent implements OnInit {\n  @Input() msg: string;\n  @Output() update = new EventEmitter<{title: string}>();\n  constructor() {\n    this.title = 'xun-com'\n    }\n}\n<!--子组件模板  -->\n<button (click)=\"update.emit(title)\">更新</button>\n\n<!--父组件  -->\nexport class AppComponent {\n  constructor() {}\n  onUpdate(title) {\n    console.log(title)\n  }\n}\n<!--父组件模板  -->\n<app-xun-com (update)=\"onUpdate(title)\"></app-xun-com>\n```\n\n#### http模块\n```ts\n<!--导入模块 app.module.ts  -->\n...\nimport { HttpModule } from '@angular/http';\n...\n@NgModule({\n  imports: [BrowserModule, FormsModule, HttpModule],\n  declarations: [AppComponent, UserComponent],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n<!--调用模块  -->\nimport { Http } from '@angular/http';\nimport 'rxjs/add/operator/map';\n...\nexport class MembersComponent implements OnInit {\n  members: Member[];\n\n  constructor(private http: Http) { } // (3)\n\n  ngOnInit() {\n    this.http.get(`api`) // (4)\n        .map(res => res.json()) // (5)\n        .subscribe(data => {\n           if (data) this.members = data; // (6)\n        });\n    }\n}\n```\n\n#### 路由\n- `RouterModule.forRoot()`: 在主模块中定义主要的路由信息\n- `RouterModule.forChild()`: 在子模块中定义路由信息\n- `<router-outlet></router-outlet>`: 路由视图入口位置\n- 动态路由\n```ts\n// 配置文件\n  { path: '/profile/:username', component: ProfileComponent }\n// 组件中\nimport { ActivatedRoute } from '@angular/router';\n...\nexport class SettingsComponent implements OnInit {\n  username: string;\n  constructor(private route: ActivatedRoute) {}\n  ngOnInit() {\n    this.route.params.subscribe((params) => this.username = params.username);\n  }\n}\n```\n- 子路由 children\n- loadChildren 从另一个模块中获取子路由\n\n```ts\n// 子模块\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Routes, RouterModule } from '@angular/router';\n\nexport const ROUTES: Routes = [\n  {\n    path: '',\n    component: SettingsComponent,\n    children: [\n      { path: 'profile', component: ProfileSettingsComponent },\n      { path: 'password', component: PasswordSettingsComponent }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    CommonModule,\n    RouterModule.forChild(ROUTES)\n  ],\n})\nexport class SettingsModule {}\n\n// 父模块\nexport const ROUTES: Routes = [\n  {\n    path: 'settings',\n    loadChildren: './settings/settings.module#SettingsModule'\n  }\n];\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n  // ...\n})\nexport class AppModule {}\n\n```\n\n- Router Directives\n  `routerLink`: 跳转指令\n  ```html\n  <a routerLink=\"/\">Home</a>\n  ```\n- 路由跳转\n  ```ts\n  this.router.navigate(['/profile', event.name]);\n  ```\n\n### NgModule\n@NgModule接收一个用来描述模块属性的元数据对象\n\n- `declarations`:  声明本模块中的视图类\n- `exports`: declarations 的子集，可用于其它模块的组件模板\n- `imports`: 注册其他模块\n- `providers`: 添加全局服务\n- `bootstrap`: 根组件\n\n\n### Directive\n- `Component directive`: 构建UI组件，继承于Directive类\n- `Attribute directive`: 改变组件的外观或行为\n- `Structural directive`: 动态添加或删除DOM元素来改变DOM布局\n\n#### 自定义指令\n- `HostBinding`: 实现元素属性绑定\n- `Input`: 实现自定义元素属性输入\n- `HostListener`: 监听元素的事件\n- `Attribute`: 获取指令宿主元素上的自定义属性\n\n#### ngFor: 使用可迭代的每个项作为模板的上下文来重复模板\n首先更新mail服务，增加数组\n```ts\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class MailService {\n  message: string = '该消息来自MailService';\n  messages: string[] = [\n    '天之骄子，加入修仙之路群',\n    'Shadows，加入修仙之路群',\n    'Keriy，加入修仙之路群'\n  ]\n  constructor() { }\n}\n```\n更新组件模板\n```html\n<ul>\n  <li *ngFor=\"let message of mailService.messages; index as i;\">\n    {{i}} - {{message}}\n  </li>\n</ul>\n```\n\n#### ngIf: 根据表达式的值，显示或移除元素\n```html\n<div *ngIf=\"SHOW\">show</div>\n```\n#### ngSwitch\n```html\n<ul [ngSwitch]='person.country'>\n  <li *ngSwitchCase=\"'UK'\" class='text-success'>\n      {{ person.name }} ({{person.country}})\n  </li>\n   <li *ngSwitchCase=\"'USA'\" class='text-secondary'>\n      {{ person.name }} ({{person.country}})\n  </li>\n  <li *ngSwitchDefault class='text-primary'>\n    {{ person.name }} ({{person.country}})\n  </li>\n</ul>\n```\n\n\n\n### Template Driven Forms\n#### 创建表单\nng内嵌`validators`模块\n使用`userName.valid`判断验证，`userName.errors`输出错误信息\n```ts\n<!--html模板  -->\n<input\n  type=\"text\"\n  required\n  minlength=\"3\"\n  [(ngModel)]=\"username\"\n  #userName=\"ngModel\">\n  {{userName.valid}}\n<div *ngIf=\"userName.errors?.required\">请您输入用户名</div>\n<div *ngIf=\"userName.errors?.minlength\">\n  用户名的长度必须大于 {{userName.errors?.minlength.requiredLength}}，当前的长度为\n    {{userName.errors?.minlength.actualLength}}\n</div>\n\n<!--ts模块  -->\nexport class AppComponent {\n  username = 'semlinker';\n}\n```\n\n\n#### 表单提交\n通过 `#loginForm=\"ngForm\"` 方式获取 `ngForm` 对象，然后通过 `loginForm.value` 来获取表单的值\n<!--html模板  -->\n```html\n<form #loginForm=\"ngForm\" (ngSubmit)=\"onSubmit(loginForm.value)\">\n...\n<button type=\"submit\">提交</button>\n</form>\n```\n<!--绑定方法  -->\n```ts\nonSubmit(value) {\n    console.dir(value);\n  }\n```\n通过`ngModelGroup`指令对表单元素进行细化\n```html\n<form #loginForm=\"ngForm\" (ngSubmit)=\"onSubmit(loginForm.value)\">\n   <fieldset ngModelGroup=\"user\">\n    <input\n     type=\"text\"\n     required\n     minlength=\"3\"\n     name=\"username\"\n     [(ngModel)]=\"username\"\n     #userName=\"ngModel\">\n    <hr>\n    <div *ngIf=\"userName.errors?.required\">请您输入用户名</div>\n    <div *ngIf=\"userName.errors?.minlength\">\n      用户名的长度必须大于 {{userName.errors?.minlength.requiredLength}}，当前的长度为\n        {{userName.errors?.minlength.actualLength}}\n    </div>\n    <input type=\"password\" ngModel name=\"password\">\n   </fieldset>\n    <button type=\"submit\">提交</button>\n    <hr>\n    {{loginForm.value | json}}\n  </form>\n```\n\n#### 验证状态样式\n可以通过 `#userName=\"ngModel\"` 方式获取 `ngModel` 对象，进而通过`userName.dirty`获取控件的状态信息\ncss类\n```css\n.input.ng-invalid {\n  border: 3px solid red;\n}\ninput.ng-valid {\n  border: 3px solid green;\n}\n```\n状态列表\n- `valid`: 表单控件有效\n- `invalid`: 表单控件无效\n- `pristine`: 表单控件值未改变\n- `dirty`: 表单控件值已改变\n- `touched`: 表单控件已被访问过\n- `untouched`: 表单控件未被访问过\n\n#### 单选多选\n```html\n<div *ngFor=\"let version of versions;\">\n  <input\n    [attr.id]=\"version\"\n      name=\"version\"\n\n      required\n      [value]=\"version\"\n      type=\"radio\">\n    <label [attr.for]=\"version\">{{version}}</label>\n</div>\n```\n#### 特点\n- 使用方便，适用于简单环境\n- 通过[(ngModel)]实现数据的双向绑定\n- 最小化组件类的代码\n- 不易于单元测试\n\n### Reactive Form\n`FormControl`: 一个为单个表单控件提供支持的类，可用于跟踪控件的值和验证状态.\n```ts\nngOnInit() {\n  this.myControl = new FormControl('Semlinker');\n}\n```\n\n`FormGroup`: 包含一组 FormControl 实例，可用于跟踪 FormControl 组的值和验证状态.\n<!--组件ts  -->\n```ts\nexport class XunCsComponent implements OnInit {\n\nconstructor() {}\n  // tslint:disable-next-line:member-ordering\n  user: FormGroup;\n  ngOnInit() {\n    this.user = new FormGroup({\n      name: new FormControl(''),\n      account: new FormGroup({\n        email: new FormControl(''),\n        confirm: new FormControl('')\n      })\n    });\n  }\n  onSubmit() {\n    console.log(this.user.value, this.user.valid);\n  }\n}\n```\n<!--组件模板  -->\n```html\n  <form novalidate [formGroup]=\"user\"  (ngSubmit)=\"onSubmit(user)\" >\n  <label>\n    <span>Full name</span>\n    <input\n      type=\"text\"\n      placeholder=\"Your full name\"\n      formControlName=\"name\">\n  </label>\n  <div formGroupName=\"account\">\n    <label>\n      <span>Email address</span>\n      <input\n        type=\"email\"\n        placeholder=\"Your email address\"\n        formControlName=\"email\">\n    </label>\n    <label>\n      <span>Confirm address</span>\n      <input\n        type=\"email\"\n        placeholder=\"Confirm your email address\"\n        formControlName=\"confirm\">\n    </label>\n  </div>\n  <button type=\"submit\">Sign up</button>\n</form>\n```\n\n#### 表单验证\n通过`user.invalid`判断表单验证是否正确\n通过`user.controls.name?.errors`获取错误原因\n```ts\nthis.user = new FormGroup({\n  name: new FormControl('', [Validators.required, Validators.minLength(2)]),\n  account: new FormGroup({\n    email: new FormControl('', Validators.required),\n    confirm: new FormControl('', Validators.required)\n  })\n});\n```\n\n#### FormBuilder\n用来简化`FormGroup`+`FormControl`结合\n```ts\nngOnInit() {\n  this.user = this.fb.group({\n    name: ['', [Validators.required, Validators.minLength(2)]],\n    account: this.fb.group({\n      email: ['', Validators.required],\n      confirm: ['', Validators.required]\n    })\n  });\n}\n```\n\n#### 特点\n- 灵活，适用于复杂场景\n- 简化html模板代码，将验证逻辑抽离到组件类中\n- 方便跟踪表单控件值变化\n- 易于单元测试\n\n### 动态加载已声明的组件\n\n* 定义组件\n* 创建组件容器\n  `ViewChild`：一个属性装饰器，用来从模板视图中获取对应的元素，可以通过模板变量获取，获取时可以通过 read 属性设置查询的条件，就是说可以把此视图转为不同的实例\n  `ViewContainerRef`： 个视图容器，可以在此上面创建、插入、删除组件等等\n  ```ts\n   @ViewChild(\"childContainer\", { read: ViewContainerRef }) container: ViewContainerRef;\n   ```\n* 动态创建组件\n  `ComponentFactoryResolve`: 一个服务，动态加载组件的核心，这个服务可以将一个组件实例呈现到另一个组件视图上\n  通过调用`ComponentFactory`实例的`create()`创建组件\n  应用`ComponentFactoryResolver`服务的`resolveComponentFactory()`方法接受组件类，返回`ComponentFactory`\n  在组件`constructor`注入该服务\n  ```ts\n  constructor(private resolver: ComponentFactoryResolver) {}\n  ```\n  ```ts\n  createComponent(type: string) {\n    // 删除之前的视图\n    this.container.clear();\n    // 创建组件实例\n    const factory: ComponentFactory<ActXunComponent> = this.resolver.resolveComponentFactory(ActXunComponent);\n    // 将组件添加到容器当中\n    this.componentRef = this.container.createComponent(factory);\n    // 为组建复制\n    this.componentRef.instance.type = type;\n    // 订阅组件的输出属性\n    this.componentRef.instance.output.subscribe((msg: string) => console.log(msg));\n  }\n  ```\n  销毁组件\n  ```ts\n  ngOnDestroy() {\n    this.componentRef.destroy();\n  }\n  ```\n* 在`NgModule`的`entryComponents`属性中添加动态组件\n```ts\n@NgModule({\n  ...,\n  declarations: [AppComponent, ActXunComponent],\n  bootstrap: [AppComponent],\n  entryComponents: [ActXunComponent],\n})\nexport class AppModule { }\n```\n\n### 动态加载已声明的表单\n\n### Pipe (管道)\n过滤器，对输入的数据进行处理。\n\n#### Ng内建管道\n- String => String\n  * UpperCasePipe（大写转换）\n  ```html\n  <p>{{'Angular' | uppercase}}</p>\n  <span>输出ANGULAR</span>\n  ```\n\n  * LowerCasePipe (小写转换)\n ```html\n  <p>{{'Angular' | lowercase}}</p>\n  <span>输出angular</span>\n  ```\n\n  * TitleCasePipe (首字母大写)\n   ```html\n  <p>{{'angular' | titlecase}}</p>\n  <span>输出Angular</span>\n  ```\n\n- Number => String\n  * DecimalPipe (数值格式化)\n  ```html\n  <p>{{expression | number[: digiInfo] }}</p>\n  <p>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</p>\n  <p>{{ 3.14159265 | number: '1.3-5' }}</p>\n  <p>输出3.14159</p>\n  ```\n\n  * PercentPipe （百分比格式化）\n  ```html\n  <p>{{expression | percent[: digiInfo] }}</p>\n  <p>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</p>\n  <p>{{ 1 | percent: '1.3-5' }}</p>\n  <p>输出100.000%</p>\n  ```\n\n  * CurrencyPipe (货币格式化)\n  ```html\n  <p>{{expression | currency[: currencyCode[: symbolDisplay[: digiInfo]]] }}</p>\n  <p>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</p>\n  <p>currencyCod是指货币代码，其值为ISO 4217标准，人民币CNY,美元USD,欧元 EUR.\nsymbolDisplay 是一个布尔值，true时显示货币符号($￥) false显示货币码</p>\n  <p>{{ 1 | currency: 'USD': true }}</p>\n  <p>输出100.000%</p>\n  ```\n\n- Object => String\n  * JsonPipe (对象json化)\n  ```html\n  <p>{{ {name: 'xuncs'} | json}}</p>\n  <p>输出{ \"name\": \"xuncs\" }</p>\n  ```\n\n  * DatePipe (日期格式化)\n  ```html\n  <p>{{ new Date() | date: 'shortTime' }}</p>\n  <p>语法：{{expression | date:format}}</p>\n  <p>\n    y 年 y使用4位数字表示年份(2017),yy使用两位数字表示(17)\n    M 月 M 1位或两位数字(2或10、11、12),MM 两位数字表示，前面补0(02)\n    d 日 d 一位或两位数字(9) dd两位数字，前面补0(09)\n    E 星期 EEE 三位字母缩写的星期 EEEE 星期全称\n    j 12小时制时间 j (9 AM) jj (09 AM)\n    h 12小时制小时 h(9) hh (09)\n    H 24小时制小时 H(9) HH (09)\n    m 分 m (5) mm (05)\n    s 秒 s (1) ss (01)\n    z 时区 z China Standard Time\n  </p>\n  ```\n\n- Tools (工具类)\n  * SlicePipe (数组或字符串取切割)\n  ```html\n  <p>{{ 'xuncs' | slice:0:3 }}</p>\n  <p>输出：xun</p>\n  <p>语法：{{expression | slice: start [: end] }}</p>\n  ```\n  * AsyncPipe\n  `Promise`: 返回单个值，不可取消\n  `Observalbe`: 随着时间推移发出多个值，可以取消，支持`map`,`filter`,`reduce`等操作符，延迟执行\n  * I18nPluralPipe\n  * I18nSelectPipe\n\n#### 管道参数\n管道可以接收任意数量的参数。\n用法: 参数之间用`:`隔开\n\n#### 管道链\n将多个管道连接在一起，组成管道链对数据进行处理\n```html\n<p>{{ 'angular' | slice:0:3 | uppercase }}</p>\n<p>输出：ANG</p>\n```\n\n#### 管道分类\n\n- pure管道\n仅当管道输入值变化的时候，才执行转换操作，默认的类型是 pure 类型。(备注：输入值变化是指原始数据类型如：string、number、boolean 等的数值或对象的引用值发生变化)\n\n- impure管道\n在每次变化检测期间都会执行，如鼠标点击或移动都会执行 impure 管道\n\n#### 自定义管道 (@Pipe)\n- 使用 @Pipe 装饰器定义 Pipe 的 metadata 信息，如 Pipe 的名称 - 即 name 属性\n- 实现 PipeTransform 接口中定义的 transform 方法\n```\nng g p  <Name> --flat=false      // 新建管道\n```\n\n```ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'xunTest',\n  // 非纯管道\n  pure: false\n})\nexport class XunTestPipe implements PipeTransform {\n\n  transform(value: any, args?: any): any {\n    return null;\n  }\n\n}\n```\n","source":"_posts/angular4入门.md","raw":"---\ntitle: Angular4入门\ndate: 2017-08-02 10:49:44\ntags:\n\tAngular\n---\n## Angular4入门\n\n### Angular-cli\n\n#### 全局安装\n```shell\nsudo npm install @angular/cli -g\n\nng generate --help  // 查询帮助\n```\n#### 创建项目\n```sh\nng new <ProjectName>\n```\n相关配置\n```sh\n--dry-run           // boolean, 默认为 false, 若设置 dry-run 则不会创建任何文件\n--verbose           // boolean, 默认为 false\n--link-cli          // boolean, 默认为 false, 自动链接到 @angular/cli 包\n--skip-install      // boolean, 默认为 false, 表示跳过 npm install\n--skip-git          // boolean, 默认为 false, 表示该目录不初始化为 git 仓库\n--skip-tests        // boolean, 默认为 false, 表示不创建 tests 相关文件\n--skip-commit       // boolean, 默认为 false, 表示不进行初始提交\n--directory         // string, 用于设置创建的目录名，默认与应用程序的同名\n--source-dir        // string, 默认为 'src', 用于设置源文件目录的名称\n--style             // string, 默认为 'css', 用于设置选用的样式语法 ('css', 'less' or 'scss')\n--prefix            // string, 默认为 'app', 用于设置创建新组件时，组件选择器使用的前缀\n--mobile            // boolean, 默认为 false,表示是否生成 Progressive Web App 应用程序\n--routing           // boolean, 默认为 false, 表示新增带有路由信息的模块，并添加到根模块中\n--inline-style      // boolean, 默认为 false, 表示当创建新的应用程序时，使用内联样式\n--inline-template   // boolean, 默认为 false, 表示当创建新的应用程序时，使用内联模板\n```\n\n#### 启动项目\n```sh\ncd <ProjectName>\nnpm start -o\nng serve  --open   // 主动打开浏览器窗口\n```\n\n```sh\nng g cl <Name> --spec            // 新建 class\nng g c  <Name>                   // 新建组件\nng g d  <Name>                   // 新建指令\nng g e  <Name>                   // 新建枚举\nng g m  <Name> --routing --spec  // 新建模块\nng g p  <Name> --flat=false      // 新建管道\nng g s  <Name> --flat=false       // 新建服务\n```\n\n#### 单元测试\n```sh\nng test\nnpm test\n```\n\n#### e2e测试\n```sh\nng e2e\n```\n\n#### 构建压缩代码并实施监控变化的应用程序\n```sh\nng build --target=production --watch\n```\n\n#### 自定义构建webpack\n```sh\nng eject\n```\n\n### 实际开发\n\n#### 事件绑定\n\n```html\n<!--xun-com.component.html  -->\n<span>{{title}}</span>\n<!--dom绑定  -->\n<input #myInput type=\"text\">\n<!--鼠标事件  -->\n<button (click)=\"onClick($event, myInput.value)\">鼠标点击事件</button>\n<!--键盘事件  -->\n<input #keyBoard type=\"text\" (keydown.enter)=\"onEnter($event, keyBoard.value)\">\n```\n\n```ts\n<!--xun-com.component.ts  -->\nimport { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-xun-com',\n  templateUrl: './xun-com.component.html',\n  styleUrls: ['./xun-com.component.css']\n})\nexport class XunComComponent implements OnInit {\n  title: string;\n  constructor() {\n    this.title = 'title'\n  }\n\n  ngOnInit() {\n  }\n  // 事件方法\n  onClick(event, val) {\n    console.log(event)\n    console.log(val)\n  }\n  onEnter(event, val) {\n    console.log(event)\n    console.log(val)\n  }\n\n}\n```\n\n#### 新建服务\n\n```sh\nng g s mail\n\n// 输出\ninstalling service\n  create src/app/mail.service.spec.ts     // 用于单元测试\n  create src/app/mail.service.ts          // 新建的服务\n  WARNING Service is generated but not provided, it must be provided to be used\n```\n\n#### 配置服务\n```ts\nimport { MailService } from './mail.service';\n\n@NgModule({\n\n  providers: [\n    MailService,\n    {provide: 'apiUrl', useValue: 'https://jsonplaceholder.typicode.com/'}\n  ],     // 注入服务  \n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\n#### 更新服务\n```ts\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class MailService {\n  message: string  ='该消息来自MailService';\n  constructor() { }\n}\n```\n\n#### 使用服务\n```ts\n<!--xun-com.component.ts  -->\nimport { MailService } from '../mail.service';\n...\nexport class AppComponent {\n\n  constructor(private mailService: MailService) {}\n  constructor(\n    @Inject(MailService) private mailService,\n    @Inject('apiUrl') private apiUrl) {}\n  <!--二选其一  -->\n  <!-- 不过对于 Type 类型(函数类型) 的对象，我们一般使用 constructor(private mailService: MailService) 方式进行注入。而 Inject 装饰器一般用来注入非 Type 类型的对象。 -->\n}\n```\n```html\n<!--xun-com.component.html  -->\n<p>{{mailService.message}}</p>\n```\n\n#### ngClass\n```html\n<div [ngClass]=\"{mousedown: isMousedown}\"></div>\n```\n\n#### ngStyle\n```html\n<!--font-size支持px % em  -->\n<div>\n   <span [ngStyle]=\"{color: 'red'}\" [style.font-size.px]=\"fontSize\" [style.background-color=\"'red'\"]>\n      Red Text\n   </span>\n</div>\n```\n\n#### ngModel\n- 单独使用ngModel\n需要给表单元素添加`name`，为`ngForm.value`对象添加`property`\n```html\n<input type='text' name='userName' placeholder='Input your userName' ngModel>\n```\n- 单向绑定[ngModel]\n将this.name 初始化绑定到`ngForm.value`上\n```html\n<input type='text' name='userName' placeholder='Input your userName' [ngModel]=\"name\" />\n```\n\n- 双向绑定[(ngModel)]\n```ts\n<!--module中  -->\nimport {FormsModule} from '@angular/forms';\n...\nimports: [\n    ...\n    FormsModule\n  ],\n<!--组件中  -->\nthis.inputValue = 'inputvalue'\n<!--模板中  -->\n<input #myInput type=\"text\" [(ngModel)]=\"inputValue\">\n```\n\n#### @Input\n相当于props 父组件==>子组件\n```ts\n<!--子组件 xun-com.component  -->\nimport { ..., Input } from '@angular/core';\n...\nexport class XunComComponent implements OnInit {\n\n  @Input() msg: string;\n}\n\n<!--父组件 app.component  -->\nexport class AppComponent {\n  msg = {\n    data: '数据'\n  };\n}\n```\n\n```html\n<!--父模板 app.component  -->\n<app-xun-com [msg]=\"msg\"></app-xun-com>\n\n<!--子模板 xun-com.component -->\n<span>msg: {{msg.data}}</span>\n```\n\n#### @Output\nOutput装饰器:  让子组件将信息通过事件的方式返回给父组件\n```ts\n<!--子组件  -->\nimport {Output, EventEmitter } from '@angular/core';\nexport class XunComComponent implements OnInit {\n  @Input() msg: string;\n  @Output() update = new EventEmitter<{title: string}>();\n  constructor() {\n    this.title = 'xun-com'\n    }\n}\n<!--子组件模板  -->\n<button (click)=\"update.emit(title)\">更新</button>\n\n<!--父组件  -->\nexport class AppComponent {\n  constructor() {}\n  onUpdate(title) {\n    console.log(title)\n  }\n}\n<!--父组件模板  -->\n<app-xun-com (update)=\"onUpdate(title)\"></app-xun-com>\n```\n\n#### http模块\n```ts\n<!--导入模块 app.module.ts  -->\n...\nimport { HttpModule } from '@angular/http';\n...\n@NgModule({\n  imports: [BrowserModule, FormsModule, HttpModule],\n  declarations: [AppComponent, UserComponent],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n<!--调用模块  -->\nimport { Http } from '@angular/http';\nimport 'rxjs/add/operator/map';\n...\nexport class MembersComponent implements OnInit {\n  members: Member[];\n\n  constructor(private http: Http) { } // (3)\n\n  ngOnInit() {\n    this.http.get(`api`) // (4)\n        .map(res => res.json()) // (5)\n        .subscribe(data => {\n           if (data) this.members = data; // (6)\n        });\n    }\n}\n```\n\n#### 路由\n- `RouterModule.forRoot()`: 在主模块中定义主要的路由信息\n- `RouterModule.forChild()`: 在子模块中定义路由信息\n- `<router-outlet></router-outlet>`: 路由视图入口位置\n- 动态路由\n```ts\n// 配置文件\n  { path: '/profile/:username', component: ProfileComponent }\n// 组件中\nimport { ActivatedRoute } from '@angular/router';\n...\nexport class SettingsComponent implements OnInit {\n  username: string;\n  constructor(private route: ActivatedRoute) {}\n  ngOnInit() {\n    this.route.params.subscribe((params) => this.username = params.username);\n  }\n}\n```\n- 子路由 children\n- loadChildren 从另一个模块中获取子路由\n\n```ts\n// 子模块\nimport { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Routes, RouterModule } from '@angular/router';\n\nexport const ROUTES: Routes = [\n  {\n    path: '',\n    component: SettingsComponent,\n    children: [\n      { path: 'profile', component: ProfileSettingsComponent },\n      { path: 'password', component: PasswordSettingsComponent }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    CommonModule,\n    RouterModule.forChild(ROUTES)\n  ],\n})\nexport class SettingsModule {}\n\n// 父模块\nexport const ROUTES: Routes = [\n  {\n    path: 'settings',\n    loadChildren: './settings/settings.module#SettingsModule'\n  }\n];\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n  // ...\n})\nexport class AppModule {}\n\n```\n\n- Router Directives\n  `routerLink`: 跳转指令\n  ```html\n  <a routerLink=\"/\">Home</a>\n  ```\n- 路由跳转\n  ```ts\n  this.router.navigate(['/profile', event.name]);\n  ```\n\n### NgModule\n@NgModule接收一个用来描述模块属性的元数据对象\n\n- `declarations`:  声明本模块中的视图类\n- `exports`: declarations 的子集，可用于其它模块的组件模板\n- `imports`: 注册其他模块\n- `providers`: 添加全局服务\n- `bootstrap`: 根组件\n\n\n### Directive\n- `Component directive`: 构建UI组件，继承于Directive类\n- `Attribute directive`: 改变组件的外观或行为\n- `Structural directive`: 动态添加或删除DOM元素来改变DOM布局\n\n#### 自定义指令\n- `HostBinding`: 实现元素属性绑定\n- `Input`: 实现自定义元素属性输入\n- `HostListener`: 监听元素的事件\n- `Attribute`: 获取指令宿主元素上的自定义属性\n\n#### ngFor: 使用可迭代的每个项作为模板的上下文来重复模板\n首先更新mail服务，增加数组\n```ts\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class MailService {\n  message: string = '该消息来自MailService';\n  messages: string[] = [\n    '天之骄子，加入修仙之路群',\n    'Shadows，加入修仙之路群',\n    'Keriy，加入修仙之路群'\n  ]\n  constructor() { }\n}\n```\n更新组件模板\n```html\n<ul>\n  <li *ngFor=\"let message of mailService.messages; index as i;\">\n    {{i}} - {{message}}\n  </li>\n</ul>\n```\n\n#### ngIf: 根据表达式的值，显示或移除元素\n```html\n<div *ngIf=\"SHOW\">show</div>\n```\n#### ngSwitch\n```html\n<ul [ngSwitch]='person.country'>\n  <li *ngSwitchCase=\"'UK'\" class='text-success'>\n      {{ person.name }} ({{person.country}})\n  </li>\n   <li *ngSwitchCase=\"'USA'\" class='text-secondary'>\n      {{ person.name }} ({{person.country}})\n  </li>\n  <li *ngSwitchDefault class='text-primary'>\n    {{ person.name }} ({{person.country}})\n  </li>\n</ul>\n```\n\n\n\n### Template Driven Forms\n#### 创建表单\nng内嵌`validators`模块\n使用`userName.valid`判断验证，`userName.errors`输出错误信息\n```ts\n<!--html模板  -->\n<input\n  type=\"text\"\n  required\n  minlength=\"3\"\n  [(ngModel)]=\"username\"\n  #userName=\"ngModel\">\n  {{userName.valid}}\n<div *ngIf=\"userName.errors?.required\">请您输入用户名</div>\n<div *ngIf=\"userName.errors?.minlength\">\n  用户名的长度必须大于 {{userName.errors?.minlength.requiredLength}}，当前的长度为\n    {{userName.errors?.minlength.actualLength}}\n</div>\n\n<!--ts模块  -->\nexport class AppComponent {\n  username = 'semlinker';\n}\n```\n\n\n#### 表单提交\n通过 `#loginForm=\"ngForm\"` 方式获取 `ngForm` 对象，然后通过 `loginForm.value` 来获取表单的值\n<!--html模板  -->\n```html\n<form #loginForm=\"ngForm\" (ngSubmit)=\"onSubmit(loginForm.value)\">\n...\n<button type=\"submit\">提交</button>\n</form>\n```\n<!--绑定方法  -->\n```ts\nonSubmit(value) {\n    console.dir(value);\n  }\n```\n通过`ngModelGroup`指令对表单元素进行细化\n```html\n<form #loginForm=\"ngForm\" (ngSubmit)=\"onSubmit(loginForm.value)\">\n   <fieldset ngModelGroup=\"user\">\n    <input\n     type=\"text\"\n     required\n     minlength=\"3\"\n     name=\"username\"\n     [(ngModel)]=\"username\"\n     #userName=\"ngModel\">\n    <hr>\n    <div *ngIf=\"userName.errors?.required\">请您输入用户名</div>\n    <div *ngIf=\"userName.errors?.minlength\">\n      用户名的长度必须大于 {{userName.errors?.minlength.requiredLength}}，当前的长度为\n        {{userName.errors?.minlength.actualLength}}\n    </div>\n    <input type=\"password\" ngModel name=\"password\">\n   </fieldset>\n    <button type=\"submit\">提交</button>\n    <hr>\n    {{loginForm.value | json}}\n  </form>\n```\n\n#### 验证状态样式\n可以通过 `#userName=\"ngModel\"` 方式获取 `ngModel` 对象，进而通过`userName.dirty`获取控件的状态信息\ncss类\n```css\n.input.ng-invalid {\n  border: 3px solid red;\n}\ninput.ng-valid {\n  border: 3px solid green;\n}\n```\n状态列表\n- `valid`: 表单控件有效\n- `invalid`: 表单控件无效\n- `pristine`: 表单控件值未改变\n- `dirty`: 表单控件值已改变\n- `touched`: 表单控件已被访问过\n- `untouched`: 表单控件未被访问过\n\n#### 单选多选\n```html\n<div *ngFor=\"let version of versions;\">\n  <input\n    [attr.id]=\"version\"\n      name=\"version\"\n\n      required\n      [value]=\"version\"\n      type=\"radio\">\n    <label [attr.for]=\"version\">{{version}}</label>\n</div>\n```\n#### 特点\n- 使用方便，适用于简单环境\n- 通过[(ngModel)]实现数据的双向绑定\n- 最小化组件类的代码\n- 不易于单元测试\n\n### Reactive Form\n`FormControl`: 一个为单个表单控件提供支持的类，可用于跟踪控件的值和验证状态.\n```ts\nngOnInit() {\n  this.myControl = new FormControl('Semlinker');\n}\n```\n\n`FormGroup`: 包含一组 FormControl 实例，可用于跟踪 FormControl 组的值和验证状态.\n<!--组件ts  -->\n```ts\nexport class XunCsComponent implements OnInit {\n\nconstructor() {}\n  // tslint:disable-next-line:member-ordering\n  user: FormGroup;\n  ngOnInit() {\n    this.user = new FormGroup({\n      name: new FormControl(''),\n      account: new FormGroup({\n        email: new FormControl(''),\n        confirm: new FormControl('')\n      })\n    });\n  }\n  onSubmit() {\n    console.log(this.user.value, this.user.valid);\n  }\n}\n```\n<!--组件模板  -->\n```html\n  <form novalidate [formGroup]=\"user\"  (ngSubmit)=\"onSubmit(user)\" >\n  <label>\n    <span>Full name</span>\n    <input\n      type=\"text\"\n      placeholder=\"Your full name\"\n      formControlName=\"name\">\n  </label>\n  <div formGroupName=\"account\">\n    <label>\n      <span>Email address</span>\n      <input\n        type=\"email\"\n        placeholder=\"Your email address\"\n        formControlName=\"email\">\n    </label>\n    <label>\n      <span>Confirm address</span>\n      <input\n        type=\"email\"\n        placeholder=\"Confirm your email address\"\n        formControlName=\"confirm\">\n    </label>\n  </div>\n  <button type=\"submit\">Sign up</button>\n</form>\n```\n\n#### 表单验证\n通过`user.invalid`判断表单验证是否正确\n通过`user.controls.name?.errors`获取错误原因\n```ts\nthis.user = new FormGroup({\n  name: new FormControl('', [Validators.required, Validators.minLength(2)]),\n  account: new FormGroup({\n    email: new FormControl('', Validators.required),\n    confirm: new FormControl('', Validators.required)\n  })\n});\n```\n\n#### FormBuilder\n用来简化`FormGroup`+`FormControl`结合\n```ts\nngOnInit() {\n  this.user = this.fb.group({\n    name: ['', [Validators.required, Validators.minLength(2)]],\n    account: this.fb.group({\n      email: ['', Validators.required],\n      confirm: ['', Validators.required]\n    })\n  });\n}\n```\n\n#### 特点\n- 灵活，适用于复杂场景\n- 简化html模板代码，将验证逻辑抽离到组件类中\n- 方便跟踪表单控件值变化\n- 易于单元测试\n\n### 动态加载已声明的组件\n\n* 定义组件\n* 创建组件容器\n  `ViewChild`：一个属性装饰器，用来从模板视图中获取对应的元素，可以通过模板变量获取，获取时可以通过 read 属性设置查询的条件，就是说可以把此视图转为不同的实例\n  `ViewContainerRef`： 个视图容器，可以在此上面创建、插入、删除组件等等\n  ```ts\n   @ViewChild(\"childContainer\", { read: ViewContainerRef }) container: ViewContainerRef;\n   ```\n* 动态创建组件\n  `ComponentFactoryResolve`: 一个服务，动态加载组件的核心，这个服务可以将一个组件实例呈现到另一个组件视图上\n  通过调用`ComponentFactory`实例的`create()`创建组件\n  应用`ComponentFactoryResolver`服务的`resolveComponentFactory()`方法接受组件类，返回`ComponentFactory`\n  在组件`constructor`注入该服务\n  ```ts\n  constructor(private resolver: ComponentFactoryResolver) {}\n  ```\n  ```ts\n  createComponent(type: string) {\n    // 删除之前的视图\n    this.container.clear();\n    // 创建组件实例\n    const factory: ComponentFactory<ActXunComponent> = this.resolver.resolveComponentFactory(ActXunComponent);\n    // 将组件添加到容器当中\n    this.componentRef = this.container.createComponent(factory);\n    // 为组建复制\n    this.componentRef.instance.type = type;\n    // 订阅组件的输出属性\n    this.componentRef.instance.output.subscribe((msg: string) => console.log(msg));\n  }\n  ```\n  销毁组件\n  ```ts\n  ngOnDestroy() {\n    this.componentRef.destroy();\n  }\n  ```\n* 在`NgModule`的`entryComponents`属性中添加动态组件\n```ts\n@NgModule({\n  ...,\n  declarations: [AppComponent, ActXunComponent],\n  bootstrap: [AppComponent],\n  entryComponents: [ActXunComponent],\n})\nexport class AppModule { }\n```\n\n### 动态加载已声明的表单\n\n### Pipe (管道)\n过滤器，对输入的数据进行处理。\n\n#### Ng内建管道\n- String => String\n  * UpperCasePipe（大写转换）\n  ```html\n  <p>{{'Angular' | uppercase}}</p>\n  <span>输出ANGULAR</span>\n  ```\n\n  * LowerCasePipe (小写转换)\n ```html\n  <p>{{'Angular' | lowercase}}</p>\n  <span>输出angular</span>\n  ```\n\n  * TitleCasePipe (首字母大写)\n   ```html\n  <p>{{'angular' | titlecase}}</p>\n  <span>输出Angular</span>\n  ```\n\n- Number => String\n  * DecimalPipe (数值格式化)\n  ```html\n  <p>{{expression | number[: digiInfo] }}</p>\n  <p>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</p>\n  <p>{{ 3.14159265 | number: '1.3-5' }}</p>\n  <p>输出3.14159</p>\n  ```\n\n  * PercentPipe （百分比格式化）\n  ```html\n  <p>{{expression | percent[: digiInfo] }}</p>\n  <p>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</p>\n  <p>{{ 1 | percent: '1.3-5' }}</p>\n  <p>输出100.000%</p>\n  ```\n\n  * CurrencyPipe (货币格式化)\n  ```html\n  <p>{{expression | currency[: currencyCode[: symbolDisplay[: digiInfo]]] }}</p>\n  <p>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</p>\n  <p>currencyCod是指货币代码，其值为ISO 4217标准，人民币CNY,美元USD,欧元 EUR.\nsymbolDisplay 是一个布尔值，true时显示货币符号($￥) false显示货币码</p>\n  <p>{{ 1 | currency: 'USD': true }}</p>\n  <p>输出100.000%</p>\n  ```\n\n- Object => String\n  * JsonPipe (对象json化)\n  ```html\n  <p>{{ {name: 'xuncs'} | json}}</p>\n  <p>输出{ \"name\": \"xuncs\" }</p>\n  ```\n\n  * DatePipe (日期格式化)\n  ```html\n  <p>{{ new Date() | date: 'shortTime' }}</p>\n  <p>语法：{{expression | date:format}}</p>\n  <p>\n    y 年 y使用4位数字表示年份(2017),yy使用两位数字表示(17)\n    M 月 M 1位或两位数字(2或10、11、12),MM 两位数字表示，前面补0(02)\n    d 日 d 一位或两位数字(9) dd两位数字，前面补0(09)\n    E 星期 EEE 三位字母缩写的星期 EEEE 星期全称\n    j 12小时制时间 j (9 AM) jj (09 AM)\n    h 12小时制小时 h(9) hh (09)\n    H 24小时制小时 H(9) HH (09)\n    m 分 m (5) mm (05)\n    s 秒 s (1) ss (01)\n    z 时区 z China Standard Time\n  </p>\n  ```\n\n- Tools (工具类)\n  * SlicePipe (数组或字符串取切割)\n  ```html\n  <p>{{ 'xuncs' | slice:0:3 }}</p>\n  <p>输出：xun</p>\n  <p>语法：{{expression | slice: start [: end] }}</p>\n  ```\n  * AsyncPipe\n  `Promise`: 返回单个值，不可取消\n  `Observalbe`: 随着时间推移发出多个值，可以取消，支持`map`,`filter`,`reduce`等操作符，延迟执行\n  * I18nPluralPipe\n  * I18nSelectPipe\n\n#### 管道参数\n管道可以接收任意数量的参数。\n用法: 参数之间用`:`隔开\n\n#### 管道链\n将多个管道连接在一起，组成管道链对数据进行处理\n```html\n<p>{{ 'angular' | slice:0:3 | uppercase }}</p>\n<p>输出：ANG</p>\n```\n\n#### 管道分类\n\n- pure管道\n仅当管道输入值变化的时候，才执行转换操作，默认的类型是 pure 类型。(备注：输入值变化是指原始数据类型如：string、number、boolean 等的数值或对象的引用值发生变化)\n\n- impure管道\n在每次变化检测期间都会执行，如鼠标点击或移动都会执行 impure 管道\n\n#### 自定义管道 (@Pipe)\n- 使用 @Pipe 装饰器定义 Pipe 的 metadata 信息，如 Pipe 的名称 - 即 name 属性\n- 实现 PipeTransform 接口中定义的 transform 方法\n```\nng g p  <Name> --flat=false      // 新建管道\n```\n\n```ts\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'xunTest',\n  // 非纯管道\n  pure: false\n})\nexport class XunTestPipe implements PipeTransform {\n\n  transform(value: any, args?: any): any {\n    return null;\n  }\n\n}\n```\n","slug":"angular4入门","published":1,"updated":"2017-10-15T02:51:58.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2p000lttwptan34f3v","content":"<h2 id=\"Angular4入门\"><a href=\"#Angular4入门\" class=\"headerlink\" title=\"Angular4入门\"></a>Angular4入门</h2><h3 id=\"Angular-cli\"><a href=\"#Angular-cli\" class=\"headerlink\" title=\"Angular-cli\"></a>Angular-cli</h3><h4 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h4><pre><code class=\"shell\">sudo npm install @angular/cli -g\n\nng generate --help  // 查询帮助\n</code></pre>\n<h4 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h4><pre><code class=\"sh\">ng new &lt;ProjectName&gt;\n</code></pre>\n<p>相关配置</p>\n<pre><code class=\"sh\">--dry-run           // boolean, 默认为 false, 若设置 dry-run 则不会创建任何文件\n--verbose           // boolean, 默认为 false\n--link-cli          // boolean, 默认为 false, 自动链接到 @angular/cli 包\n--skip-install      // boolean, 默认为 false, 表示跳过 npm install\n--skip-git          // boolean, 默认为 false, 表示该目录不初始化为 git 仓库\n--skip-tests        // boolean, 默认为 false, 表示不创建 tests 相关文件\n--skip-commit       // boolean, 默认为 false, 表示不进行初始提交\n--directory         // string, 用于设置创建的目录名，默认与应用程序的同名\n--source-dir        // string, 默认为 &#39;src&#39;, 用于设置源文件目录的名称\n--style             // string, 默认为 &#39;css&#39;, 用于设置选用的样式语法 (&#39;css&#39;, &#39;less&#39; or &#39;scss&#39;)\n--prefix            // string, 默认为 &#39;app&#39;, 用于设置创建新组件时，组件选择器使用的前缀\n--mobile            // boolean, 默认为 false,表示是否生成 Progressive Web App 应用程序\n--routing           // boolean, 默认为 false, 表示新增带有路由信息的模块，并添加到根模块中\n--inline-style      // boolean, 默认为 false, 表示当创建新的应用程序时，使用内联样式\n--inline-template   // boolean, 默认为 false, 表示当创建新的应用程序时，使用内联模板\n</code></pre>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><pre><code class=\"sh\">cd &lt;ProjectName&gt;\nnpm start -o\nng serve  --open   // 主动打开浏览器窗口\n</code></pre>\n<pre><code class=\"sh\">ng g cl &lt;Name&gt; --spec            // 新建 class\nng g c  &lt;Name&gt;                   // 新建组件\nng g d  &lt;Name&gt;                   // 新建指令\nng g e  &lt;Name&gt;                   // 新建枚举\nng g m  &lt;Name&gt; --routing --spec  // 新建模块\nng g p  &lt;Name&gt; --flat=false      // 新建管道\nng g s  &lt;Name&gt; --flat=false       // 新建服务\n</code></pre>\n<h4 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h4><pre><code class=\"sh\">ng test\nnpm test\n</code></pre>\n<h4 id=\"e2e测试\"><a href=\"#e2e测试\" class=\"headerlink\" title=\"e2e测试\"></a>e2e测试</h4><pre><code class=\"sh\">ng e2e\n</code></pre>\n<h4 id=\"构建压缩代码并实施监控变化的应用程序\"><a href=\"#构建压缩代码并实施监控变化的应用程序\" class=\"headerlink\" title=\"构建压缩代码并实施监控变化的应用程序\"></a>构建压缩代码并实施监控变化的应用程序</h4><pre><code class=\"sh\">ng build --target=production --watch\n</code></pre>\n<h4 id=\"自定义构建webpack\"><a href=\"#自定义构建webpack\" class=\"headerlink\" title=\"自定义构建webpack\"></a>自定义构建webpack</h4><pre><code class=\"sh\">ng eject\n</code></pre>\n<h3 id=\"实际开发\"><a href=\"#实际开发\" class=\"headerlink\" title=\"实际开发\"></a>实际开发</h3><h4 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h4><pre><code class=\"html\">&lt;!--xun-com.component.html  --&gt;\n&lt;span&gt;{{title}}&lt;/span&gt;\n&lt;!--dom绑定  --&gt;\n&lt;input #myInput type=&quot;text&quot;&gt;\n&lt;!--鼠标事件  --&gt;\n&lt;button (click)=&quot;onClick($event, myInput.value)&quot;&gt;鼠标点击事件&lt;/button&gt;\n&lt;!--键盘事件  --&gt;\n&lt;input #keyBoard type=&quot;text&quot; (keydown.enter)=&quot;onEnter($event, keyBoard.value)&quot;&gt;\n</code></pre>\n<pre><code class=\"ts\">&lt;!--xun-com.component.ts  --&gt;\nimport { Component, OnInit } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-xun-com&#39;,\n  templateUrl: &#39;./xun-com.component.html&#39;,\n  styleUrls: [&#39;./xun-com.component.css&#39;]\n})\nexport class XunComComponent implements OnInit {\n  title: string;\n  constructor() {\n    this.title = &#39;title&#39;\n  }\n\n  ngOnInit() {\n  }\n  // 事件方法\n  onClick(event, val) {\n    console.log(event)\n    console.log(val)\n  }\n  onEnter(event, val) {\n    console.log(event)\n    console.log(val)\n  }\n\n}\n</code></pre>\n<h4 id=\"新建服务\"><a href=\"#新建服务\" class=\"headerlink\" title=\"新建服务\"></a>新建服务</h4><pre><code class=\"sh\">ng g s mail\n\n// 输出\ninstalling service\n  create src/app/mail.service.spec.ts     // 用于单元测试\n  create src/app/mail.service.ts          // 新建的服务\n  WARNING Service is generated but not provided, it must be provided to be used\n</code></pre>\n<h4 id=\"配置服务\"><a href=\"#配置服务\" class=\"headerlink\" title=\"配置服务\"></a>配置服务</h4><pre><code class=\"ts\">import { MailService } from &#39;./mail.service&#39;;\n\n@NgModule({\n\n  providers: [\n    MailService,\n    {provide: &#39;apiUrl&#39;, useValue: &#39;https://jsonplaceholder.typicode.com/&#39;}\n  ],     // 注入服务  \n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n</code></pre>\n<h4 id=\"更新服务\"><a href=\"#更新服务\" class=\"headerlink\" title=\"更新服务\"></a>更新服务</h4><pre><code class=\"ts\">import { Injectable } from &#39;@angular/core&#39;;\n\n@Injectable()\nexport class MailService {\n  message: string  =&#39;该消息来自MailService&#39;;\n  constructor() { }\n}\n</code></pre>\n<h4 id=\"使用服务\"><a href=\"#使用服务\" class=\"headerlink\" title=\"使用服务\"></a>使用服务</h4><pre><code class=\"ts\">&lt;!--xun-com.component.ts  --&gt;\nimport { MailService } from &#39;../mail.service&#39;;\n...\nexport class AppComponent {\n\n  constructor(private mailService: MailService) {}\n  constructor(\n    @Inject(MailService) private mailService,\n    @Inject(&#39;apiUrl&#39;) private apiUrl) {}\n  &lt;!--二选其一  --&gt;\n  &lt;!-- 不过对于 Type 类型(函数类型) 的对象，我们一般使用 constructor(private mailService: MailService) 方式进行注入。而 Inject 装饰器一般用来注入非 Type 类型的对象。 --&gt;\n}\n</code></pre>\n<pre><code class=\"html\">&lt;!--xun-com.component.html  --&gt;\n&lt;p&gt;{{mailService.message}}&lt;/p&gt;\n</code></pre>\n<h4 id=\"ngClass\"><a href=\"#ngClass\" class=\"headerlink\" title=\"ngClass\"></a>ngClass</h4><pre><code class=\"html\">&lt;div [ngClass]=&quot;{mousedown: isMousedown}&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h4 id=\"ngStyle\"><a href=\"#ngStyle\" class=\"headerlink\" title=\"ngStyle\"></a>ngStyle</h4><pre><code class=\"html\">&lt;!--font-size支持px % em  --&gt;\n&lt;div&gt;\n   &lt;span [ngStyle]=&quot;{color: &#39;red&#39;}&quot; [style.font-size.px]=&quot;fontSize&quot; [style.background-color=&quot;&#39;red&#39;&quot;]&gt;\n      Red Text\n   &lt;/span&gt;\n&lt;/div&gt;\n</code></pre>\n<h4 id=\"ngModel\"><a href=\"#ngModel\" class=\"headerlink\" title=\"ngModel\"></a>ngModel</h4><ul>\n<li>单独使用ngModel<br>需要给表单元素添加<code>name</code>，为<code>ngForm.value</code>对象添加<code>property</code><pre><code class=\"html\">&lt;input type=&#39;text&#39; name=&#39;userName&#39; placeholder=&#39;Input your userName&#39; ngModel&gt;\n</code></pre>\n</li>\n<li><p>单向绑定[ngModel]<br>将this.name 初始化绑定到<code>ngForm.value</code>上</p>\n<pre><code class=\"html\">&lt;input type=&#39;text&#39; name=&#39;userName&#39; placeholder=&#39;Input your userName&#39; [ngModel]=&quot;name&quot; /&gt;\n</code></pre>\n</li>\n<li><p>双向绑定[(ngModel)]</p>\n<pre><code class=\"ts\">&lt;!--module中  --&gt;\nimport {FormsModule} from &#39;@angular/forms&#39;;\n...\nimports: [\n  ...\n  FormsModule\n],\n&lt;!--组件中  --&gt;\nthis.inputValue = &#39;inputvalue&#39;\n&lt;!--模板中  --&gt;\n&lt;input #myInput type=&quot;text&quot; [(ngModel)]=&quot;inputValue&quot;&gt;\n</code></pre>\n</li>\n</ul>\n<h4 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"@Input\"></a>@Input</h4><p>相当于props 父组件==&gt;子组件</p>\n<pre><code class=\"ts\">&lt;!--子组件 xun-com.component  --&gt;\nimport { ..., Input } from &#39;@angular/core&#39;;\n...\nexport class XunComComponent implements OnInit {\n\n  @Input() msg: string;\n}\n\n&lt;!--父组件 app.component  --&gt;\nexport class AppComponent {\n  msg = {\n    data: &#39;数据&#39;\n  };\n}\n</code></pre>\n<pre><code class=\"html\">&lt;!--父模板 app.component  --&gt;\n&lt;app-xun-com [msg]=&quot;msg&quot;&gt;&lt;/app-xun-com&gt;\n\n&lt;!--子模板 xun-com.component --&gt;\n&lt;span&gt;msg: {{msg.data}}&lt;/span&gt;\n</code></pre>\n<h4 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"@Output\"></a>@Output</h4><p>Output装饰器:  让子组件将信息通过事件的方式返回给父组件</p>\n<pre><code class=\"ts\">&lt;!--子组件  --&gt;\nimport {Output, EventEmitter } from &#39;@angular/core&#39;;\nexport class XunComComponent implements OnInit {\n  @Input() msg: string;\n  @Output() update = new EventEmitter&lt;{title: string}&gt;();\n  constructor() {\n    this.title = &#39;xun-com&#39;\n    }\n}\n&lt;!--子组件模板  --&gt;\n&lt;button (click)=&quot;update.emit(title)&quot;&gt;更新&lt;/button&gt;\n\n&lt;!--父组件  --&gt;\nexport class AppComponent {\n  constructor() {}\n  onUpdate(title) {\n    console.log(title)\n  }\n}\n&lt;!--父组件模板  --&gt;\n&lt;app-xun-com (update)=&quot;onUpdate(title)&quot;&gt;&lt;/app-xun-com&gt;\n</code></pre>\n<h4 id=\"http模块\"><a href=\"#http模块\" class=\"headerlink\" title=\"http模块\"></a>http模块</h4><pre><code class=\"ts\">&lt;!--导入模块 app.module.ts  --&gt;\n...\nimport { HttpModule } from &#39;@angular/http&#39;;\n...\n@NgModule({\n  imports: [BrowserModule, FormsModule, HttpModule],\n  declarations: [AppComponent, UserComponent],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n&lt;!--调用模块  --&gt;\nimport { Http } from &#39;@angular/http&#39;;\nimport &#39;rxjs/add/operator/map&#39;;\n...\nexport class MembersComponent implements OnInit {\n  members: Member[];\n\n  constructor(private http: Http) { } // (3)\n\n  ngOnInit() {\n    this.http.get(`api`) // (4)\n        .map(res =&gt; res.json()) // (5)\n        .subscribe(data =&gt; {\n           if (data) this.members = data; // (6)\n        });\n    }\n}\n</code></pre>\n<h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><ul>\n<li><code>RouterModule.forRoot()</code>: 在主模块中定义主要的路由信息</li>\n<li><code>RouterModule.forChild()</code>: 在子模块中定义路由信息</li>\n<li><code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>: 路由视图入口位置</li>\n<li>动态路由<pre><code class=\"ts\">// 配置文件\n{ path: &#39;/profile/:username&#39;, component: ProfileComponent }\n// 组件中\nimport { ActivatedRoute } from &#39;@angular/router&#39;;\n...\nexport class SettingsComponent implements OnInit {\nusername: string;\nconstructor(private route: ActivatedRoute) {}\nngOnInit() {\n  this.route.params.subscribe((params) =&gt; this.username = params.username);\n}\n}\n</code></pre>\n</li>\n<li>子路由 children</li>\n<li>loadChildren 从另一个模块中获取子路由</li>\n</ul>\n<pre><code class=\"ts\">// 子模块\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { CommonModule } from &#39;@angular/common&#39;;\nimport { Routes, RouterModule } from &#39;@angular/router&#39;;\n\nexport const ROUTES: Routes = [\n  {\n    path: &#39;&#39;,\n    component: SettingsComponent,\n    children: [\n      { path: &#39;profile&#39;, component: ProfileSettingsComponent },\n      { path: &#39;password&#39;, component: PasswordSettingsComponent }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    CommonModule,\n    RouterModule.forChild(ROUTES)\n  ],\n})\nexport class SettingsModule {}\n\n// 父模块\nexport const ROUTES: Routes = [\n  {\n    path: &#39;settings&#39;,\n    loadChildren: &#39;./settings/settings.module#SettingsModule&#39;\n  }\n];\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n  // ...\n})\nexport class AppModule {}\n</code></pre>\n<ul>\n<li>Router Directives<br><code>routerLink</code>: 跳转指令<pre><code class=\"html\">&lt;a routerLink=&quot;/&quot;&gt;Home&lt;/a&gt;\n</code></pre>\n</li>\n<li>路由跳转<pre><code class=\"ts\">this.router.navigate([&#39;/profile&#39;, event.name]);\n</code></pre>\n</li>\n</ul>\n<h3 id=\"NgModule\"><a href=\"#NgModule\" class=\"headerlink\" title=\"NgModule\"></a>NgModule</h3><p>@NgModule接收一个用来描述模块属性的元数据对象</p>\n<ul>\n<li><code>declarations</code>:  声明本模块中的视图类</li>\n<li><code>exports</code>: declarations 的子集，可用于其它模块的组件模板</li>\n<li><code>imports</code>: 注册其他模块</li>\n<li><code>providers</code>: 添加全局服务</li>\n<li><code>bootstrap</code>: 根组件</li>\n</ul>\n<h3 id=\"Directive\"><a href=\"#Directive\" class=\"headerlink\" title=\"Directive\"></a>Directive</h3><ul>\n<li><code>Component directive</code>: 构建UI组件，继承于Directive类</li>\n<li><code>Attribute directive</code>: 改变组件的外观或行为</li>\n<li><code>Structural directive</code>: 动态添加或删除DOM元素来改变DOM布局</li>\n</ul>\n<h4 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h4><ul>\n<li><code>HostBinding</code>: 实现元素属性绑定</li>\n<li><code>Input</code>: 实现自定义元素属性输入</li>\n<li><code>HostListener</code>: 监听元素的事件</li>\n<li><code>Attribute</code>: 获取指令宿主元素上的自定义属性</li>\n</ul>\n<h4 id=\"ngFor-使用可迭代的每个项作为模板的上下文来重复模板\"><a href=\"#ngFor-使用可迭代的每个项作为模板的上下文来重复模板\" class=\"headerlink\" title=\"ngFor: 使用可迭代的每个项作为模板的上下文来重复模板\"></a>ngFor: 使用可迭代的每个项作为模板的上下文来重复模板</h4><p>首先更新mail服务，增加数组</p>\n<pre><code class=\"ts\">import { Injectable } from &#39;@angular/core&#39;;\n\n@Injectable()\nexport class MailService {\n  message: string = &#39;该消息来自MailService&#39;;\n  messages: string[] = [\n    &#39;天之骄子，加入修仙之路群&#39;,\n    &#39;Shadows，加入修仙之路群&#39;,\n    &#39;Keriy，加入修仙之路群&#39;\n  ]\n  constructor() { }\n}\n</code></pre>\n<p>更新组件模板</p>\n<pre><code class=\"html\">&lt;ul&gt;\n  &lt;li *ngFor=&quot;let message of mailService.messages; index as i;&quot;&gt;\n    {{i}} - {{message}}\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h4 id=\"ngIf-根据表达式的值，显示或移除元素\"><a href=\"#ngIf-根据表达式的值，显示或移除元素\" class=\"headerlink\" title=\"ngIf: 根据表达式的值，显示或移除元素\"></a>ngIf: 根据表达式的值，显示或移除元素</h4><pre><code class=\"html\">&lt;div *ngIf=&quot;SHOW&quot;&gt;show&lt;/div&gt;\n</code></pre>\n<h4 id=\"ngSwitch\"><a href=\"#ngSwitch\" class=\"headerlink\" title=\"ngSwitch\"></a>ngSwitch</h4><pre><code class=\"html\">&lt;ul [ngSwitch]=&#39;person.country&#39;&gt;\n  &lt;li *ngSwitchCase=&quot;&#39;UK&#39;&quot; class=&#39;text-success&#39;&gt;\n      {{ person.name }} ({{person.country}})\n  &lt;/li&gt;\n   &lt;li *ngSwitchCase=&quot;&#39;USA&#39;&quot; class=&#39;text-secondary&#39;&gt;\n      {{ person.name }} ({{person.country}})\n  &lt;/li&gt;\n  &lt;li *ngSwitchDefault class=&#39;text-primary&#39;&gt;\n    {{ person.name }} ({{person.country}})\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h3 id=\"Template-Driven-Forms\"><a href=\"#Template-Driven-Forms\" class=\"headerlink\" title=\"Template Driven Forms\"></a>Template Driven Forms</h3><h4 id=\"创建表单\"><a href=\"#创建表单\" class=\"headerlink\" title=\"创建表单\"></a>创建表单</h4><p>ng内嵌<code>validators</code>模块<br>使用<code>userName.valid</code>判断验证，<code>userName.errors</code>输出错误信息</p>\n<pre><code class=\"ts\">&lt;!--html模板  --&gt;\n&lt;input\n  type=&quot;text&quot;\n  required\n  minlength=&quot;3&quot;\n  [(ngModel)]=&quot;username&quot;\n  #userName=&quot;ngModel&quot;&gt;\n  {{userName.valid}}\n&lt;div *ngIf=&quot;userName.errors?.required&quot;&gt;请您输入用户名&lt;/div&gt;\n&lt;div *ngIf=&quot;userName.errors?.minlength&quot;&gt;\n  用户名的长度必须大于 {{userName.errors?.minlength.requiredLength}}，当前的长度为\n    {{userName.errors?.minlength.actualLength}}\n&lt;/div&gt;\n\n&lt;!--ts模块  --&gt;\nexport class AppComponent {\n  username = &#39;semlinker&#39;;\n}\n</code></pre>\n<h4 id=\"表单提交\"><a href=\"#表单提交\" class=\"headerlink\" title=\"表单提交\"></a>表单提交</h4><p>通过 <code>#loginForm=&quot;ngForm&quot;</code> 方式获取 <code>ngForm</code> 对象，然后通过 <code>loginForm.value</code> 来获取表单的值<br><!--html模板  --></p>\n<pre><code class=\"html\">&lt;form #loginForm=&quot;ngForm&quot; (ngSubmit)=&quot;onSubmit(loginForm.value)&quot;&gt;\n...\n&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>\n<!--绑定方法  -->\n<pre><code class=\"ts\">onSubmit(value) {\n    console.dir(value);\n  }\n</code></pre>\n<p>通过<code>ngModelGroup</code>指令对表单元素进行细化</p>\n<pre><code class=\"html\">&lt;form #loginForm=&quot;ngForm&quot; (ngSubmit)=&quot;onSubmit(loginForm.value)&quot;&gt;\n   &lt;fieldset ngModelGroup=&quot;user&quot;&gt;\n    &lt;input\n     type=&quot;text&quot;\n     required\n     minlength=&quot;3&quot;\n     name=&quot;username&quot;\n     [(ngModel)]=&quot;username&quot;\n     #userName=&quot;ngModel&quot;&gt;\n    &lt;hr&gt;\n    &lt;div *ngIf=&quot;userName.errors?.required&quot;&gt;请您输入用户名&lt;/div&gt;\n    &lt;div *ngIf=&quot;userName.errors?.minlength&quot;&gt;\n      用户名的长度必须大于 {{userName.errors?.minlength.requiredLength}}，当前的长度为\n        {{userName.errors?.minlength.actualLength}}\n    &lt;/div&gt;\n    &lt;input type=&quot;password&quot; ngModel name=&quot;password&quot;&gt;\n   &lt;/fieldset&gt;\n    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;\n    &lt;hr&gt;\n    {{loginForm.value | json}}\n  &lt;/form&gt;\n</code></pre>\n<h4 id=\"验证状态样式\"><a href=\"#验证状态样式\" class=\"headerlink\" title=\"验证状态样式\"></a>验证状态样式</h4><p>可以通过 <code>#userName=&quot;ngModel&quot;</code> 方式获取 <code>ngModel</code> 对象，进而通过<code>userName.dirty</code>获取控件的状态信息<br>css类</p>\n<pre><code class=\"css\">.input.ng-invalid {\n  border: 3px solid red;\n}\ninput.ng-valid {\n  border: 3px solid green;\n}\n</code></pre>\n<p>状态列表</p>\n<ul>\n<li><code>valid</code>: 表单控件有效</li>\n<li><code>invalid</code>: 表单控件无效</li>\n<li><code>pristine</code>: 表单控件值未改变</li>\n<li><code>dirty</code>: 表单控件值已改变</li>\n<li><code>touched</code>: 表单控件已被访问过</li>\n<li><code>untouched</code>: 表单控件未被访问过</li>\n</ul>\n<h4 id=\"单选多选\"><a href=\"#单选多选\" class=\"headerlink\" title=\"单选多选\"></a>单选多选</h4><pre><code class=\"html\">&lt;div *ngFor=&quot;let version of versions;&quot;&gt;\n  &lt;input\n    [attr.id]=&quot;version&quot;\n      name=&quot;version&quot;\n\n      required\n      [value]=&quot;version&quot;\n      type=&quot;radio&quot;&gt;\n    &lt;label [attr.for]=&quot;version&quot;&gt;{{version}}&lt;/label&gt;\n&lt;/div&gt;\n</code></pre>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>使用方便，适用于简单环境</li>\n<li>通过[(ngModel)]实现数据的双向绑定</li>\n<li>最小化组件类的代码</li>\n<li>不易于单元测试</li>\n</ul>\n<h3 id=\"Reactive-Form\"><a href=\"#Reactive-Form\" class=\"headerlink\" title=\"Reactive Form\"></a>Reactive Form</h3><p><code>FormControl</code>: 一个为单个表单控件提供支持的类，可用于跟踪控件的值和验证状态.</p>\n<pre><code class=\"ts\">ngOnInit() {\n  this.myControl = new FormControl(&#39;Semlinker&#39;);\n}\n</code></pre>\n<p><code>FormGroup</code>: 包含一组 FormControl 实例，可用于跟踪 FormControl 组的值和验证状态.<br><!--组件ts  --></p>\n<pre><code class=\"ts\">export class XunCsComponent implements OnInit {\n\nconstructor() {}\n  // tslint:disable-next-line:member-ordering\n  user: FormGroup;\n  ngOnInit() {\n    this.user = new FormGroup({\n      name: new FormControl(&#39;&#39;),\n      account: new FormGroup({\n        email: new FormControl(&#39;&#39;),\n        confirm: new FormControl(&#39;&#39;)\n      })\n    });\n  }\n  onSubmit() {\n    console.log(this.user.value, this.user.valid);\n  }\n}\n</code></pre>\n<!--组件模板  -->\n<pre><code class=\"html\">  &lt;form novalidate [formGroup]=&quot;user&quot;  (ngSubmit)=&quot;onSubmit(user)&quot; &gt;\n  &lt;label&gt;\n    &lt;span&gt;Full name&lt;/span&gt;\n    &lt;input\n      type=&quot;text&quot;\n      placeholder=&quot;Your full name&quot;\n      formControlName=&quot;name&quot;&gt;\n  &lt;/label&gt;\n  &lt;div formGroupName=&quot;account&quot;&gt;\n    &lt;label&gt;\n      &lt;span&gt;Email address&lt;/span&gt;\n      &lt;input\n        type=&quot;email&quot;\n        placeholder=&quot;Your email address&quot;\n        formControlName=&quot;email&quot;&gt;\n    &lt;/label&gt;\n    &lt;label&gt;\n      &lt;span&gt;Confirm address&lt;/span&gt;\n      &lt;input\n        type=&quot;email&quot;\n        placeholder=&quot;Confirm your email address&quot;\n        formControlName=&quot;confirm&quot;&gt;\n    &lt;/label&gt;\n  &lt;/div&gt;\n  &lt;button type=&quot;submit&quot;&gt;Sign up&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>\n<h4 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h4><p>通过<code>user.invalid</code>判断表单验证是否正确<br>通过<code>user.controls.name?.errors</code>获取错误原因</p>\n<pre><code class=\"ts\">this.user = new FormGroup({\n  name: new FormControl(&#39;&#39;, [Validators.required, Validators.minLength(2)]),\n  account: new FormGroup({\n    email: new FormControl(&#39;&#39;, Validators.required),\n    confirm: new FormControl(&#39;&#39;, Validators.required)\n  })\n});\n</code></pre>\n<h4 id=\"FormBuilder\"><a href=\"#FormBuilder\" class=\"headerlink\" title=\"FormBuilder\"></a>FormBuilder</h4><p>用来简化<code>FormGroup</code>+<code>FormControl</code>结合</p>\n<pre><code class=\"ts\">ngOnInit() {\n  this.user = this.fb.group({\n    name: [&#39;&#39;, [Validators.required, Validators.minLength(2)]],\n    account: this.fb.group({\n      email: [&#39;&#39;, Validators.required],\n      confirm: [&#39;&#39;, Validators.required]\n    })\n  });\n}\n</code></pre>\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>灵活，适用于复杂场景</li>\n<li>简化html模板代码，将验证逻辑抽离到组件类中</li>\n<li>方便跟踪表单控件值变化</li>\n<li>易于单元测试</li>\n</ul>\n<h3 id=\"动态加载已声明的组件\"><a href=\"#动态加载已声明的组件\" class=\"headerlink\" title=\"动态加载已声明的组件\"></a>动态加载已声明的组件</h3><ul>\n<li>定义组件</li>\n<li>创建组件容器<br><code>ViewChild</code>：一个属性装饰器，用来从模板视图中获取对应的元素，可以通过模板变量获取，获取时可以通过 read 属性设置查询的条件，就是说可以把此视图转为不同的实例<br><code>ViewContainerRef</code>： 个视图容器，可以在此上面创建、插入、删除组件等等<pre><code class=\"ts\"> @ViewChild(&quot;childContainer&quot;, { read: ViewContainerRef }) container: ViewContainerRef;\n</code></pre>\n</li>\n<li>动态创建组件<br><code>ComponentFactoryResolve</code>: 一个服务，动态加载组件的核心，这个服务可以将一个组件实例呈现到另一个组件视图上<br>通过调用<code>ComponentFactory</code>实例的<code>create()</code>创建组件<br>应用<code>ComponentFactoryResolver</code>服务的<code>resolveComponentFactory()</code>方法接受组件类，返回<code>ComponentFactory</code><br>在组件<code>constructor</code>注入该服务<pre><code class=\"ts\">constructor(private resolver: ComponentFactoryResolver) {}\n</code></pre>\n<pre><code class=\"ts\">createComponent(type: string) {\n  // 删除之前的视图\n  this.container.clear();\n  // 创建组件实例\n  const factory: ComponentFactory&lt;ActXunComponent&gt; = this.resolver.resolveComponentFactory(ActXunComponent);\n  // 将组件添加到容器当中\n  this.componentRef = this.container.createComponent(factory);\n  // 为组建复制\n  this.componentRef.instance.type = type;\n  // 订阅组件的输出属性\n  this.componentRef.instance.output.subscribe((msg: string) =&gt; console.log(msg));\n}\n</code></pre>\n销毁组件<pre><code class=\"ts\">ngOnDestroy() {\n  this.componentRef.destroy();\n}\n</code></pre>\n</li>\n<li>在<code>NgModule</code>的<code>entryComponents</code>属性中添加动态组件<pre><code class=\"ts\">@NgModule({\n...,\ndeclarations: [AppComponent, ActXunComponent],\nbootstrap: [AppComponent],\nentryComponents: [ActXunComponent],\n})\nexport class AppModule { }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"动态加载已声明的表单\"><a href=\"#动态加载已声明的表单\" class=\"headerlink\" title=\"动态加载已声明的表单\"></a>动态加载已声明的表单</h3><h3 id=\"Pipe-管道\"><a href=\"#Pipe-管道\" class=\"headerlink\" title=\"Pipe (管道)\"></a>Pipe (管道)</h3><p>过滤器，对输入的数据进行处理。</p>\n<h4 id=\"Ng内建管道\"><a href=\"#Ng内建管道\" class=\"headerlink\" title=\"Ng内建管道\"></a>Ng内建管道</h4><ul>\n<li><p>String =&gt; String</p>\n<ul>\n<li><p>UpperCasePipe（大写转换）</p>\n<pre><code class=\"html\">&lt;p&gt;{{'Angular' | uppercase}}&lt;/p&gt;\n&lt;span&gt;输出ANGULAR&lt;/span&gt;\n</code></pre>\n</li>\n<li><p>LowerCasePipe (小写转换)</p>\n<pre><code class=\"html\">&lt;p&gt;{{'Angular' | lowercase}}&lt;/p&gt;\n&lt;span&gt;输出angular&lt;/span&gt;\n</code></pre>\n</li>\n<li><p>TitleCasePipe (首字母大写)</p>\n<pre><code class=\"html\">&lt;p&gt;{{'angular' | titlecase}}&lt;/p&gt;\n&lt;span&gt;输出Angular&lt;/span&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Number =&gt; String</p>\n<ul>\n<li><p>DecimalPipe (数值格式化)</p>\n<pre><code class=\"html\">&lt;p&gt;{{expression | number[: digiInfo] }}&lt;/p&gt;\n&lt;p&gt;{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}&lt;/p&gt;\n&lt;p&gt;{{ 3.14159265 | number: '1.3-5' }}&lt;/p&gt;\n&lt;p&gt;输出3.14159&lt;/p&gt;\n</code></pre>\n</li>\n<li><p>PercentPipe （百分比格式化）</p>\n<pre><code class=\"html\">&lt;p&gt;{{expression | percent[: digiInfo] }}&lt;/p&gt;\n&lt;p&gt;{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}&lt;/p&gt;\n&lt;p&gt;{{ 1 | percent: '1.3-5' }}&lt;/p&gt;\n&lt;p&gt;输出100.000%&lt;/p&gt;\n</code></pre>\n</li>\n<li><p>CurrencyPipe (货币格式化)</p>\n<pre><code class=\"html\">&lt;p&gt;{{expression | currency[: currencyCode[: symbolDisplay[: digiInfo]]] }}&lt;/p&gt;\n&lt;p&gt;{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}&lt;/p&gt;\n&lt;p&gt;currencyCod是指货币代码，其值为ISO 4217标准，人民币CNY,美元USD,欧元 EUR.\nsymbolDisplay 是一个布尔值，true时显示货币符号($￥) false显示货币码&lt;/p&gt;\n&lt;p&gt;{{ 1 | currency: 'USD': true }}&lt;/p&gt;\n&lt;p&gt;输出100.000%&lt;/p&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Object =&gt; String</p>\n<ul>\n<li><p>JsonPipe (对象json化)</p>\n<pre><code class=\"html\">&lt;p&gt;{{ {name: 'xuncs'} | json}}&lt;/p&gt;\n&lt;p&gt;输出{ &quot;name&quot;: &quot;xuncs&quot; }&lt;/p&gt;\n</code></pre>\n</li>\n<li><p>DatePipe (日期格式化)</p>\n<pre><code class=\"html\">&lt;p&gt;{{ new Date() | date: 'shortTime' }}&lt;/p&gt;\n&lt;p&gt;语法：{{expression | date:format}}&lt;/p&gt;\n&lt;p&gt;\ny 年 y使用4位数字表示年份(2017),yy使用两位数字表示(17)\nM 月 M 1位或两位数字(2或10、11、12),MM 两位数字表示，前面补0(02)\nd 日 d 一位或两位数字(9) dd两位数字，前面补0(09)\nE 星期 EEE 三位字母缩写的星期 EEEE 星期全称\nj 12小时制时间 j (9 AM) jj (09 AM)\nh 12小时制小时 h(9) hh (09)\nH 24小时制小时 H(9) HH (09)\nm 分 m (5) mm (05)\ns 秒 s (1) ss (01)\nz 时区 z China Standard Time\n&lt;/p&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Tools (工具类)</p>\n<ul>\n<li>SlicePipe (数组或字符串取切割)<pre><code class=\"html\">&lt;p&gt;{{ 'xuncs' | slice:0:3 }}&lt;/p&gt;\n&lt;p&gt;输出：xun&lt;/p&gt;\n&lt;p&gt;语法：{{expression | slice: start [: end] }}&lt;/p&gt;\n</code></pre>\n</li>\n<li>AsyncPipe<br><code>Promise</code>: 返回单个值，不可取消<br><code>Observalbe</code>: 随着时间推移发出多个值，可以取消，支持<code>map</code>,<code>filter</code>,<code>reduce</code>等操作符，延迟执行</li>\n<li>I18nPluralPipe</li>\n<li>I18nSelectPipe</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"管道参数\"><a href=\"#管道参数\" class=\"headerlink\" title=\"管道参数\"></a>管道参数</h4><p>管道可以接收任意数量的参数。<br>用法: 参数之间用<code>:</code>隔开</p>\n<h4 id=\"管道链\"><a href=\"#管道链\" class=\"headerlink\" title=\"管道链\"></a>管道链</h4><p>将多个管道连接在一起，组成管道链对数据进行处理</p>\n<pre><code class=\"html\">&lt;p&gt;{{ 'angular' | slice:0:3 | uppercase }}&lt;/p&gt;\n&lt;p&gt;输出：ANG&lt;/p&gt;\n</code></pre>\n<h4 id=\"管道分类\"><a href=\"#管道分类\" class=\"headerlink\" title=\"管道分类\"></a>管道分类</h4><ul>\n<li><p>pure管道<br>仅当管道输入值变化的时候，才执行转换操作，默认的类型是 pure 类型。(备注：输入值变化是指原始数据类型如：string、number、boolean 等的数值或对象的引用值发生变化)</p>\n</li>\n<li><p>impure管道<br>在每次变化检测期间都会执行，如鼠标点击或移动都会执行 impure 管道</p>\n</li>\n</ul>\n<h4 id=\"自定义管道-Pipe\"><a href=\"#自定义管道-Pipe\" class=\"headerlink\" title=\"自定义管道 (@Pipe)\"></a>自定义管道 (@Pipe)</h4><ul>\n<li>使用 @Pipe 装饰器定义 Pipe 的 metadata 信息，如 Pipe 的名称 - 即 name 属性</li>\n<li>实现 PipeTransform 接口中定义的 transform 方法<pre><code>ng g p  &lt;Name&gt; --flat=false      // 新建管道\n</code></pre></li>\n</ul>\n<pre><code class=\"ts\">import { Pipe, PipeTransform } from &#39;@angular/core&#39;;\n\n@Pipe({\n  name: &#39;xunTest&#39;,\n  // 非纯管道\n  pure: false\n})\nexport class XunTestPipe implements PipeTransform {\n\n  transform(value: any, args?: any): any {\n    return null;\n  }\n\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Angular4入门\"><a href=\"#Angular4入门\" class=\"headerlink\" title=\"Angular4入门\"></a>Angular4入门</h2><h3 id=\"Angular-cli\"><a href=\"#Angular-cli\" class=\"headerlink\" title=\"Angular-cli\"></a>Angular-cli</h3><h4 id=\"全局安装\"><a href=\"#全局安装\" class=\"headerlink\" title=\"全局安装\"></a>全局安装</h4><pre><code class=\"shell\">sudo npm install @angular/cli -g\n\nng generate --help  // 查询帮助\n</code></pre>\n<h4 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h4><pre><code class=\"sh\">ng new &lt;ProjectName&gt;\n</code></pre>\n<p>相关配置</p>\n<pre><code class=\"sh\">--dry-run           // boolean, 默认为 false, 若设置 dry-run 则不会创建任何文件\n--verbose           // boolean, 默认为 false\n--link-cli          // boolean, 默认为 false, 自动链接到 @angular/cli 包\n--skip-install      // boolean, 默认为 false, 表示跳过 npm install\n--skip-git          // boolean, 默认为 false, 表示该目录不初始化为 git 仓库\n--skip-tests        // boolean, 默认为 false, 表示不创建 tests 相关文件\n--skip-commit       // boolean, 默认为 false, 表示不进行初始提交\n--directory         // string, 用于设置创建的目录名，默认与应用程序的同名\n--source-dir        // string, 默认为 &#39;src&#39;, 用于设置源文件目录的名称\n--style             // string, 默认为 &#39;css&#39;, 用于设置选用的样式语法 (&#39;css&#39;, &#39;less&#39; or &#39;scss&#39;)\n--prefix            // string, 默认为 &#39;app&#39;, 用于设置创建新组件时，组件选择器使用的前缀\n--mobile            // boolean, 默认为 false,表示是否生成 Progressive Web App 应用程序\n--routing           // boolean, 默认为 false, 表示新增带有路由信息的模块，并添加到根模块中\n--inline-style      // boolean, 默认为 false, 表示当创建新的应用程序时，使用内联样式\n--inline-template   // boolean, 默认为 false, 表示当创建新的应用程序时，使用内联模板\n</code></pre>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><pre><code class=\"sh\">cd &lt;ProjectName&gt;\nnpm start -o\nng serve  --open   // 主动打开浏览器窗口\n</code></pre>\n<pre><code class=\"sh\">ng g cl &lt;Name&gt; --spec            // 新建 class\nng g c  &lt;Name&gt;                   // 新建组件\nng g d  &lt;Name&gt;                   // 新建指令\nng g e  &lt;Name&gt;                   // 新建枚举\nng g m  &lt;Name&gt; --routing --spec  // 新建模块\nng g p  &lt;Name&gt; --flat=false      // 新建管道\nng g s  &lt;Name&gt; --flat=false       // 新建服务\n</code></pre>\n<h4 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h4><pre><code class=\"sh\">ng test\nnpm test\n</code></pre>\n<h4 id=\"e2e测试\"><a href=\"#e2e测试\" class=\"headerlink\" title=\"e2e测试\"></a>e2e测试</h4><pre><code class=\"sh\">ng e2e\n</code></pre>\n<h4 id=\"构建压缩代码并实施监控变化的应用程序\"><a href=\"#构建压缩代码并实施监控变化的应用程序\" class=\"headerlink\" title=\"构建压缩代码并实施监控变化的应用程序\"></a>构建压缩代码并实施监控变化的应用程序</h4><pre><code class=\"sh\">ng build --target=production --watch\n</code></pre>\n<h4 id=\"自定义构建webpack\"><a href=\"#自定义构建webpack\" class=\"headerlink\" title=\"自定义构建webpack\"></a>自定义构建webpack</h4><pre><code class=\"sh\">ng eject\n</code></pre>\n<h3 id=\"实际开发\"><a href=\"#实际开发\" class=\"headerlink\" title=\"实际开发\"></a>实际开发</h3><h4 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h4><pre><code class=\"html\">&lt;!--xun-com.component.html  --&gt;\n&lt;span&gt;{{title}}&lt;/span&gt;\n&lt;!--dom绑定  --&gt;\n&lt;input #myInput type=&quot;text&quot;&gt;\n&lt;!--鼠标事件  --&gt;\n&lt;button (click)=&quot;onClick($event, myInput.value)&quot;&gt;鼠标点击事件&lt;/button&gt;\n&lt;!--键盘事件  --&gt;\n&lt;input #keyBoard type=&quot;text&quot; (keydown.enter)=&quot;onEnter($event, keyBoard.value)&quot;&gt;\n</code></pre>\n<pre><code class=\"ts\">&lt;!--xun-com.component.ts  --&gt;\nimport { Component, OnInit } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-xun-com&#39;,\n  templateUrl: &#39;./xun-com.component.html&#39;,\n  styleUrls: [&#39;./xun-com.component.css&#39;]\n})\nexport class XunComComponent implements OnInit {\n  title: string;\n  constructor() {\n    this.title = &#39;title&#39;\n  }\n\n  ngOnInit() {\n  }\n  // 事件方法\n  onClick(event, val) {\n    console.log(event)\n    console.log(val)\n  }\n  onEnter(event, val) {\n    console.log(event)\n    console.log(val)\n  }\n\n}\n</code></pre>\n<h4 id=\"新建服务\"><a href=\"#新建服务\" class=\"headerlink\" title=\"新建服务\"></a>新建服务</h4><pre><code class=\"sh\">ng g s mail\n\n// 输出\ninstalling service\n  create src/app/mail.service.spec.ts     // 用于单元测试\n  create src/app/mail.service.ts          // 新建的服务\n  WARNING Service is generated but not provided, it must be provided to be used\n</code></pre>\n<h4 id=\"配置服务\"><a href=\"#配置服务\" class=\"headerlink\" title=\"配置服务\"></a>配置服务</h4><pre><code class=\"ts\">import { MailService } from &#39;./mail.service&#39;;\n\n@NgModule({\n\n  providers: [\n    MailService,\n    {provide: &#39;apiUrl&#39;, useValue: &#39;https://jsonplaceholder.typicode.com/&#39;}\n  ],     // 注入服务  \n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n</code></pre>\n<h4 id=\"更新服务\"><a href=\"#更新服务\" class=\"headerlink\" title=\"更新服务\"></a>更新服务</h4><pre><code class=\"ts\">import { Injectable } from &#39;@angular/core&#39;;\n\n@Injectable()\nexport class MailService {\n  message: string  =&#39;该消息来自MailService&#39;;\n  constructor() { }\n}\n</code></pre>\n<h4 id=\"使用服务\"><a href=\"#使用服务\" class=\"headerlink\" title=\"使用服务\"></a>使用服务</h4><pre><code class=\"ts\">&lt;!--xun-com.component.ts  --&gt;\nimport { MailService } from &#39;../mail.service&#39;;\n...\nexport class AppComponent {\n\n  constructor(private mailService: MailService) {}\n  constructor(\n    @Inject(MailService) private mailService,\n    @Inject(&#39;apiUrl&#39;) private apiUrl) {}\n  &lt;!--二选其一  --&gt;\n  &lt;!-- 不过对于 Type 类型(函数类型) 的对象，我们一般使用 constructor(private mailService: MailService) 方式进行注入。而 Inject 装饰器一般用来注入非 Type 类型的对象。 --&gt;\n}\n</code></pre>\n<pre><code class=\"html\">&lt;!--xun-com.component.html  --&gt;\n&lt;p&gt;{{mailService.message}}&lt;/p&gt;\n</code></pre>\n<h4 id=\"ngClass\"><a href=\"#ngClass\" class=\"headerlink\" title=\"ngClass\"></a>ngClass</h4><pre><code class=\"html\">&lt;div [ngClass]=&quot;{mousedown: isMousedown}&quot;&gt;&lt;/div&gt;\n</code></pre>\n<h4 id=\"ngStyle\"><a href=\"#ngStyle\" class=\"headerlink\" title=\"ngStyle\"></a>ngStyle</h4><pre><code class=\"html\">&lt;!--font-size支持px % em  --&gt;\n&lt;div&gt;\n   &lt;span [ngStyle]=&quot;{color: &#39;red&#39;}&quot; [style.font-size.px]=&quot;fontSize&quot; [style.background-color=&quot;&#39;red&#39;&quot;]&gt;\n      Red Text\n   &lt;/span&gt;\n&lt;/div&gt;\n</code></pre>\n<h4 id=\"ngModel\"><a href=\"#ngModel\" class=\"headerlink\" title=\"ngModel\"></a>ngModel</h4><ul>\n<li>单独使用ngModel<br>需要给表单元素添加<code>name</code>，为<code>ngForm.value</code>对象添加<code>property</code><pre><code class=\"html\">&lt;input type=&#39;text&#39; name=&#39;userName&#39; placeholder=&#39;Input your userName&#39; ngModel&gt;\n</code></pre>\n</li>\n<li><p>单向绑定[ngModel]<br>将this.name 初始化绑定到<code>ngForm.value</code>上</p>\n<pre><code class=\"html\">&lt;input type=&#39;text&#39; name=&#39;userName&#39; placeholder=&#39;Input your userName&#39; [ngModel]=&quot;name&quot; /&gt;\n</code></pre>\n</li>\n<li><p>双向绑定[(ngModel)]</p>\n<pre><code class=\"ts\">&lt;!--module中  --&gt;\nimport {FormsModule} from &#39;@angular/forms&#39;;\n...\nimports: [\n  ...\n  FormsModule\n],\n&lt;!--组件中  --&gt;\nthis.inputValue = &#39;inputvalue&#39;\n&lt;!--模板中  --&gt;\n&lt;input #myInput type=&quot;text&quot; [(ngModel)]=&quot;inputValue&quot;&gt;\n</code></pre>\n</li>\n</ul>\n<h4 id=\"Input\"><a href=\"#Input\" class=\"headerlink\" title=\"@Input\"></a>@Input</h4><p>相当于props 父组件==&gt;子组件</p>\n<pre><code class=\"ts\">&lt;!--子组件 xun-com.component  --&gt;\nimport { ..., Input } from &#39;@angular/core&#39;;\n...\nexport class XunComComponent implements OnInit {\n\n  @Input() msg: string;\n}\n\n&lt;!--父组件 app.component  --&gt;\nexport class AppComponent {\n  msg = {\n    data: &#39;数据&#39;\n  };\n}\n</code></pre>\n<pre><code class=\"html\">&lt;!--父模板 app.component  --&gt;\n&lt;app-xun-com [msg]=&quot;msg&quot;&gt;&lt;/app-xun-com&gt;\n\n&lt;!--子模板 xun-com.component --&gt;\n&lt;span&gt;msg: {{msg.data}}&lt;/span&gt;\n</code></pre>\n<h4 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"@Output\"></a>@Output</h4><p>Output装饰器:  让子组件将信息通过事件的方式返回给父组件</p>\n<pre><code class=\"ts\">&lt;!--子组件  --&gt;\nimport {Output, EventEmitter } from &#39;@angular/core&#39;;\nexport class XunComComponent implements OnInit {\n  @Input() msg: string;\n  @Output() update = new EventEmitter&lt;{title: string}&gt;();\n  constructor() {\n    this.title = &#39;xun-com&#39;\n    }\n}\n&lt;!--子组件模板  --&gt;\n&lt;button (click)=&quot;update.emit(title)&quot;&gt;更新&lt;/button&gt;\n\n&lt;!--父组件  --&gt;\nexport class AppComponent {\n  constructor() {}\n  onUpdate(title) {\n    console.log(title)\n  }\n}\n&lt;!--父组件模板  --&gt;\n&lt;app-xun-com (update)=&quot;onUpdate(title)&quot;&gt;&lt;/app-xun-com&gt;\n</code></pre>\n<h4 id=\"http模块\"><a href=\"#http模块\" class=\"headerlink\" title=\"http模块\"></a>http模块</h4><pre><code class=\"ts\">&lt;!--导入模块 app.module.ts  --&gt;\n...\nimport { HttpModule } from &#39;@angular/http&#39;;\n...\n@NgModule({\n  imports: [BrowserModule, FormsModule, HttpModule],\n  declarations: [AppComponent, UserComponent],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n&lt;!--调用模块  --&gt;\nimport { Http } from &#39;@angular/http&#39;;\nimport &#39;rxjs/add/operator/map&#39;;\n...\nexport class MembersComponent implements OnInit {\n  members: Member[];\n\n  constructor(private http: Http) { } // (3)\n\n  ngOnInit() {\n    this.http.get(`api`) // (4)\n        .map(res =&gt; res.json()) // (5)\n        .subscribe(data =&gt; {\n           if (data) this.members = data; // (6)\n        });\n    }\n}\n</code></pre>\n<h4 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h4><ul>\n<li><code>RouterModule.forRoot()</code>: 在主模块中定义主要的路由信息</li>\n<li><code>RouterModule.forChild()</code>: 在子模块中定义路由信息</li>\n<li><code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>: 路由视图入口位置</li>\n<li>动态路由<pre><code class=\"ts\">// 配置文件\n{ path: &#39;/profile/:username&#39;, component: ProfileComponent }\n// 组件中\nimport { ActivatedRoute } from &#39;@angular/router&#39;;\n...\nexport class SettingsComponent implements OnInit {\nusername: string;\nconstructor(private route: ActivatedRoute) {}\nngOnInit() {\n  this.route.params.subscribe((params) =&gt; this.username = params.username);\n}\n}\n</code></pre>\n</li>\n<li>子路由 children</li>\n<li>loadChildren 从另一个模块中获取子路由</li>\n</ul>\n<pre><code class=\"ts\">// 子模块\nimport { NgModule } from &#39;@angular/core&#39;;\nimport { CommonModule } from &#39;@angular/common&#39;;\nimport { Routes, RouterModule } from &#39;@angular/router&#39;;\n\nexport const ROUTES: Routes = [\n  {\n    path: &#39;&#39;,\n    component: SettingsComponent,\n    children: [\n      { path: &#39;profile&#39;, component: ProfileSettingsComponent },\n      { path: &#39;password&#39;, component: PasswordSettingsComponent }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    CommonModule,\n    RouterModule.forChild(ROUTES)\n  ],\n})\nexport class SettingsModule {}\n\n// 父模块\nexport const ROUTES: Routes = [\n  {\n    path: &#39;settings&#39;,\n    loadChildren: &#39;./settings/settings.module#SettingsModule&#39;\n  }\n];\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n  // ...\n})\nexport class AppModule {}\n</code></pre>\n<ul>\n<li>Router Directives<br><code>routerLink</code>: 跳转指令<pre><code class=\"html\">&lt;a routerLink=&quot;/&quot;&gt;Home&lt;/a&gt;\n</code></pre>\n</li>\n<li>路由跳转<pre><code class=\"ts\">this.router.navigate([&#39;/profile&#39;, event.name]);\n</code></pre>\n</li>\n</ul>\n<h3 id=\"NgModule\"><a href=\"#NgModule\" class=\"headerlink\" title=\"NgModule\"></a>NgModule</h3><p>@NgModule接收一个用来描述模块属性的元数据对象</p>\n<ul>\n<li><code>declarations</code>:  声明本模块中的视图类</li>\n<li><code>exports</code>: declarations 的子集，可用于其它模块的组件模板</li>\n<li><code>imports</code>: 注册其他模块</li>\n<li><code>providers</code>: 添加全局服务</li>\n<li><code>bootstrap</code>: 根组件</li>\n</ul>\n<h3 id=\"Directive\"><a href=\"#Directive\" class=\"headerlink\" title=\"Directive\"></a>Directive</h3><ul>\n<li><code>Component directive</code>: 构建UI组件，继承于Directive类</li>\n<li><code>Attribute directive</code>: 改变组件的外观或行为</li>\n<li><code>Structural directive</code>: 动态添加或删除DOM元素来改变DOM布局</li>\n</ul>\n<h4 id=\"自定义指令\"><a href=\"#自定义指令\" class=\"headerlink\" title=\"自定义指令\"></a>自定义指令</h4><ul>\n<li><code>HostBinding</code>: 实现元素属性绑定</li>\n<li><code>Input</code>: 实现自定义元素属性输入</li>\n<li><code>HostListener</code>: 监听元素的事件</li>\n<li><code>Attribute</code>: 获取指令宿主元素上的自定义属性</li>\n</ul>\n<h4 id=\"ngFor-使用可迭代的每个项作为模板的上下文来重复模板\"><a href=\"#ngFor-使用可迭代的每个项作为模板的上下文来重复模板\" class=\"headerlink\" title=\"ngFor: 使用可迭代的每个项作为模板的上下文来重复模板\"></a>ngFor: 使用可迭代的每个项作为模板的上下文来重复模板</h4><p>首先更新mail服务，增加数组</p>\n<pre><code class=\"ts\">import { Injectable } from &#39;@angular/core&#39;;\n\n@Injectable()\nexport class MailService {\n  message: string = &#39;该消息来自MailService&#39;;\n  messages: string[] = [\n    &#39;天之骄子，加入修仙之路群&#39;,\n    &#39;Shadows，加入修仙之路群&#39;,\n    &#39;Keriy，加入修仙之路群&#39;\n  ]\n  constructor() { }\n}\n</code></pre>\n<p>更新组件模板</p>\n<pre><code class=\"html\">&lt;ul&gt;\n  &lt;li *ngFor=&quot;let message of mailService.messages; index as i;&quot;&gt;\n    {{i}} - {{message}}\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h4 id=\"ngIf-根据表达式的值，显示或移除元素\"><a href=\"#ngIf-根据表达式的值，显示或移除元素\" class=\"headerlink\" title=\"ngIf: 根据表达式的值，显示或移除元素\"></a>ngIf: 根据表达式的值，显示或移除元素</h4><pre><code class=\"html\">&lt;div *ngIf=&quot;SHOW&quot;&gt;show&lt;/div&gt;\n</code></pre>\n<h4 id=\"ngSwitch\"><a href=\"#ngSwitch\" class=\"headerlink\" title=\"ngSwitch\"></a>ngSwitch</h4><pre><code class=\"html\">&lt;ul [ngSwitch]=&#39;person.country&#39;&gt;\n  &lt;li *ngSwitchCase=&quot;&#39;UK&#39;&quot; class=&#39;text-success&#39;&gt;\n      {{ person.name }} ({{person.country}})\n  &lt;/li&gt;\n   &lt;li *ngSwitchCase=&quot;&#39;USA&#39;&quot; class=&#39;text-secondary&#39;&gt;\n      {{ person.name }} ({{person.country}})\n  &lt;/li&gt;\n  &lt;li *ngSwitchDefault class=&#39;text-primary&#39;&gt;\n    {{ person.name }} ({{person.country}})\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h3 id=\"Template-Driven-Forms\"><a href=\"#Template-Driven-Forms\" class=\"headerlink\" title=\"Template Driven Forms\"></a>Template Driven Forms</h3><h4 id=\"创建表单\"><a href=\"#创建表单\" class=\"headerlink\" title=\"创建表单\"></a>创建表单</h4><p>ng内嵌<code>validators</code>模块<br>使用<code>userName.valid</code>判断验证，<code>userName.errors</code>输出错误信息</p>\n<pre><code class=\"ts\">&lt;!--html模板  --&gt;\n&lt;input\n  type=&quot;text&quot;\n  required\n  minlength=&quot;3&quot;\n  [(ngModel)]=&quot;username&quot;\n  #userName=&quot;ngModel&quot;&gt;\n  {{userName.valid}}\n&lt;div *ngIf=&quot;userName.errors?.required&quot;&gt;请您输入用户名&lt;/div&gt;\n&lt;div *ngIf=&quot;userName.errors?.minlength&quot;&gt;\n  用户名的长度必须大于 {{userName.errors?.minlength.requiredLength}}，当前的长度为\n    {{userName.errors?.minlength.actualLength}}\n&lt;/div&gt;\n\n&lt;!--ts模块  --&gt;\nexport class AppComponent {\n  username = &#39;semlinker&#39;;\n}\n</code></pre>\n<h4 id=\"表单提交\"><a href=\"#表单提交\" class=\"headerlink\" title=\"表单提交\"></a>表单提交</h4><p>通过 <code>#loginForm=&quot;ngForm&quot;</code> 方式获取 <code>ngForm</code> 对象，然后通过 <code>loginForm.value</code> 来获取表单的值<br><!--html模板  --></p>\n<pre><code class=\"html\">&lt;form #loginForm=&quot;ngForm&quot; (ngSubmit)=&quot;onSubmit(loginForm.value)&quot;&gt;\n...\n&lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>\n<!--绑定方法  -->\n<pre><code class=\"ts\">onSubmit(value) {\n    console.dir(value);\n  }\n</code></pre>\n<p>通过<code>ngModelGroup</code>指令对表单元素进行细化</p>\n<pre><code class=\"html\">&lt;form #loginForm=&quot;ngForm&quot; (ngSubmit)=&quot;onSubmit(loginForm.value)&quot;&gt;\n   &lt;fieldset ngModelGroup=&quot;user&quot;&gt;\n    &lt;input\n     type=&quot;text&quot;\n     required\n     minlength=&quot;3&quot;\n     name=&quot;username&quot;\n     [(ngModel)]=&quot;username&quot;\n     #userName=&quot;ngModel&quot;&gt;\n    &lt;hr&gt;\n    &lt;div *ngIf=&quot;userName.errors?.required&quot;&gt;请您输入用户名&lt;/div&gt;\n    &lt;div *ngIf=&quot;userName.errors?.minlength&quot;&gt;\n      用户名的长度必须大于 {{userName.errors?.minlength.requiredLength}}，当前的长度为\n        {{userName.errors?.minlength.actualLength}}\n    &lt;/div&gt;\n    &lt;input type=&quot;password&quot; ngModel name=&quot;password&quot;&gt;\n   &lt;/fieldset&gt;\n    &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;\n    &lt;hr&gt;\n    {{loginForm.value | json}}\n  &lt;/form&gt;\n</code></pre>\n<h4 id=\"验证状态样式\"><a href=\"#验证状态样式\" class=\"headerlink\" title=\"验证状态样式\"></a>验证状态样式</h4><p>可以通过 <code>#userName=&quot;ngModel&quot;</code> 方式获取 <code>ngModel</code> 对象，进而通过<code>userName.dirty</code>获取控件的状态信息<br>css类</p>\n<pre><code class=\"css\">.input.ng-invalid {\n  border: 3px solid red;\n}\ninput.ng-valid {\n  border: 3px solid green;\n}\n</code></pre>\n<p>状态列表</p>\n<ul>\n<li><code>valid</code>: 表单控件有效</li>\n<li><code>invalid</code>: 表单控件无效</li>\n<li><code>pristine</code>: 表单控件值未改变</li>\n<li><code>dirty</code>: 表单控件值已改变</li>\n<li><code>touched</code>: 表单控件已被访问过</li>\n<li><code>untouched</code>: 表单控件未被访问过</li>\n</ul>\n<h4 id=\"单选多选\"><a href=\"#单选多选\" class=\"headerlink\" title=\"单选多选\"></a>单选多选</h4><pre><code class=\"html\">&lt;div *ngFor=&quot;let version of versions;&quot;&gt;\n  &lt;input\n    [attr.id]=&quot;version&quot;\n      name=&quot;version&quot;\n\n      required\n      [value]=&quot;version&quot;\n      type=&quot;radio&quot;&gt;\n    &lt;label [attr.for]=&quot;version&quot;&gt;{{version}}&lt;/label&gt;\n&lt;/div&gt;\n</code></pre>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>使用方便，适用于简单环境</li>\n<li>通过[(ngModel)]实现数据的双向绑定</li>\n<li>最小化组件类的代码</li>\n<li>不易于单元测试</li>\n</ul>\n<h3 id=\"Reactive-Form\"><a href=\"#Reactive-Form\" class=\"headerlink\" title=\"Reactive Form\"></a>Reactive Form</h3><p><code>FormControl</code>: 一个为单个表单控件提供支持的类，可用于跟踪控件的值和验证状态.</p>\n<pre><code class=\"ts\">ngOnInit() {\n  this.myControl = new FormControl(&#39;Semlinker&#39;);\n}\n</code></pre>\n<p><code>FormGroup</code>: 包含一组 FormControl 实例，可用于跟踪 FormControl 组的值和验证状态.<br><!--组件ts  --></p>\n<pre><code class=\"ts\">export class XunCsComponent implements OnInit {\n\nconstructor() {}\n  // tslint:disable-next-line:member-ordering\n  user: FormGroup;\n  ngOnInit() {\n    this.user = new FormGroup({\n      name: new FormControl(&#39;&#39;),\n      account: new FormGroup({\n        email: new FormControl(&#39;&#39;),\n        confirm: new FormControl(&#39;&#39;)\n      })\n    });\n  }\n  onSubmit() {\n    console.log(this.user.value, this.user.valid);\n  }\n}\n</code></pre>\n<!--组件模板  -->\n<pre><code class=\"html\">  &lt;form novalidate [formGroup]=&quot;user&quot;  (ngSubmit)=&quot;onSubmit(user)&quot; &gt;\n  &lt;label&gt;\n    &lt;span&gt;Full name&lt;/span&gt;\n    &lt;input\n      type=&quot;text&quot;\n      placeholder=&quot;Your full name&quot;\n      formControlName=&quot;name&quot;&gt;\n  &lt;/label&gt;\n  &lt;div formGroupName=&quot;account&quot;&gt;\n    &lt;label&gt;\n      &lt;span&gt;Email address&lt;/span&gt;\n      &lt;input\n        type=&quot;email&quot;\n        placeholder=&quot;Your email address&quot;\n        formControlName=&quot;email&quot;&gt;\n    &lt;/label&gt;\n    &lt;label&gt;\n      &lt;span&gt;Confirm address&lt;/span&gt;\n      &lt;input\n        type=&quot;email&quot;\n        placeholder=&quot;Confirm your email address&quot;\n        formControlName=&quot;confirm&quot;&gt;\n    &lt;/label&gt;\n  &lt;/div&gt;\n  &lt;button type=&quot;submit&quot;&gt;Sign up&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>\n<h4 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h4><p>通过<code>user.invalid</code>判断表单验证是否正确<br>通过<code>user.controls.name?.errors</code>获取错误原因</p>\n<pre><code class=\"ts\">this.user = new FormGroup({\n  name: new FormControl(&#39;&#39;, [Validators.required, Validators.minLength(2)]),\n  account: new FormGroup({\n    email: new FormControl(&#39;&#39;, Validators.required),\n    confirm: new FormControl(&#39;&#39;, Validators.required)\n  })\n});\n</code></pre>\n<h4 id=\"FormBuilder\"><a href=\"#FormBuilder\" class=\"headerlink\" title=\"FormBuilder\"></a>FormBuilder</h4><p>用来简化<code>FormGroup</code>+<code>FormControl</code>结合</p>\n<pre><code class=\"ts\">ngOnInit() {\n  this.user = this.fb.group({\n    name: [&#39;&#39;, [Validators.required, Validators.minLength(2)]],\n    account: this.fb.group({\n      email: [&#39;&#39;, Validators.required],\n      confirm: [&#39;&#39;, Validators.required]\n    })\n  });\n}\n</code></pre>\n<h4 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h4><ul>\n<li>灵活，适用于复杂场景</li>\n<li>简化html模板代码，将验证逻辑抽离到组件类中</li>\n<li>方便跟踪表单控件值变化</li>\n<li>易于单元测试</li>\n</ul>\n<h3 id=\"动态加载已声明的组件\"><a href=\"#动态加载已声明的组件\" class=\"headerlink\" title=\"动态加载已声明的组件\"></a>动态加载已声明的组件</h3><ul>\n<li>定义组件</li>\n<li>创建组件容器<br><code>ViewChild</code>：一个属性装饰器，用来从模板视图中获取对应的元素，可以通过模板变量获取，获取时可以通过 read 属性设置查询的条件，就是说可以把此视图转为不同的实例<br><code>ViewContainerRef</code>： 个视图容器，可以在此上面创建、插入、删除组件等等<pre><code class=\"ts\"> @ViewChild(&quot;childContainer&quot;, { read: ViewContainerRef }) container: ViewContainerRef;\n</code></pre>\n</li>\n<li>动态创建组件<br><code>ComponentFactoryResolve</code>: 一个服务，动态加载组件的核心，这个服务可以将一个组件实例呈现到另一个组件视图上<br>通过调用<code>ComponentFactory</code>实例的<code>create()</code>创建组件<br>应用<code>ComponentFactoryResolver</code>服务的<code>resolveComponentFactory()</code>方法接受组件类，返回<code>ComponentFactory</code><br>在组件<code>constructor</code>注入该服务<pre><code class=\"ts\">constructor(private resolver: ComponentFactoryResolver) {}\n</code></pre>\n<pre><code class=\"ts\">createComponent(type: string) {\n  // 删除之前的视图\n  this.container.clear();\n  // 创建组件实例\n  const factory: ComponentFactory&lt;ActXunComponent&gt; = this.resolver.resolveComponentFactory(ActXunComponent);\n  // 将组件添加到容器当中\n  this.componentRef = this.container.createComponent(factory);\n  // 为组建复制\n  this.componentRef.instance.type = type;\n  // 订阅组件的输出属性\n  this.componentRef.instance.output.subscribe((msg: string) =&gt; console.log(msg));\n}\n</code></pre>\n销毁组件<pre><code class=\"ts\">ngOnDestroy() {\n  this.componentRef.destroy();\n}\n</code></pre>\n</li>\n<li>在<code>NgModule</code>的<code>entryComponents</code>属性中添加动态组件<pre><code class=\"ts\">@NgModule({\n...,\ndeclarations: [AppComponent, ActXunComponent],\nbootstrap: [AppComponent],\nentryComponents: [ActXunComponent],\n})\nexport class AppModule { }\n</code></pre>\n</li>\n</ul>\n<h3 id=\"动态加载已声明的表单\"><a href=\"#动态加载已声明的表单\" class=\"headerlink\" title=\"动态加载已声明的表单\"></a>动态加载已声明的表单</h3><h3 id=\"Pipe-管道\"><a href=\"#Pipe-管道\" class=\"headerlink\" title=\"Pipe (管道)\"></a>Pipe (管道)</h3><p>过滤器，对输入的数据进行处理。</p>\n<h4 id=\"Ng内建管道\"><a href=\"#Ng内建管道\" class=\"headerlink\" title=\"Ng内建管道\"></a>Ng内建管道</h4><ul>\n<li><p>String =&gt; String</p>\n<ul>\n<li><p>UpperCasePipe（大写转换）</p>\n<pre><code class=\"html\">&lt;p&gt;{{'Angular' | uppercase}}&lt;/p&gt;\n&lt;span&gt;输出ANGULAR&lt;/span&gt;\n</code></pre>\n</li>\n<li><p>LowerCasePipe (小写转换)</p>\n<pre><code class=\"html\">&lt;p&gt;{{'Angular' | lowercase}}&lt;/p&gt;\n&lt;span&gt;输出angular&lt;/span&gt;\n</code></pre>\n</li>\n<li><p>TitleCasePipe (首字母大写)</p>\n<pre><code class=\"html\">&lt;p&gt;{{'angular' | titlecase}}&lt;/p&gt;\n&lt;span&gt;输出Angular&lt;/span&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Number =&gt; String</p>\n<ul>\n<li><p>DecimalPipe (数值格式化)</p>\n<pre><code class=\"html\">&lt;p&gt;{{expression | number[: digiInfo] }}&lt;/p&gt;\n&lt;p&gt;{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}&lt;/p&gt;\n&lt;p&gt;{{ 3.14159265 | number: '1.3-5' }}&lt;/p&gt;\n&lt;p&gt;输出3.14159&lt;/p&gt;\n</code></pre>\n</li>\n<li><p>PercentPipe （百分比格式化）</p>\n<pre><code class=\"html\">&lt;p&gt;{{expression | percent[: digiInfo] }}&lt;/p&gt;\n&lt;p&gt;{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}&lt;/p&gt;\n&lt;p&gt;{{ 1 | percent: '1.3-5' }}&lt;/p&gt;\n&lt;p&gt;输出100.000%&lt;/p&gt;\n</code></pre>\n</li>\n<li><p>CurrencyPipe (货币格式化)</p>\n<pre><code class=\"html\">&lt;p&gt;{{expression | currency[: currencyCode[: symbolDisplay[: digiInfo]]] }}&lt;/p&gt;\n&lt;p&gt;{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}&lt;/p&gt;\n&lt;p&gt;currencyCod是指货币代码，其值为ISO 4217标准，人民币CNY,美元USD,欧元 EUR.\nsymbolDisplay 是一个布尔值，true时显示货币符号($￥) false显示货币码&lt;/p&gt;\n&lt;p&gt;{{ 1 | currency: 'USD': true }}&lt;/p&gt;\n&lt;p&gt;输出100.000%&lt;/p&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Object =&gt; String</p>\n<ul>\n<li><p>JsonPipe (对象json化)</p>\n<pre><code class=\"html\">&lt;p&gt;{{ {name: 'xuncs'} | json}}&lt;/p&gt;\n&lt;p&gt;输出{ &quot;name&quot;: &quot;xuncs&quot; }&lt;/p&gt;\n</code></pre>\n</li>\n<li><p>DatePipe (日期格式化)</p>\n<pre><code class=\"html\">&lt;p&gt;{{ new Date() | date: 'shortTime' }}&lt;/p&gt;\n&lt;p&gt;语法：{{expression | date:format}}&lt;/p&gt;\n&lt;p&gt;\ny 年 y使用4位数字表示年份(2017),yy使用两位数字表示(17)\nM 月 M 1位或两位数字(2或10、11、12),MM 两位数字表示，前面补0(02)\nd 日 d 一位或两位数字(9) dd两位数字，前面补0(09)\nE 星期 EEE 三位字母缩写的星期 EEEE 星期全称\nj 12小时制时间 j (9 AM) jj (09 AM)\nh 12小时制小时 h(9) hh (09)\nH 24小时制小时 H(9) HH (09)\nm 分 m (5) mm (05)\ns 秒 s (1) ss (01)\nz 时区 z China Standard Time\n&lt;/p&gt;\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>Tools (工具类)</p>\n<ul>\n<li>SlicePipe (数组或字符串取切割)<pre><code class=\"html\">&lt;p&gt;{{ 'xuncs' | slice:0:3 }}&lt;/p&gt;\n&lt;p&gt;输出：xun&lt;/p&gt;\n&lt;p&gt;语法：{{expression | slice: start [: end] }}&lt;/p&gt;\n</code></pre>\n</li>\n<li>AsyncPipe<br><code>Promise</code>: 返回单个值，不可取消<br><code>Observalbe</code>: 随着时间推移发出多个值，可以取消，支持<code>map</code>,<code>filter</code>,<code>reduce</code>等操作符，延迟执行</li>\n<li>I18nPluralPipe</li>\n<li>I18nSelectPipe</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"管道参数\"><a href=\"#管道参数\" class=\"headerlink\" title=\"管道参数\"></a>管道参数</h4><p>管道可以接收任意数量的参数。<br>用法: 参数之间用<code>:</code>隔开</p>\n<h4 id=\"管道链\"><a href=\"#管道链\" class=\"headerlink\" title=\"管道链\"></a>管道链</h4><p>将多个管道连接在一起，组成管道链对数据进行处理</p>\n<pre><code class=\"html\">&lt;p&gt;{{ 'angular' | slice:0:3 | uppercase }}&lt;/p&gt;\n&lt;p&gt;输出：ANG&lt;/p&gt;\n</code></pre>\n<h4 id=\"管道分类\"><a href=\"#管道分类\" class=\"headerlink\" title=\"管道分类\"></a>管道分类</h4><ul>\n<li><p>pure管道<br>仅当管道输入值变化的时候，才执行转换操作，默认的类型是 pure 类型。(备注：输入值变化是指原始数据类型如：string、number、boolean 等的数值或对象的引用值发生变化)</p>\n</li>\n<li><p>impure管道<br>在每次变化检测期间都会执行，如鼠标点击或移动都会执行 impure 管道</p>\n</li>\n</ul>\n<h4 id=\"自定义管道-Pipe\"><a href=\"#自定义管道-Pipe\" class=\"headerlink\" title=\"自定义管道 (@Pipe)\"></a>自定义管道 (@Pipe)</h4><ul>\n<li>使用 @Pipe 装饰器定义 Pipe 的 metadata 信息，如 Pipe 的名称 - 即 name 属性</li>\n<li>实现 PipeTransform 接口中定义的 transform 方法<pre><code>ng g p  &lt;Name&gt; --flat=false      // 新建管道\n</code></pre></li>\n</ul>\n<pre><code class=\"ts\">import { Pipe, PipeTransform } from &#39;@angular/core&#39;;\n\n@Pipe({\n  name: &#39;xunTest&#39;,\n  // 非纯管道\n  pure: false\n})\nexport class XunTestPipe implements PipeTransform {\n\n  transform(value: any, args?: any): any {\n    return null;\n  }\n\n}\n</code></pre>\n"},{"title":"softwareEngineering","date":"2017-11-29T07:02:47.000Z","_content":"\n<!--more-->\n\n#### 软件的含义\n- 提供功能与性能的指令 / 计算机程序  的集合\n- 处理信息的数据逻辑\n- 按照商业逻辑处理\n- 产品文档\n\n#### 软件的特点\n- 表现形式： 逻辑性产品，复杂，无磨损，开发环境受限，成本高\n- 生产方式： 脑力，手工开发\n- 要求： 受计算机系统限制，涉及社会等因素\n\n#### 软件危机\n\n##### 表现\n- 开发成本/进度预估不准\n- 用户不满意\n- 质量差\n- 不可维护\n- 缺少文档\n- 成本过高\n- 开发速度过慢\n\n##### 原因\n- 客观：逻辑复杂，规模庞大\n- 主管：开发方式不正确，忽视需求分析/维护/写文档\n\n##### 解决途径\n- 按工程化的原则和方法组织软件开发工作\n\n#### 软件工程基本原理\n- 阶段性生命周期\n- 阶段评审\n- 产品控制\n- 现代程序设计架构\n- 结果清晰审查\n- 开发人员少而精\n- 不断迭代产品\n\n#####  研究内容\n- 软件开发技术\n- 软件工程管理\n\n##### 三要素\n- 方法\n- 工具\n- 过程\n\n##### 生命周期\n- 可行性分析与设计阶段\n- 需求分析阶段\n- 设计阶段\n- 实现阶段\n- 测试阶段\n- 运维阶段\n\n#### 软件过程\n指软件整个生命周期，从需求获取，需求分析，设计，实现，测试，发布和维护一个过程模型。\n\n##### 过程模型\n- 传统开发模型\n\t- 瀑布模型\n\t\t特征：一次性单向开发，质量保证，文档规范\n\t\t适合：需求明确的项目\n\t\t优点：质量保证，严格品控\n\t\t缺点：周期长，不灵活，难变动\n\t- 快速原型模型\n\t\t特征：快速构建，用户测试反馈，成本低\n\t\t适合：需求模糊的中小型软件\n\t\t优点：快速，符合用户预期\n\t\t缺点：难管理，变动大，架构规范\n- 演化开发模型\n\t- 增量模型\n\t\t特征：对功能以一系列增量的方式开发\n\t\t适合：小而可用的软件\n\t\t优点：灵活，降低风险，可持续开发\n\t- 螺旋模型\n\t\t特征：每个阶段都风险评估的快速原型模型\n\t\t适合：内部开发的大规模软件项目\n\t\t优点：减少过多测试或测试不足带来的风险，项目稳定\n\t\t一个周期：确定目标=>确定方案=>风险评估=>开发=>评估，计划\n- 喷泉模型\n\t特征：每个阶段相互重叠\n\t优点：提高效率，节省时间，适合面向对象\n\t缺点：不利于管理，规范，文档重要\n\n##### 开发方法\n- 面向过程的结构化方法\n\t优点：\n- 面向对象的开发方法\n\t= 对象+类+继承+消息\n\tOOA：分析对象，外部关联，内部结构\n\tOOD：归纳抽象类，规范接口\n\n#### 软件需求\n用户对目标软件在功能、行为、性能、设计约束等方面的期望\n\n##### 软件需求工程的必要性\n需求分析是介于系统分析和软件设计阶段之间的重要桥梁\n以系统规格说明和项目规划做基点，从软件的角度调整分析\n需求分析师软件设计实现测试维护的主要基础\n良好的需求分析有助于避免早起错误，提高效率，降低成本\n\n##### 需求分析的任务\n- 确定系统的功能需求\n- 数据分析\n- 定义逻辑模型\n- 适应需求变更\n\n##### 需求分析原则\n- 从用户的角度考虑\n- 以流程为主线\n- 注重复用\n- 划分需求优先级\n- 需求变更及时反馈\n\n##### 需求分析内容\n- 功能需求\n- 性能需求\n- 领域需求\n- 其他需求\n\n#### 结构化需求分析和建模\n- 核心：数据\n- 实体关系模型\n\t描述数据建模过程，刻画系统静态特征\n- 数据流图\n\t对功能，操作流程进行分解，完成功能建模\n- 状态转换图\n\t系统行为建模，通过外部事件触发\n\n##### 数据模型\n实体-联系图，描述数据对象间的关系\n\n##### 功能模型\n数据流图，描绘数据在软件中的变换逻辑过程\n\n##### 行为模型\n状态转换图，描绘系统通过各种行为模式在不同状态间转换的方式\n\n##### 建模目的\n- 使分析系统化\n- 模型是评审的焦点，是确定系统完整性，一致性，规格说明准确性的关键\n- 模型是设计的基础\n\n##### 建模的原因\n- 在建模中了解系统\n- 通过抽象降低复杂性\n- 有助于回忆细节\n- 有助于开发间，与用户交流\n- 提供开发维护文档\n\n##### 数据字典\n- 数据流\n- 数据流分量\n- 数据存储\n- 处理\n\n#### 软件设计\n\n##### 目的\n构造一个高内聚，高可靠性，高维护性，高效率的软件模型\n为提高软件质量做基础\n\n- 过程设计：状态转换图，控制规格说明，加工规格说明\n- 接口设计：数据流图\n- 体系结构设计：数据流图\n- 数据设计：数据词典，实体关系图\n\n##### 原则\n- 分而治之，模块化\n- 重用设计模式\n- 可跟踪性\n- 灵活性\n- 一致性\n\n\n##### 概要设计\n将软件需求转化为数据结构和软件的系统结构，确定模块间相互关系\n\n##### 详细设计设计\n通过结构细化得到数据结构与算法\n\n##### 总体设计过程\n- 设想供选择的方案\n- 选择合理方案\n- 推荐最佳方案\n- 功能分解\n\t- 结构设计 模块化组件化设计\n\t- 过程设计 模块处理过程\n- 设计软件结构\n- 数据库设计\n\n##### 设计原理\n- 抽象与逐步求精 \n\t控制复杂性\n- 模块化\n\t使程序获得智能化管理\n- 信息隐藏\n\t隐藏的信息只能通过暴露的接口访问\n\t提高模块独立性，减少维护的影响\n- 内聚度\n\t衡量一个模块内部各个元素彼此间的紧密程度\n\t- 7：偶然性内聚\n\t- 6：逻辑性内聚\n\t- 5：时间性内聚\n\t- 4：过程性内聚\n\t- 3：通信性内聚\n\t- 2：顺序性内聚\n\t- 1：功能性内聚\n- 耦合度\n\t衡量不同模块间相互依赖的紧密程度\n\t- 7：非直接耦合\n\t- 6：数据耦合\n\t- 5：特征耦合\n\t- 4：控制耦合\n\t- 3：外部耦合\n\t- 2：公共耦合\n\t- 1：内容耦合\n\n##### 启发式原则\n- 改进软件结构提高模块独立性\n- 模块规模适中\n- 深度、宽度、扇入和扇出适当\n- 模块的作用域应在控制域之内\n- 设计单入口单出口的模块，力争降低模块接口复杂度\n- 模块功能可预测\n\n#### 结构化设计方法\n\n##### 思想\n- 基于模块独立性和信息隐藏原则\n- 自顶向下，逐步求精\n- 分解与抽象结合\n- 应用结构化程序设计\n\n##### 面向数据流 SD\n- 确定信息流的类型\n- 划定流界\n- 将数据流图映射为程序结构\n- 提取层次控制结构\n- 通过设计复审和使用启发式策略进一步精化\n\n##### 变换分析法 迭代\n在数据流图中，数据流经过输入，系统变换，输出，完成数据分析。\n- 复审基本系统模型\n- 复审精化软件数据流图\n- 确定DFD特性，判断是变换流还是事务流\n- 划定输入流和输出流界限，孤立变换中心\n- 依次分解\n\n##### 事物分析法\n- 复审基本系统模型\n- 复审并精化软件数据流图\n- 确定数据流图特性\n- 指出事务中心，确认动作路径的数据流特性\n- 把数据流图映射为事务处理型的程序结构\n- 分解并精化石斛结构及动作路径\n- 使用启发式设计策略，精化程序结构雏形，改良软件质量\n\n##### 面向数据结构 DSSD\n- 确定数据结构特征\n- 用顺序/选择/重复三种基本形式表示数据\n- 把数据结构表示映射为软件的控制结构\n- 用与具体方法配套的设计指南进一步精化控制结构\n- 开发软件的过程性描述\n\n#### 软件实现及测试\n\n##### 程序设计语言分类\n- 机器语言\n- 汇编语言\n- 高级语言\n\n- 基础语言(BASIC,FORTRAN,COBOL,ALGOL)\n- 结构语言(PL/1,PASCAL,C．ADA)\n- 专用语言(FORTH,PROLOG,LISP)\n- 系统实现语言(C)\n- 静态高级语言(COBOL,FORTRAN)\n- 动态高级语言\n- 块结构高级语言(ALGOL,PASCAL)\n- 可视化编程语言(VB,VC,PB,BC,C++BUILDER) \n\n##### 编程语言特点\n- 心理学观点\n\t- 一致性\n\t- 多义性\n\t- 局限性\n\t- 易编码性\n\t- 可移植性\n\t- 可维护性\n\t- 配套开发工具\n- 工程观点\n\t- 易于把设计翻译为代码\n\t- 编译器效率\n\t- 源代码可移植性\n\t- 开发法工具可用性\n\t- 可维护性\n\n##### 编写风格要求\n- 节简化 提供简洁代码\n\t- 避免程序中不必要的动作和变量\n\t- 避免变量名重载\n\t- 减小程序体积\n\t- 提高运行速度\n\t- 避免模块冗杂\n\t- 避免全局变量副作用\n- 模块化 把代码划分为内聚度高，富有意义的功能块\n\t- 确保物理和逻辑功能密切想逛\n\t- 限定一个模块完成一个功能\n\t- 检查代码重复率\n- 简单化 去掉过分复制和不必要的矫揉造作\n\t- 采用简单的算法\n\t- 简单的数据结构\n\t- 对象命名一致性\n\t- 简化算术，逻辑表达式\n- 结构化 把程序的各个构建组织成一个有效的系统\n\t- 按标准化的次序说明数据\n\t- 按字母顺序说明对象名\n\t- 使用读者明了的结构化程序部件\n\t- 根据应用背景排列程序各部分\n\t- 不随意为效率而牺牲可读性\n\t- 让机器多做重复工作\n\t- 用公共函数调用代替重复出现的表达式\n\t- 检查参数传递情况\n\t- 检查多层嵌套循环\n\t- 坚持使用统一缩进规则\n\t- 只编写单入口单出口的代码\n- 文档化\n\t- 有效的使用注释\n\t- 使用含义鲜明的变量名\n\t- 协调使用程序块注释和程序行注释\n\t- 始终坚持写文档\n- 格式化 使程序布局合理清晰明了\n\t- 有效的使用编程空间\n\t- 适当插入括号 排出多义性\n\t- 有效使用空格\n\n##### 测试模型\n- V \n定义了软件测试如何与软件工程各阶段相融合，描述了各级别软件测试与软件开发各阶段的对应关系\n- W\n- H\n对W模型在更高层次上的线性抽象。在任何一个开发流程，只要有必要，且测试配置已准备就绪，即可进行测试活动\n\n\n##### 测试原则\n- 应尽早地和不断地进行测试\n- 开发人员应尽量避免参加测试\n- 注重测试用例的设计和选择\n- 增量式测试\n- 充分注意测试的群集现象\n- 合理安排测试计划，严格执行测试计划\n- 全面统计和分析测试结果\n- 保存测试文档，并及时更新\n\n##### 白盒测试\n","source":"_posts/softwareEngineering.md","raw":"---\ntitle: softwareEngineering\ndate: 2017-11-29 15:02:47\ntags:\n---\n\n<!--more-->\n\n#### 软件的含义\n- 提供功能与性能的指令 / 计算机程序  的集合\n- 处理信息的数据逻辑\n- 按照商业逻辑处理\n- 产品文档\n\n#### 软件的特点\n- 表现形式： 逻辑性产品，复杂，无磨损，开发环境受限，成本高\n- 生产方式： 脑力，手工开发\n- 要求： 受计算机系统限制，涉及社会等因素\n\n#### 软件危机\n\n##### 表现\n- 开发成本/进度预估不准\n- 用户不满意\n- 质量差\n- 不可维护\n- 缺少文档\n- 成本过高\n- 开发速度过慢\n\n##### 原因\n- 客观：逻辑复杂，规模庞大\n- 主管：开发方式不正确，忽视需求分析/维护/写文档\n\n##### 解决途径\n- 按工程化的原则和方法组织软件开发工作\n\n#### 软件工程基本原理\n- 阶段性生命周期\n- 阶段评审\n- 产品控制\n- 现代程序设计架构\n- 结果清晰审查\n- 开发人员少而精\n- 不断迭代产品\n\n#####  研究内容\n- 软件开发技术\n- 软件工程管理\n\n##### 三要素\n- 方法\n- 工具\n- 过程\n\n##### 生命周期\n- 可行性分析与设计阶段\n- 需求分析阶段\n- 设计阶段\n- 实现阶段\n- 测试阶段\n- 运维阶段\n\n#### 软件过程\n指软件整个生命周期，从需求获取，需求分析，设计，实现，测试，发布和维护一个过程模型。\n\n##### 过程模型\n- 传统开发模型\n\t- 瀑布模型\n\t\t特征：一次性单向开发，质量保证，文档规范\n\t\t适合：需求明确的项目\n\t\t优点：质量保证，严格品控\n\t\t缺点：周期长，不灵活，难变动\n\t- 快速原型模型\n\t\t特征：快速构建，用户测试反馈，成本低\n\t\t适合：需求模糊的中小型软件\n\t\t优点：快速，符合用户预期\n\t\t缺点：难管理，变动大，架构规范\n- 演化开发模型\n\t- 增量模型\n\t\t特征：对功能以一系列增量的方式开发\n\t\t适合：小而可用的软件\n\t\t优点：灵活，降低风险，可持续开发\n\t- 螺旋模型\n\t\t特征：每个阶段都风险评估的快速原型模型\n\t\t适合：内部开发的大规模软件项目\n\t\t优点：减少过多测试或测试不足带来的风险，项目稳定\n\t\t一个周期：确定目标=>确定方案=>风险评估=>开发=>评估，计划\n- 喷泉模型\n\t特征：每个阶段相互重叠\n\t优点：提高效率，节省时间，适合面向对象\n\t缺点：不利于管理，规范，文档重要\n\n##### 开发方法\n- 面向过程的结构化方法\n\t优点：\n- 面向对象的开发方法\n\t= 对象+类+继承+消息\n\tOOA：分析对象，外部关联，内部结构\n\tOOD：归纳抽象类，规范接口\n\n#### 软件需求\n用户对目标软件在功能、行为、性能、设计约束等方面的期望\n\n##### 软件需求工程的必要性\n需求分析是介于系统分析和软件设计阶段之间的重要桥梁\n以系统规格说明和项目规划做基点，从软件的角度调整分析\n需求分析师软件设计实现测试维护的主要基础\n良好的需求分析有助于避免早起错误，提高效率，降低成本\n\n##### 需求分析的任务\n- 确定系统的功能需求\n- 数据分析\n- 定义逻辑模型\n- 适应需求变更\n\n##### 需求分析原则\n- 从用户的角度考虑\n- 以流程为主线\n- 注重复用\n- 划分需求优先级\n- 需求变更及时反馈\n\n##### 需求分析内容\n- 功能需求\n- 性能需求\n- 领域需求\n- 其他需求\n\n#### 结构化需求分析和建模\n- 核心：数据\n- 实体关系模型\n\t描述数据建模过程，刻画系统静态特征\n- 数据流图\n\t对功能，操作流程进行分解，完成功能建模\n- 状态转换图\n\t系统行为建模，通过外部事件触发\n\n##### 数据模型\n实体-联系图，描述数据对象间的关系\n\n##### 功能模型\n数据流图，描绘数据在软件中的变换逻辑过程\n\n##### 行为模型\n状态转换图，描绘系统通过各种行为模式在不同状态间转换的方式\n\n##### 建模目的\n- 使分析系统化\n- 模型是评审的焦点，是确定系统完整性，一致性，规格说明准确性的关键\n- 模型是设计的基础\n\n##### 建模的原因\n- 在建模中了解系统\n- 通过抽象降低复杂性\n- 有助于回忆细节\n- 有助于开发间，与用户交流\n- 提供开发维护文档\n\n##### 数据字典\n- 数据流\n- 数据流分量\n- 数据存储\n- 处理\n\n#### 软件设计\n\n##### 目的\n构造一个高内聚，高可靠性，高维护性，高效率的软件模型\n为提高软件质量做基础\n\n- 过程设计：状态转换图，控制规格说明，加工规格说明\n- 接口设计：数据流图\n- 体系结构设计：数据流图\n- 数据设计：数据词典，实体关系图\n\n##### 原则\n- 分而治之，模块化\n- 重用设计模式\n- 可跟踪性\n- 灵活性\n- 一致性\n\n\n##### 概要设计\n将软件需求转化为数据结构和软件的系统结构，确定模块间相互关系\n\n##### 详细设计设计\n通过结构细化得到数据结构与算法\n\n##### 总体设计过程\n- 设想供选择的方案\n- 选择合理方案\n- 推荐最佳方案\n- 功能分解\n\t- 结构设计 模块化组件化设计\n\t- 过程设计 模块处理过程\n- 设计软件结构\n- 数据库设计\n\n##### 设计原理\n- 抽象与逐步求精 \n\t控制复杂性\n- 模块化\n\t使程序获得智能化管理\n- 信息隐藏\n\t隐藏的信息只能通过暴露的接口访问\n\t提高模块独立性，减少维护的影响\n- 内聚度\n\t衡量一个模块内部各个元素彼此间的紧密程度\n\t- 7：偶然性内聚\n\t- 6：逻辑性内聚\n\t- 5：时间性内聚\n\t- 4：过程性内聚\n\t- 3：通信性内聚\n\t- 2：顺序性内聚\n\t- 1：功能性内聚\n- 耦合度\n\t衡量不同模块间相互依赖的紧密程度\n\t- 7：非直接耦合\n\t- 6：数据耦合\n\t- 5：特征耦合\n\t- 4：控制耦合\n\t- 3：外部耦合\n\t- 2：公共耦合\n\t- 1：内容耦合\n\n##### 启发式原则\n- 改进软件结构提高模块独立性\n- 模块规模适中\n- 深度、宽度、扇入和扇出适当\n- 模块的作用域应在控制域之内\n- 设计单入口单出口的模块，力争降低模块接口复杂度\n- 模块功能可预测\n\n#### 结构化设计方法\n\n##### 思想\n- 基于模块独立性和信息隐藏原则\n- 自顶向下，逐步求精\n- 分解与抽象结合\n- 应用结构化程序设计\n\n##### 面向数据流 SD\n- 确定信息流的类型\n- 划定流界\n- 将数据流图映射为程序结构\n- 提取层次控制结构\n- 通过设计复审和使用启发式策略进一步精化\n\n##### 变换分析法 迭代\n在数据流图中，数据流经过输入，系统变换，输出，完成数据分析。\n- 复审基本系统模型\n- 复审精化软件数据流图\n- 确定DFD特性，判断是变换流还是事务流\n- 划定输入流和输出流界限，孤立变换中心\n- 依次分解\n\n##### 事物分析法\n- 复审基本系统模型\n- 复审并精化软件数据流图\n- 确定数据流图特性\n- 指出事务中心，确认动作路径的数据流特性\n- 把数据流图映射为事务处理型的程序结构\n- 分解并精化石斛结构及动作路径\n- 使用启发式设计策略，精化程序结构雏形，改良软件质量\n\n##### 面向数据结构 DSSD\n- 确定数据结构特征\n- 用顺序/选择/重复三种基本形式表示数据\n- 把数据结构表示映射为软件的控制结构\n- 用与具体方法配套的设计指南进一步精化控制结构\n- 开发软件的过程性描述\n\n#### 软件实现及测试\n\n##### 程序设计语言分类\n- 机器语言\n- 汇编语言\n- 高级语言\n\n- 基础语言(BASIC,FORTRAN,COBOL,ALGOL)\n- 结构语言(PL/1,PASCAL,C．ADA)\n- 专用语言(FORTH,PROLOG,LISP)\n- 系统实现语言(C)\n- 静态高级语言(COBOL,FORTRAN)\n- 动态高级语言\n- 块结构高级语言(ALGOL,PASCAL)\n- 可视化编程语言(VB,VC,PB,BC,C++BUILDER) \n\n##### 编程语言特点\n- 心理学观点\n\t- 一致性\n\t- 多义性\n\t- 局限性\n\t- 易编码性\n\t- 可移植性\n\t- 可维护性\n\t- 配套开发工具\n- 工程观点\n\t- 易于把设计翻译为代码\n\t- 编译器效率\n\t- 源代码可移植性\n\t- 开发法工具可用性\n\t- 可维护性\n\n##### 编写风格要求\n- 节简化 提供简洁代码\n\t- 避免程序中不必要的动作和变量\n\t- 避免变量名重载\n\t- 减小程序体积\n\t- 提高运行速度\n\t- 避免模块冗杂\n\t- 避免全局变量副作用\n- 模块化 把代码划分为内聚度高，富有意义的功能块\n\t- 确保物理和逻辑功能密切想逛\n\t- 限定一个模块完成一个功能\n\t- 检查代码重复率\n- 简单化 去掉过分复制和不必要的矫揉造作\n\t- 采用简单的算法\n\t- 简单的数据结构\n\t- 对象命名一致性\n\t- 简化算术，逻辑表达式\n- 结构化 把程序的各个构建组织成一个有效的系统\n\t- 按标准化的次序说明数据\n\t- 按字母顺序说明对象名\n\t- 使用读者明了的结构化程序部件\n\t- 根据应用背景排列程序各部分\n\t- 不随意为效率而牺牲可读性\n\t- 让机器多做重复工作\n\t- 用公共函数调用代替重复出现的表达式\n\t- 检查参数传递情况\n\t- 检查多层嵌套循环\n\t- 坚持使用统一缩进规则\n\t- 只编写单入口单出口的代码\n- 文档化\n\t- 有效的使用注释\n\t- 使用含义鲜明的变量名\n\t- 协调使用程序块注释和程序行注释\n\t- 始终坚持写文档\n- 格式化 使程序布局合理清晰明了\n\t- 有效的使用编程空间\n\t- 适当插入括号 排出多义性\n\t- 有效使用空格\n\n##### 测试模型\n- V \n定义了软件测试如何与软件工程各阶段相融合，描述了各级别软件测试与软件开发各阶段的对应关系\n- W\n- H\n对W模型在更高层次上的线性抽象。在任何一个开发流程，只要有必要，且测试配置已准备就绪，即可进行测试活动\n\n\n##### 测试原则\n- 应尽早地和不断地进行测试\n- 开发人员应尽量避免参加测试\n- 注重测试用例的设计和选择\n- 增量式测试\n- 充分注意测试的群集现象\n- 合理安排测试计划，严格执行测试计划\n- 全面统计和分析测试结果\n- 保存测试文档，并及时更新\n\n##### 白盒测试\n","slug":"softwareEngineering","published":1,"updated":"2017-11-29T07:04:19.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2r000nttwp23l93pt3","content":"<a id=\"more\"></a>\n<h4 id=\"软件的含义\"><a href=\"#软件的含义\" class=\"headerlink\" title=\"软件的含义\"></a>软件的含义</h4><ul>\n<li>提供功能与性能的指令 / 计算机程序  的集合</li>\n<li>处理信息的数据逻辑</li>\n<li>按照商业逻辑处理</li>\n<li>产品文档</li>\n</ul>\n<h4 id=\"软件的特点\"><a href=\"#软件的特点\" class=\"headerlink\" title=\"软件的特点\"></a>软件的特点</h4><ul>\n<li>表现形式： 逻辑性产品，复杂，无磨损，开发环境受限，成本高</li>\n<li>生产方式： 脑力，手工开发</li>\n<li>要求： 受计算机系统限制，涉及社会等因素</li>\n</ul>\n<h4 id=\"软件危机\"><a href=\"#软件危机\" class=\"headerlink\" title=\"软件危机\"></a>软件危机</h4><h5 id=\"表现\"><a href=\"#表现\" class=\"headerlink\" title=\"表现\"></a>表现</h5><ul>\n<li>开发成本/进度预估不准</li>\n<li>用户不满意</li>\n<li>质量差</li>\n<li>不可维护</li>\n<li>缺少文档</li>\n<li>成本过高</li>\n<li>开发速度过慢</li>\n</ul>\n<h5 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h5><ul>\n<li>客观：逻辑复杂，规模庞大</li>\n<li>主管：开发方式不正确，忽视需求分析/维护/写文档</li>\n</ul>\n<h5 id=\"解决途径\"><a href=\"#解决途径\" class=\"headerlink\" title=\"解决途径\"></a>解决途径</h5><ul>\n<li>按工程化的原则和方法组织软件开发工作</li>\n</ul>\n<h4 id=\"软件工程基本原理\"><a href=\"#软件工程基本原理\" class=\"headerlink\" title=\"软件工程基本原理\"></a>软件工程基本原理</h4><ul>\n<li>阶段性生命周期</li>\n<li>阶段评审</li>\n<li>产品控制</li>\n<li>现代程序设计架构</li>\n<li>结果清晰审查</li>\n<li>开发人员少而精</li>\n<li>不断迭代产品</li>\n</ul>\n<h5 id=\"研究内容\"><a href=\"#研究内容\" class=\"headerlink\" title=\"研究内容\"></a>研究内容</h5><ul>\n<li>软件开发技术</li>\n<li>软件工程管理</li>\n</ul>\n<h5 id=\"三要素\"><a href=\"#三要素\" class=\"headerlink\" title=\"三要素\"></a>三要素</h5><ul>\n<li>方法</li>\n<li>工具</li>\n<li>过程</li>\n</ul>\n<h5 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h5><ul>\n<li>可行性分析与设计阶段</li>\n<li>需求分析阶段</li>\n<li>设计阶段</li>\n<li>实现阶段</li>\n<li>测试阶段</li>\n<li>运维阶段</li>\n</ul>\n<h4 id=\"软件过程\"><a href=\"#软件过程\" class=\"headerlink\" title=\"软件过程\"></a>软件过程</h4><p>指软件整个生命周期，从需求获取，需求分析，设计，实现，测试，发布和维护一个过程模型。</p>\n<h5 id=\"过程模型\"><a href=\"#过程模型\" class=\"headerlink\" title=\"过程模型\"></a>过程模型</h5><ul>\n<li>传统开发模型<ul>\n<li>瀑布模型<br>  特征：一次性单向开发，质量保证，文档规范<br>  适合：需求明确的项目<br>  优点：质量保证，严格品控<br>  缺点：周期长，不灵活，难变动</li>\n<li>快速原型模型<br>  特征：快速构建，用户测试反馈，成本低<br>  适合：需求模糊的中小型软件<br>  优点：快速，符合用户预期<br>  缺点：难管理，变动大，架构规范</li>\n</ul>\n</li>\n<li>演化开发模型<ul>\n<li>增量模型<br>  特征：对功能以一系列增量的方式开发<br>  适合：小而可用的软件<br>  优点：灵活，降低风险，可持续开发</li>\n<li>螺旋模型<br>  特征：每个阶段都风险评估的快速原型模型<br>  适合：内部开发的大规模软件项目<br>  优点：减少过多测试或测试不足带来的风险，项目稳定<br>  一个周期：确定目标=&gt;确定方案=&gt;风险评估=&gt;开发=&gt;评估，计划</li>\n</ul>\n</li>\n<li>喷泉模型<br>  特征：每个阶段相互重叠<br>  优点：提高效率，节省时间，适合面向对象<br>  缺点：不利于管理，规范，文档重要</li>\n</ul>\n<h5 id=\"开发方法\"><a href=\"#开发方法\" class=\"headerlink\" title=\"开发方法\"></a>开发方法</h5><ul>\n<li>面向过程的结构化方法<br>  优点：</li>\n<li>面向对象的开发方法<br>  = 对象+类+继承+消息<br>  OOA：分析对象，外部关联，内部结构<br>  OOD：归纳抽象类，规范接口</li>\n</ul>\n<h4 id=\"软件需求\"><a href=\"#软件需求\" class=\"headerlink\" title=\"软件需求\"></a>软件需求</h4><p>用户对目标软件在功能、行为、性能、设计约束等方面的期望</p>\n<h5 id=\"软件需求工程的必要性\"><a href=\"#软件需求工程的必要性\" class=\"headerlink\" title=\"软件需求工程的必要性\"></a>软件需求工程的必要性</h5><p>需求分析是介于系统分析和软件设计阶段之间的重要桥梁<br>以系统规格说明和项目规划做基点，从软件的角度调整分析<br>需求分析师软件设计实现测试维护的主要基础<br>良好的需求分析有助于避免早起错误，提高效率，降低成本</p>\n<h5 id=\"需求分析的任务\"><a href=\"#需求分析的任务\" class=\"headerlink\" title=\"需求分析的任务\"></a>需求分析的任务</h5><ul>\n<li>确定系统的功能需求</li>\n<li>数据分析</li>\n<li>定义逻辑模型</li>\n<li>适应需求变更</li>\n</ul>\n<h5 id=\"需求分析原则\"><a href=\"#需求分析原则\" class=\"headerlink\" title=\"需求分析原则\"></a>需求分析原则</h5><ul>\n<li>从用户的角度考虑</li>\n<li>以流程为主线</li>\n<li>注重复用</li>\n<li>划分需求优先级</li>\n<li>需求变更及时反馈</li>\n</ul>\n<h5 id=\"需求分析内容\"><a href=\"#需求分析内容\" class=\"headerlink\" title=\"需求分析内容\"></a>需求分析内容</h5><ul>\n<li>功能需求</li>\n<li>性能需求</li>\n<li>领域需求</li>\n<li>其他需求</li>\n</ul>\n<h4 id=\"结构化需求分析和建模\"><a href=\"#结构化需求分析和建模\" class=\"headerlink\" title=\"结构化需求分析和建模\"></a>结构化需求分析和建模</h4><ul>\n<li>核心：数据</li>\n<li>实体关系模型<br>  描述数据建模过程，刻画系统静态特征</li>\n<li>数据流图<br>  对功能，操作流程进行分解，完成功能建模</li>\n<li>状态转换图<br>  系统行为建模，通过外部事件触发</li>\n</ul>\n<h5 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h5><p>实体-联系图，描述数据对象间的关系</p>\n<h5 id=\"功能模型\"><a href=\"#功能模型\" class=\"headerlink\" title=\"功能模型\"></a>功能模型</h5><p>数据流图，描绘数据在软件中的变换逻辑过程</p>\n<h5 id=\"行为模型\"><a href=\"#行为模型\" class=\"headerlink\" title=\"行为模型\"></a>行为模型</h5><p>状态转换图，描绘系统通过各种行为模式在不同状态间转换的方式</p>\n<h5 id=\"建模目的\"><a href=\"#建模目的\" class=\"headerlink\" title=\"建模目的\"></a>建模目的</h5><ul>\n<li>使分析系统化</li>\n<li>模型是评审的焦点，是确定系统完整性，一致性，规格说明准确性的关键</li>\n<li>模型是设计的基础</li>\n</ul>\n<h5 id=\"建模的原因\"><a href=\"#建模的原因\" class=\"headerlink\" title=\"建模的原因\"></a>建模的原因</h5><ul>\n<li>在建模中了解系统</li>\n<li>通过抽象降低复杂性</li>\n<li>有助于回忆细节</li>\n<li>有助于开发间，与用户交流</li>\n<li>提供开发维护文档</li>\n</ul>\n<h5 id=\"数据字典\"><a href=\"#数据字典\" class=\"headerlink\" title=\"数据字典\"></a>数据字典</h5><ul>\n<li>数据流</li>\n<li>数据流分量</li>\n<li>数据存储</li>\n<li>处理</li>\n</ul>\n<h4 id=\"软件设计\"><a href=\"#软件设计\" class=\"headerlink\" title=\"软件设计\"></a>软件设计</h4><h5 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h5><p>构造一个高内聚，高可靠性，高维护性，高效率的软件模型<br>为提高软件质量做基础</p>\n<ul>\n<li>过程设计：状态转换图，控制规格说明，加工规格说明</li>\n<li>接口设计：数据流图</li>\n<li>体系结构设计：数据流图</li>\n<li>数据设计：数据词典，实体关系图</li>\n</ul>\n<h5 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h5><ul>\n<li>分而治之，模块化</li>\n<li>重用设计模式</li>\n<li>可跟踪性</li>\n<li>灵活性</li>\n<li>一致性</li>\n</ul>\n<h5 id=\"概要设计\"><a href=\"#概要设计\" class=\"headerlink\" title=\"概要设计\"></a>概要设计</h5><p>将软件需求转化为数据结构和软件的系统结构，确定模块间相互关系</p>\n<h5 id=\"详细设计设计\"><a href=\"#详细设计设计\" class=\"headerlink\" title=\"详细设计设计\"></a>详细设计设计</h5><p>通过结构细化得到数据结构与算法</p>\n<h5 id=\"总体设计过程\"><a href=\"#总体设计过程\" class=\"headerlink\" title=\"总体设计过程\"></a>总体设计过程</h5><ul>\n<li>设想供选择的方案</li>\n<li>选择合理方案</li>\n<li>推荐最佳方案</li>\n<li>功能分解<ul>\n<li>结构设计 模块化组件化设计</li>\n<li>过程设计 模块处理过程</li>\n</ul>\n</li>\n<li>设计软件结构</li>\n<li>数据库设计</li>\n</ul>\n<h5 id=\"设计原理\"><a href=\"#设计原理\" class=\"headerlink\" title=\"设计原理\"></a>设计原理</h5><ul>\n<li>抽象与逐步求精<br>  控制复杂性</li>\n<li>模块化<br>  使程序获得智能化管理</li>\n<li>信息隐藏<br>  隐藏的信息只能通过暴露的接口访问<br>  提高模块独立性，减少维护的影响</li>\n<li>内聚度<br>  衡量一个模块内部各个元素彼此间的紧密程度<ul>\n<li>7：偶然性内聚</li>\n<li>6：逻辑性内聚</li>\n<li>5：时间性内聚</li>\n<li>4：过程性内聚</li>\n<li>3：通信性内聚</li>\n<li>2：顺序性内聚</li>\n<li>1：功能性内聚</li>\n</ul>\n</li>\n<li>耦合度<br>  衡量不同模块间相互依赖的紧密程度<ul>\n<li>7：非直接耦合</li>\n<li>6：数据耦合</li>\n<li>5：特征耦合</li>\n<li>4：控制耦合</li>\n<li>3：外部耦合</li>\n<li>2：公共耦合</li>\n<li>1：内容耦合</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"启发式原则\"><a href=\"#启发式原则\" class=\"headerlink\" title=\"启发式原则\"></a>启发式原则</h5><ul>\n<li>改进软件结构提高模块独立性</li>\n<li>模块规模适中</li>\n<li>深度、宽度、扇入和扇出适当</li>\n<li>模块的作用域应在控制域之内</li>\n<li>设计单入口单出口的模块，力争降低模块接口复杂度</li>\n<li>模块功能可预测</li>\n</ul>\n<h4 id=\"结构化设计方法\"><a href=\"#结构化设计方法\" class=\"headerlink\" title=\"结构化设计方法\"></a>结构化设计方法</h4><h5 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h5><ul>\n<li>基于模块独立性和信息隐藏原则</li>\n<li>自顶向下，逐步求精</li>\n<li>分解与抽象结合</li>\n<li>应用结构化程序设计</li>\n</ul>\n<h5 id=\"面向数据流-SD\"><a href=\"#面向数据流-SD\" class=\"headerlink\" title=\"面向数据流 SD\"></a>面向数据流 SD</h5><ul>\n<li>确定信息流的类型</li>\n<li>划定流界</li>\n<li>将数据流图映射为程序结构</li>\n<li>提取层次控制结构</li>\n<li>通过设计复审和使用启发式策略进一步精化</li>\n</ul>\n<h5 id=\"变换分析法-迭代\"><a href=\"#变换分析法-迭代\" class=\"headerlink\" title=\"变换分析法 迭代\"></a>变换分析法 迭代</h5><p>在数据流图中，数据流经过输入，系统变换，输出，完成数据分析。</p>\n<ul>\n<li>复审基本系统模型</li>\n<li>复审精化软件数据流图</li>\n<li>确定DFD特性，判断是变换流还是事务流</li>\n<li>划定输入流和输出流界限，孤立变换中心</li>\n<li>依次分解</li>\n</ul>\n<h5 id=\"事物分析法\"><a href=\"#事物分析法\" class=\"headerlink\" title=\"事物分析法\"></a>事物分析法</h5><ul>\n<li>复审基本系统模型</li>\n<li>复审并精化软件数据流图</li>\n<li>确定数据流图特性</li>\n<li>指出事务中心，确认动作路径的数据流特性</li>\n<li>把数据流图映射为事务处理型的程序结构</li>\n<li>分解并精化石斛结构及动作路径</li>\n<li>使用启发式设计策略，精化程序结构雏形，改良软件质量</li>\n</ul>\n<h5 id=\"面向数据结构-DSSD\"><a href=\"#面向数据结构-DSSD\" class=\"headerlink\" title=\"面向数据结构 DSSD\"></a>面向数据结构 DSSD</h5><ul>\n<li>确定数据结构特征</li>\n<li>用顺序/选择/重复三种基本形式表示数据</li>\n<li>把数据结构表示映射为软件的控制结构</li>\n<li>用与具体方法配套的设计指南进一步精化控制结构</li>\n<li>开发软件的过程性描述</li>\n</ul>\n<h4 id=\"软件实现及测试\"><a href=\"#软件实现及测试\" class=\"headerlink\" title=\"软件实现及测试\"></a>软件实现及测试</h4><h5 id=\"程序设计语言分类\"><a href=\"#程序设计语言分类\" class=\"headerlink\" title=\"程序设计语言分类\"></a>程序设计语言分类</h5><ul>\n<li>机器语言</li>\n<li>汇编语言</li>\n<li><p>高级语言</p>\n</li>\n<li><p>基础语言(BASIC,FORTRAN,COBOL,ALGOL)</p>\n</li>\n<li>结构语言(PL/1,PASCAL,C．ADA)</li>\n<li>专用语言(FORTH,PROLOG,LISP)</li>\n<li>系统实现语言(C)</li>\n<li>静态高级语言(COBOL,FORTRAN)</li>\n<li>动态高级语言</li>\n<li>块结构高级语言(ALGOL,PASCAL)</li>\n<li>可视化编程语言(VB,VC,PB,BC,C++BUILDER) </li>\n</ul>\n<h5 id=\"编程语言特点\"><a href=\"#编程语言特点\" class=\"headerlink\" title=\"编程语言特点\"></a>编程语言特点</h5><ul>\n<li>心理学观点<ul>\n<li>一致性</li>\n<li>多义性</li>\n<li>局限性</li>\n<li>易编码性</li>\n<li>可移植性</li>\n<li>可维护性</li>\n<li>配套开发工具</li>\n</ul>\n</li>\n<li>工程观点<ul>\n<li>易于把设计翻译为代码</li>\n<li>编译器效率</li>\n<li>源代码可移植性</li>\n<li>开发法工具可用性</li>\n<li>可维护性</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"编写风格要求\"><a href=\"#编写风格要求\" class=\"headerlink\" title=\"编写风格要求\"></a>编写风格要求</h5><ul>\n<li>节简化 提供简洁代码<ul>\n<li>避免程序中不必要的动作和变量</li>\n<li>避免变量名重载</li>\n<li>减小程序体积</li>\n<li>提高运行速度</li>\n<li>避免模块冗杂</li>\n<li>避免全局变量副作用</li>\n</ul>\n</li>\n<li>模块化 把代码划分为内聚度高，富有意义的功能块<ul>\n<li>确保物理和逻辑功能密切想逛</li>\n<li>限定一个模块完成一个功能</li>\n<li>检查代码重复率</li>\n</ul>\n</li>\n<li>简单化 去掉过分复制和不必要的矫揉造作<ul>\n<li>采用简单的算法</li>\n<li>简单的数据结构</li>\n<li>对象命名一致性</li>\n<li>简化算术，逻辑表达式</li>\n</ul>\n</li>\n<li>结构化 把程序的各个构建组织成一个有效的系统<ul>\n<li>按标准化的次序说明数据</li>\n<li>按字母顺序说明对象名</li>\n<li>使用读者明了的结构化程序部件</li>\n<li>根据应用背景排列程序各部分</li>\n<li>不随意为效率而牺牲可读性</li>\n<li>让机器多做重复工作</li>\n<li>用公共函数调用代替重复出现的表达式</li>\n<li>检查参数传递情况</li>\n<li>检查多层嵌套循环</li>\n<li>坚持使用统一缩进规则</li>\n<li>只编写单入口单出口的代码</li>\n</ul>\n</li>\n<li>文档化<ul>\n<li>有效的使用注释</li>\n<li>使用含义鲜明的变量名</li>\n<li>协调使用程序块注释和程序行注释</li>\n<li>始终坚持写文档</li>\n</ul>\n</li>\n<li>格式化 使程序布局合理清晰明了<ul>\n<li>有效的使用编程空间</li>\n<li>适当插入括号 排出多义性</li>\n<li>有效使用空格</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"测试模型\"><a href=\"#测试模型\" class=\"headerlink\" title=\"测试模型\"></a>测试模型</h5><ul>\n<li>V<br>定义了软件测试如何与软件工程各阶段相融合，描述了各级别软件测试与软件开发各阶段的对应关系</li>\n<li>W</li>\n<li>H<br>对W模型在更高层次上的线性抽象。在任何一个开发流程，只要有必要，且测试配置已准备就绪，即可进行测试活动</li>\n</ul>\n<h5 id=\"测试原则\"><a href=\"#测试原则\" class=\"headerlink\" title=\"测试原则\"></a>测试原则</h5><ul>\n<li>应尽早地和不断地进行测试</li>\n<li>开发人员应尽量避免参加测试</li>\n<li>注重测试用例的设计和选择</li>\n<li>增量式测试</li>\n<li>充分注意测试的群集现象</li>\n<li>合理安排测试计划，严格执行测试计划</li>\n<li>全面统计和分析测试结果</li>\n<li>保存测试文档，并及时更新</li>\n</ul>\n<h5 id=\"白盒测试\"><a href=\"#白盒测试\" class=\"headerlink\" title=\"白盒测试\"></a>白盒测试</h5>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"软件的含义\"><a href=\"#软件的含义\" class=\"headerlink\" title=\"软件的含义\"></a>软件的含义</h4><ul>\n<li>提供功能与性能的指令 / 计算机程序  的集合</li>\n<li>处理信息的数据逻辑</li>\n<li>按照商业逻辑处理</li>\n<li>产品文档</li>\n</ul>\n<h4 id=\"软件的特点\"><a href=\"#软件的特点\" class=\"headerlink\" title=\"软件的特点\"></a>软件的特点</h4><ul>\n<li>表现形式： 逻辑性产品，复杂，无磨损，开发环境受限，成本高</li>\n<li>生产方式： 脑力，手工开发</li>\n<li>要求： 受计算机系统限制，涉及社会等因素</li>\n</ul>\n<h4 id=\"软件危机\"><a href=\"#软件危机\" class=\"headerlink\" title=\"软件危机\"></a>软件危机</h4><h5 id=\"表现\"><a href=\"#表现\" class=\"headerlink\" title=\"表现\"></a>表现</h5><ul>\n<li>开发成本/进度预估不准</li>\n<li>用户不满意</li>\n<li>质量差</li>\n<li>不可维护</li>\n<li>缺少文档</li>\n<li>成本过高</li>\n<li>开发速度过慢</li>\n</ul>\n<h5 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h5><ul>\n<li>客观：逻辑复杂，规模庞大</li>\n<li>主管：开发方式不正确，忽视需求分析/维护/写文档</li>\n</ul>\n<h5 id=\"解决途径\"><a href=\"#解决途径\" class=\"headerlink\" title=\"解决途径\"></a>解决途径</h5><ul>\n<li>按工程化的原则和方法组织软件开发工作</li>\n</ul>\n<h4 id=\"软件工程基本原理\"><a href=\"#软件工程基本原理\" class=\"headerlink\" title=\"软件工程基本原理\"></a>软件工程基本原理</h4><ul>\n<li>阶段性生命周期</li>\n<li>阶段评审</li>\n<li>产品控制</li>\n<li>现代程序设计架构</li>\n<li>结果清晰审查</li>\n<li>开发人员少而精</li>\n<li>不断迭代产品</li>\n</ul>\n<h5 id=\"研究内容\"><a href=\"#研究内容\" class=\"headerlink\" title=\"研究内容\"></a>研究内容</h5><ul>\n<li>软件开发技术</li>\n<li>软件工程管理</li>\n</ul>\n<h5 id=\"三要素\"><a href=\"#三要素\" class=\"headerlink\" title=\"三要素\"></a>三要素</h5><ul>\n<li>方法</li>\n<li>工具</li>\n<li>过程</li>\n</ul>\n<h5 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h5><ul>\n<li>可行性分析与设计阶段</li>\n<li>需求分析阶段</li>\n<li>设计阶段</li>\n<li>实现阶段</li>\n<li>测试阶段</li>\n<li>运维阶段</li>\n</ul>\n<h4 id=\"软件过程\"><a href=\"#软件过程\" class=\"headerlink\" title=\"软件过程\"></a>软件过程</h4><p>指软件整个生命周期，从需求获取，需求分析，设计，实现，测试，发布和维护一个过程模型。</p>\n<h5 id=\"过程模型\"><a href=\"#过程模型\" class=\"headerlink\" title=\"过程模型\"></a>过程模型</h5><ul>\n<li>传统开发模型<ul>\n<li>瀑布模型<br>  特征：一次性单向开发，质量保证，文档规范<br>  适合：需求明确的项目<br>  优点：质量保证，严格品控<br>  缺点：周期长，不灵活，难变动</li>\n<li>快速原型模型<br>  特征：快速构建，用户测试反馈，成本低<br>  适合：需求模糊的中小型软件<br>  优点：快速，符合用户预期<br>  缺点：难管理，变动大，架构规范</li>\n</ul>\n</li>\n<li>演化开发模型<ul>\n<li>增量模型<br>  特征：对功能以一系列增量的方式开发<br>  适合：小而可用的软件<br>  优点：灵活，降低风险，可持续开发</li>\n<li>螺旋模型<br>  特征：每个阶段都风险评估的快速原型模型<br>  适合：内部开发的大规模软件项目<br>  优点：减少过多测试或测试不足带来的风险，项目稳定<br>  一个周期：确定目标=&gt;确定方案=&gt;风险评估=&gt;开发=&gt;评估，计划</li>\n</ul>\n</li>\n<li>喷泉模型<br>  特征：每个阶段相互重叠<br>  优点：提高效率，节省时间，适合面向对象<br>  缺点：不利于管理，规范，文档重要</li>\n</ul>\n<h5 id=\"开发方法\"><a href=\"#开发方法\" class=\"headerlink\" title=\"开发方法\"></a>开发方法</h5><ul>\n<li>面向过程的结构化方法<br>  优点：</li>\n<li>面向对象的开发方法<br>  = 对象+类+继承+消息<br>  OOA：分析对象，外部关联，内部结构<br>  OOD：归纳抽象类，规范接口</li>\n</ul>\n<h4 id=\"软件需求\"><a href=\"#软件需求\" class=\"headerlink\" title=\"软件需求\"></a>软件需求</h4><p>用户对目标软件在功能、行为、性能、设计约束等方面的期望</p>\n<h5 id=\"软件需求工程的必要性\"><a href=\"#软件需求工程的必要性\" class=\"headerlink\" title=\"软件需求工程的必要性\"></a>软件需求工程的必要性</h5><p>需求分析是介于系统分析和软件设计阶段之间的重要桥梁<br>以系统规格说明和项目规划做基点，从软件的角度调整分析<br>需求分析师软件设计实现测试维护的主要基础<br>良好的需求分析有助于避免早起错误，提高效率，降低成本</p>\n<h5 id=\"需求分析的任务\"><a href=\"#需求分析的任务\" class=\"headerlink\" title=\"需求分析的任务\"></a>需求分析的任务</h5><ul>\n<li>确定系统的功能需求</li>\n<li>数据分析</li>\n<li>定义逻辑模型</li>\n<li>适应需求变更</li>\n</ul>\n<h5 id=\"需求分析原则\"><a href=\"#需求分析原则\" class=\"headerlink\" title=\"需求分析原则\"></a>需求分析原则</h5><ul>\n<li>从用户的角度考虑</li>\n<li>以流程为主线</li>\n<li>注重复用</li>\n<li>划分需求优先级</li>\n<li>需求变更及时反馈</li>\n</ul>\n<h5 id=\"需求分析内容\"><a href=\"#需求分析内容\" class=\"headerlink\" title=\"需求分析内容\"></a>需求分析内容</h5><ul>\n<li>功能需求</li>\n<li>性能需求</li>\n<li>领域需求</li>\n<li>其他需求</li>\n</ul>\n<h4 id=\"结构化需求分析和建模\"><a href=\"#结构化需求分析和建模\" class=\"headerlink\" title=\"结构化需求分析和建模\"></a>结构化需求分析和建模</h4><ul>\n<li>核心：数据</li>\n<li>实体关系模型<br>  描述数据建模过程，刻画系统静态特征</li>\n<li>数据流图<br>  对功能，操作流程进行分解，完成功能建模</li>\n<li>状态转换图<br>  系统行为建模，通过外部事件触发</li>\n</ul>\n<h5 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h5><p>实体-联系图，描述数据对象间的关系</p>\n<h5 id=\"功能模型\"><a href=\"#功能模型\" class=\"headerlink\" title=\"功能模型\"></a>功能模型</h5><p>数据流图，描绘数据在软件中的变换逻辑过程</p>\n<h5 id=\"行为模型\"><a href=\"#行为模型\" class=\"headerlink\" title=\"行为模型\"></a>行为模型</h5><p>状态转换图，描绘系统通过各种行为模式在不同状态间转换的方式</p>\n<h5 id=\"建模目的\"><a href=\"#建模目的\" class=\"headerlink\" title=\"建模目的\"></a>建模目的</h5><ul>\n<li>使分析系统化</li>\n<li>模型是评审的焦点，是确定系统完整性，一致性，规格说明准确性的关键</li>\n<li>模型是设计的基础</li>\n</ul>\n<h5 id=\"建模的原因\"><a href=\"#建模的原因\" class=\"headerlink\" title=\"建模的原因\"></a>建模的原因</h5><ul>\n<li>在建模中了解系统</li>\n<li>通过抽象降低复杂性</li>\n<li>有助于回忆细节</li>\n<li>有助于开发间，与用户交流</li>\n<li>提供开发维护文档</li>\n</ul>\n<h5 id=\"数据字典\"><a href=\"#数据字典\" class=\"headerlink\" title=\"数据字典\"></a>数据字典</h5><ul>\n<li>数据流</li>\n<li>数据流分量</li>\n<li>数据存储</li>\n<li>处理</li>\n</ul>\n<h4 id=\"软件设计\"><a href=\"#软件设计\" class=\"headerlink\" title=\"软件设计\"></a>软件设计</h4><h5 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h5><p>构造一个高内聚，高可靠性，高维护性，高效率的软件模型<br>为提高软件质量做基础</p>\n<ul>\n<li>过程设计：状态转换图，控制规格说明，加工规格说明</li>\n<li>接口设计：数据流图</li>\n<li>体系结构设计：数据流图</li>\n<li>数据设计：数据词典，实体关系图</li>\n</ul>\n<h5 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h5><ul>\n<li>分而治之，模块化</li>\n<li>重用设计模式</li>\n<li>可跟踪性</li>\n<li>灵活性</li>\n<li>一致性</li>\n</ul>\n<h5 id=\"概要设计\"><a href=\"#概要设计\" class=\"headerlink\" title=\"概要设计\"></a>概要设计</h5><p>将软件需求转化为数据结构和软件的系统结构，确定模块间相互关系</p>\n<h5 id=\"详细设计设计\"><a href=\"#详细设计设计\" class=\"headerlink\" title=\"详细设计设计\"></a>详细设计设计</h5><p>通过结构细化得到数据结构与算法</p>\n<h5 id=\"总体设计过程\"><a href=\"#总体设计过程\" class=\"headerlink\" title=\"总体设计过程\"></a>总体设计过程</h5><ul>\n<li>设想供选择的方案</li>\n<li>选择合理方案</li>\n<li>推荐最佳方案</li>\n<li>功能分解<ul>\n<li>结构设计 模块化组件化设计</li>\n<li>过程设计 模块处理过程</li>\n</ul>\n</li>\n<li>设计软件结构</li>\n<li>数据库设计</li>\n</ul>\n<h5 id=\"设计原理\"><a href=\"#设计原理\" class=\"headerlink\" title=\"设计原理\"></a>设计原理</h5><ul>\n<li>抽象与逐步求精<br>  控制复杂性</li>\n<li>模块化<br>  使程序获得智能化管理</li>\n<li>信息隐藏<br>  隐藏的信息只能通过暴露的接口访问<br>  提高模块独立性，减少维护的影响</li>\n<li>内聚度<br>  衡量一个模块内部各个元素彼此间的紧密程度<ul>\n<li>7：偶然性内聚</li>\n<li>6：逻辑性内聚</li>\n<li>5：时间性内聚</li>\n<li>4：过程性内聚</li>\n<li>3：通信性内聚</li>\n<li>2：顺序性内聚</li>\n<li>1：功能性内聚</li>\n</ul>\n</li>\n<li>耦合度<br>  衡量不同模块间相互依赖的紧密程度<ul>\n<li>7：非直接耦合</li>\n<li>6：数据耦合</li>\n<li>5：特征耦合</li>\n<li>4：控制耦合</li>\n<li>3：外部耦合</li>\n<li>2：公共耦合</li>\n<li>1：内容耦合</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"启发式原则\"><a href=\"#启发式原则\" class=\"headerlink\" title=\"启发式原则\"></a>启发式原则</h5><ul>\n<li>改进软件结构提高模块独立性</li>\n<li>模块规模适中</li>\n<li>深度、宽度、扇入和扇出适当</li>\n<li>模块的作用域应在控制域之内</li>\n<li>设计单入口单出口的模块，力争降低模块接口复杂度</li>\n<li>模块功能可预测</li>\n</ul>\n<h4 id=\"结构化设计方法\"><a href=\"#结构化设计方法\" class=\"headerlink\" title=\"结构化设计方法\"></a>结构化设计方法</h4><h5 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h5><ul>\n<li>基于模块独立性和信息隐藏原则</li>\n<li>自顶向下，逐步求精</li>\n<li>分解与抽象结合</li>\n<li>应用结构化程序设计</li>\n</ul>\n<h5 id=\"面向数据流-SD\"><a href=\"#面向数据流-SD\" class=\"headerlink\" title=\"面向数据流 SD\"></a>面向数据流 SD</h5><ul>\n<li>确定信息流的类型</li>\n<li>划定流界</li>\n<li>将数据流图映射为程序结构</li>\n<li>提取层次控制结构</li>\n<li>通过设计复审和使用启发式策略进一步精化</li>\n</ul>\n<h5 id=\"变换分析法-迭代\"><a href=\"#变换分析法-迭代\" class=\"headerlink\" title=\"变换分析法 迭代\"></a>变换分析法 迭代</h5><p>在数据流图中，数据流经过输入，系统变换，输出，完成数据分析。</p>\n<ul>\n<li>复审基本系统模型</li>\n<li>复审精化软件数据流图</li>\n<li>确定DFD特性，判断是变换流还是事务流</li>\n<li>划定输入流和输出流界限，孤立变换中心</li>\n<li>依次分解</li>\n</ul>\n<h5 id=\"事物分析法\"><a href=\"#事物分析法\" class=\"headerlink\" title=\"事物分析法\"></a>事物分析法</h5><ul>\n<li>复审基本系统模型</li>\n<li>复审并精化软件数据流图</li>\n<li>确定数据流图特性</li>\n<li>指出事务中心，确认动作路径的数据流特性</li>\n<li>把数据流图映射为事务处理型的程序结构</li>\n<li>分解并精化石斛结构及动作路径</li>\n<li>使用启发式设计策略，精化程序结构雏形，改良软件质量</li>\n</ul>\n<h5 id=\"面向数据结构-DSSD\"><a href=\"#面向数据结构-DSSD\" class=\"headerlink\" title=\"面向数据结构 DSSD\"></a>面向数据结构 DSSD</h5><ul>\n<li>确定数据结构特征</li>\n<li>用顺序/选择/重复三种基本形式表示数据</li>\n<li>把数据结构表示映射为软件的控制结构</li>\n<li>用与具体方法配套的设计指南进一步精化控制结构</li>\n<li>开发软件的过程性描述</li>\n</ul>\n<h4 id=\"软件实现及测试\"><a href=\"#软件实现及测试\" class=\"headerlink\" title=\"软件实现及测试\"></a>软件实现及测试</h4><h5 id=\"程序设计语言分类\"><a href=\"#程序设计语言分类\" class=\"headerlink\" title=\"程序设计语言分类\"></a>程序设计语言分类</h5><ul>\n<li>机器语言</li>\n<li>汇编语言</li>\n<li><p>高级语言</p>\n</li>\n<li><p>基础语言(BASIC,FORTRAN,COBOL,ALGOL)</p>\n</li>\n<li>结构语言(PL/1,PASCAL,C．ADA)</li>\n<li>专用语言(FORTH,PROLOG,LISP)</li>\n<li>系统实现语言(C)</li>\n<li>静态高级语言(COBOL,FORTRAN)</li>\n<li>动态高级语言</li>\n<li>块结构高级语言(ALGOL,PASCAL)</li>\n<li>可视化编程语言(VB,VC,PB,BC,C++BUILDER) </li>\n</ul>\n<h5 id=\"编程语言特点\"><a href=\"#编程语言特点\" class=\"headerlink\" title=\"编程语言特点\"></a>编程语言特点</h5><ul>\n<li>心理学观点<ul>\n<li>一致性</li>\n<li>多义性</li>\n<li>局限性</li>\n<li>易编码性</li>\n<li>可移植性</li>\n<li>可维护性</li>\n<li>配套开发工具</li>\n</ul>\n</li>\n<li>工程观点<ul>\n<li>易于把设计翻译为代码</li>\n<li>编译器效率</li>\n<li>源代码可移植性</li>\n<li>开发法工具可用性</li>\n<li>可维护性</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"编写风格要求\"><a href=\"#编写风格要求\" class=\"headerlink\" title=\"编写风格要求\"></a>编写风格要求</h5><ul>\n<li>节简化 提供简洁代码<ul>\n<li>避免程序中不必要的动作和变量</li>\n<li>避免变量名重载</li>\n<li>减小程序体积</li>\n<li>提高运行速度</li>\n<li>避免模块冗杂</li>\n<li>避免全局变量副作用</li>\n</ul>\n</li>\n<li>模块化 把代码划分为内聚度高，富有意义的功能块<ul>\n<li>确保物理和逻辑功能密切想逛</li>\n<li>限定一个模块完成一个功能</li>\n<li>检查代码重复率</li>\n</ul>\n</li>\n<li>简单化 去掉过分复制和不必要的矫揉造作<ul>\n<li>采用简单的算法</li>\n<li>简单的数据结构</li>\n<li>对象命名一致性</li>\n<li>简化算术，逻辑表达式</li>\n</ul>\n</li>\n<li>结构化 把程序的各个构建组织成一个有效的系统<ul>\n<li>按标准化的次序说明数据</li>\n<li>按字母顺序说明对象名</li>\n<li>使用读者明了的结构化程序部件</li>\n<li>根据应用背景排列程序各部分</li>\n<li>不随意为效率而牺牲可读性</li>\n<li>让机器多做重复工作</li>\n<li>用公共函数调用代替重复出现的表达式</li>\n<li>检查参数传递情况</li>\n<li>检查多层嵌套循环</li>\n<li>坚持使用统一缩进规则</li>\n<li>只编写单入口单出口的代码</li>\n</ul>\n</li>\n<li>文档化<ul>\n<li>有效的使用注释</li>\n<li>使用含义鲜明的变量名</li>\n<li>协调使用程序块注释和程序行注释</li>\n<li>始终坚持写文档</li>\n</ul>\n</li>\n<li>格式化 使程序布局合理清晰明了<ul>\n<li>有效的使用编程空间</li>\n<li>适当插入括号 排出多义性</li>\n<li>有效使用空格</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"测试模型\"><a href=\"#测试模型\" class=\"headerlink\" title=\"测试模型\"></a>测试模型</h5><ul>\n<li>V<br>定义了软件测试如何与软件工程各阶段相融合，描述了各级别软件测试与软件开发各阶段的对应关系</li>\n<li>W</li>\n<li>H<br>对W模型在更高层次上的线性抽象。在任何一个开发流程，只要有必要，且测试配置已准备就绪，即可进行测试活动</li>\n</ul>\n<h5 id=\"测试原则\"><a href=\"#测试原则\" class=\"headerlink\" title=\"测试原则\"></a>测试原则</h5><ul>\n<li>应尽早地和不断地进行测试</li>\n<li>开发人员应尽量避免参加测试</li>\n<li>注重测试用例的设计和选择</li>\n<li>增量式测试</li>\n<li>充分注意测试的群集现象</li>\n<li>合理安排测试计划，严格执行测试计划</li>\n<li>全面统计和分析测试结果</li>\n<li>保存测试文档，并及时更新</li>\n</ul>\n<h5 id=\"白盒测试\"><a href=\"#白盒测试\" class=\"headerlink\" title=\"白盒测试\"></a>白盒测试</h5>"},{"title":"mongodb的一些操作","date":"2017-03-30T02:50:52.000Z","_content":"\n我要学习！！\n<!--more-->\n\n### Collection集合中的基本操作\n1.查看帮助\n```\ndb.test.help()\n```\n2.查询当前集合的数据条数\n```\ndb.test.count()\n```\n3.查看数据空间大小\n```\ndb.test.dataSize()\n```\n4.得到当前聚合所在的db\n```\ndb.test.getDB()\n```\n5.得到当前聚合的状态\n```\ndb.test.stats()\n```\n6.聚合集合总大小\n```\ndb.test.totalSize()\n```\n7.聚合集合存储空间大小\n```\ndb.test.storageSize()\n```\n8.shard版本信息\n```\ndb.test.getShardVersion()\n```\n9.聚合集合重命名\n```\ndb.test.renameCollection('newName')\n```\n10.删除当前聚集集合\n```\ndb.test.drop()\n```\n\n\n### 聚集集合查询\n1.查询所有记录\n```\ndb.test.find()\n// 默认每页显示20条记录，可用 it 迭代查询下一页数据\n// 可以用 DBquery.shellBatchSize = 50 更改每页数据\n```\n2.查询过滤指定键中含有的重复数据\n```\ndb.test.distinct(\"name\")\n```\n3.查询 title = 指定值的数据\n```\ndb.test.find({title:\"xuncs\"})\n```\n4.查询 age > 18 的数据\n```\ndb.test.find({age:{$gt:18}})\n```\n5.查询 age < 18 的数据\n```\ndb.test.find({age:{$lt:18}})\n```\n6.查询 age >= 18 的数据\n```\ndb.test.find({age:{$gte:18}})\n```\n7.查询 age <= 18 的数据\n```\ndb.test.find({age:{$lte:18}})\n```\n8.查询 age > 18&& age < 24\n```\ndb.test.find({age:{$gt:18,$lt:24}})\n```\n9.查询 title中包含 xun 的数据\n```\ndb.xuncs.find({title:/xun/})\n```\n10.查询 title 中以 xun 开头的数据\n```\ndb.xuncs.find({title:/^xun/})\n```\n11.查询指定列, title，date数据\n```\ndb.xuncs.find({},{title: 1,date: 1})\n```\n12.查询指定列 且有要求查询\n```\ndb.xuncs.find({age:{$gt: 15}}, {age: 1})\n```\n13.排序\n```\ndb.xuncs.find().sort({age: 1})  // 升序\ndb.xuncs.find().sort({age: -1}) // 降序\n```\n14.查询指定数据\n```\ndb.xuncs.find()({title: 'xuncs'}) // 查询title = 'xuncs' 的data\n```\n15.查询前n条数据\n```\ndb.xuncs.find().limit(n)\n```\n16.查询n条之后的数据\n```\ndb.xuncs.find().skip(n)\n```\n17.查询n-m之间的数据\n```\ndb.xuncs.find().limit(m).skip(n)\n```\n18.or与查询\n```\ndb.xuncs.find({$or:[{age: 18},{age: 28}]})  // 查询 age = 18 || age = 28\n```\n19.查询第一条数据\n```\ndb.xuncs.findOne()\n```\n20.查询某个结果集的记录条数\n```\ndb.xuncs.find({age: {$gte:18}}).count()\n```\n21.查询某列含有该键值的数据\n```\ndb.xuncs.find({title: {$exists: true}})\n```\n\n\n### 索引\n1.创建索引\n```\ndb.xuncs.ensureIndex({title: 1})\ndb.xuncs.ensureIndex({title: 1, ts: -1})\n```\n2.查询当前聚合集合所有索引\n```\ndb.xuncs.getIdexes()\n```\n3.查看总索引记录大小\n```\ndb.xuncs.totalIndexSize()\n```\n4.读取当前集合的所有index信息\n```\ndb.xuncs.reIndex()\n```\n5.删除指定索引\n```\ndb.xuncs.dropIndex('title_1')\n```\n6.删除所有索引\n```\ndb.xuncs.dropIndexes()\n```\n\n### 增删改\n1.添加\n```\ndb.xuncs.save({title: 'xuncs', age: 18, sex: true, date: new Date()})\ndb.xuncs.insert({title: \"insert\"})\ndb.xuncs.batchInsert([{'title': 'batch1'},{'title': 'batch2'}])  // 批量添加\n```\n2.修改\n```\ndb.xuncs.update({title: 'xuncs'}, {$set: {age: 20}})\n// 修改数据中第一条title = 'xuncs'的age为20\ndb.xuncs.update({title: 'xuncs'}, {$set: {age: 22}}, false, true)\n// 修改数据中所有条目title = 'xuncs'的age为22\ndb.xuncs.update({title: 'xuncs'}, {$inc: {age: 50}})\n// $inc 增加\n```\n3.删除\n```\ndb.xuncs.remove // 删除xuncs集合中所有文档\ndb.xuncs.remove({age: 18})\n```\n4.查询修改删除\n```\ndb.xuncs.findAndModify({\n  query: {age: {$gte:18}},\n  sort: {age: -1},\n  update: {$set: {name: 'aaa'}, $inc: {age:2}}\n})\ndb.runCommand({ findandmodify: \"xuncs\",\n  query: {age: {$gte:18}},\n  sort: {age: -1},\n  /*update: {$set: {name: 'aaa'}, $inc: {age:2}}*/\n  remove: true\n})\n// update与remove中有一个必须参数，其他参数可选\n```\n","source":"_posts/mongodb的一些操作.md","raw":"---\ntitle: mongodb的一些操作\ndate: 2017-03-30 10:50:52\ntags:\n---\n\n我要学习！！\n<!--more-->\n\n### Collection集合中的基本操作\n1.查看帮助\n```\ndb.test.help()\n```\n2.查询当前集合的数据条数\n```\ndb.test.count()\n```\n3.查看数据空间大小\n```\ndb.test.dataSize()\n```\n4.得到当前聚合所在的db\n```\ndb.test.getDB()\n```\n5.得到当前聚合的状态\n```\ndb.test.stats()\n```\n6.聚合集合总大小\n```\ndb.test.totalSize()\n```\n7.聚合集合存储空间大小\n```\ndb.test.storageSize()\n```\n8.shard版本信息\n```\ndb.test.getShardVersion()\n```\n9.聚合集合重命名\n```\ndb.test.renameCollection('newName')\n```\n10.删除当前聚集集合\n```\ndb.test.drop()\n```\n\n\n### 聚集集合查询\n1.查询所有记录\n```\ndb.test.find()\n// 默认每页显示20条记录，可用 it 迭代查询下一页数据\n// 可以用 DBquery.shellBatchSize = 50 更改每页数据\n```\n2.查询过滤指定键中含有的重复数据\n```\ndb.test.distinct(\"name\")\n```\n3.查询 title = 指定值的数据\n```\ndb.test.find({title:\"xuncs\"})\n```\n4.查询 age > 18 的数据\n```\ndb.test.find({age:{$gt:18}})\n```\n5.查询 age < 18 的数据\n```\ndb.test.find({age:{$lt:18}})\n```\n6.查询 age >= 18 的数据\n```\ndb.test.find({age:{$gte:18}})\n```\n7.查询 age <= 18 的数据\n```\ndb.test.find({age:{$lte:18}})\n```\n8.查询 age > 18&& age < 24\n```\ndb.test.find({age:{$gt:18,$lt:24}})\n```\n9.查询 title中包含 xun 的数据\n```\ndb.xuncs.find({title:/xun/})\n```\n10.查询 title 中以 xun 开头的数据\n```\ndb.xuncs.find({title:/^xun/})\n```\n11.查询指定列, title，date数据\n```\ndb.xuncs.find({},{title: 1,date: 1})\n```\n12.查询指定列 且有要求查询\n```\ndb.xuncs.find({age:{$gt: 15}}, {age: 1})\n```\n13.排序\n```\ndb.xuncs.find().sort({age: 1})  // 升序\ndb.xuncs.find().sort({age: -1}) // 降序\n```\n14.查询指定数据\n```\ndb.xuncs.find()({title: 'xuncs'}) // 查询title = 'xuncs' 的data\n```\n15.查询前n条数据\n```\ndb.xuncs.find().limit(n)\n```\n16.查询n条之后的数据\n```\ndb.xuncs.find().skip(n)\n```\n17.查询n-m之间的数据\n```\ndb.xuncs.find().limit(m).skip(n)\n```\n18.or与查询\n```\ndb.xuncs.find({$or:[{age: 18},{age: 28}]})  // 查询 age = 18 || age = 28\n```\n19.查询第一条数据\n```\ndb.xuncs.findOne()\n```\n20.查询某个结果集的记录条数\n```\ndb.xuncs.find({age: {$gte:18}}).count()\n```\n21.查询某列含有该键值的数据\n```\ndb.xuncs.find({title: {$exists: true}})\n```\n\n\n### 索引\n1.创建索引\n```\ndb.xuncs.ensureIndex({title: 1})\ndb.xuncs.ensureIndex({title: 1, ts: -1})\n```\n2.查询当前聚合集合所有索引\n```\ndb.xuncs.getIdexes()\n```\n3.查看总索引记录大小\n```\ndb.xuncs.totalIndexSize()\n```\n4.读取当前集合的所有index信息\n```\ndb.xuncs.reIndex()\n```\n5.删除指定索引\n```\ndb.xuncs.dropIndex('title_1')\n```\n6.删除所有索引\n```\ndb.xuncs.dropIndexes()\n```\n\n### 增删改\n1.添加\n```\ndb.xuncs.save({title: 'xuncs', age: 18, sex: true, date: new Date()})\ndb.xuncs.insert({title: \"insert\"})\ndb.xuncs.batchInsert([{'title': 'batch1'},{'title': 'batch2'}])  // 批量添加\n```\n2.修改\n```\ndb.xuncs.update({title: 'xuncs'}, {$set: {age: 20}})\n// 修改数据中第一条title = 'xuncs'的age为20\ndb.xuncs.update({title: 'xuncs'}, {$set: {age: 22}}, false, true)\n// 修改数据中所有条目title = 'xuncs'的age为22\ndb.xuncs.update({title: 'xuncs'}, {$inc: {age: 50}})\n// $inc 增加\n```\n3.删除\n```\ndb.xuncs.remove // 删除xuncs集合中所有文档\ndb.xuncs.remove({age: 18})\n```\n4.查询修改删除\n```\ndb.xuncs.findAndModify({\n  query: {age: {$gte:18}},\n  sort: {age: -1},\n  update: {$set: {name: 'aaa'}, $inc: {age:2}}\n})\ndb.runCommand({ findandmodify: \"xuncs\",\n  query: {age: {$gte:18}},\n  sort: {age: -1},\n  /*update: {$set: {name: 'aaa'}, $inc: {age:2}}*/\n  remove: true\n})\n// update与remove中有一个必须参数，其他参数可选\n```\n","slug":"mongodb的一些操作","published":1,"updated":"2017-04-01T03:35:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2s000pttwppkk5jb3e","content":"<p>我要学习！！<br><a id=\"more\"></a></p>\n<h3 id=\"Collection集合中的基本操作\"><a href=\"#Collection集合中的基本操作\" class=\"headerlink\" title=\"Collection集合中的基本操作\"></a>Collection集合中的基本操作</h3><p>1.查看帮助</p>\n<pre><code>db.test.help()\n</code></pre><p>2.查询当前集合的数据条数</p>\n<pre><code>db.test.count()\n</code></pre><p>3.查看数据空间大小</p>\n<pre><code>db.test.dataSize()\n</code></pre><p>4.得到当前聚合所在的db</p>\n<pre><code>db.test.getDB()\n</code></pre><p>5.得到当前聚合的状态</p>\n<pre><code>db.test.stats()\n</code></pre><p>6.聚合集合总大小</p>\n<pre><code>db.test.totalSize()\n</code></pre><p>7.聚合集合存储空间大小</p>\n<pre><code>db.test.storageSize()\n</code></pre><p>8.shard版本信息</p>\n<pre><code>db.test.getShardVersion()\n</code></pre><p>9.聚合集合重命名</p>\n<pre><code>db.test.renameCollection(&#39;newName&#39;)\n</code></pre><p>10.删除当前聚集集合</p>\n<pre><code>db.test.drop()\n</code></pre><h3 id=\"聚集集合查询\"><a href=\"#聚集集合查询\" class=\"headerlink\" title=\"聚集集合查询\"></a>聚集集合查询</h3><p>1.查询所有记录</p>\n<pre><code>db.test.find()\n// 默认每页显示20条记录，可用 it 迭代查询下一页数据\n// 可以用 DBquery.shellBatchSize = 50 更改每页数据\n</code></pre><p>2.查询过滤指定键中含有的重复数据</p>\n<pre><code>db.test.distinct(&quot;name&quot;)\n</code></pre><p>3.查询 title = 指定值的数据</p>\n<pre><code>db.test.find({title:&quot;xuncs&quot;})\n</code></pre><p>4.查询 age &gt; 18 的数据</p>\n<pre><code>db.test.find({age:{$gt:18}})\n</code></pre><p>5.查询 age &lt; 18 的数据</p>\n<pre><code>db.test.find({age:{$lt:18}})\n</code></pre><p>6.查询 age &gt;= 18 的数据</p>\n<pre><code>db.test.find({age:{$gte:18}})\n</code></pre><p>7.查询 age &lt;= 18 的数据</p>\n<pre><code>db.test.find({age:{$lte:18}})\n</code></pre><p>8.查询 age &gt; 18&amp;&amp; age &lt; 24</p>\n<pre><code>db.test.find({age:{$gt:18,$lt:24}})\n</code></pre><p>9.查询 title中包含 xun 的数据</p>\n<pre><code>db.xuncs.find({title:/xun/})\n</code></pre><p>10.查询 title 中以 xun 开头的数据</p>\n<pre><code>db.xuncs.find({title:/^xun/})\n</code></pre><p>11.查询指定列, title，date数据</p>\n<pre><code>db.xuncs.find({},{title: 1,date: 1})\n</code></pre><p>12.查询指定列 且有要求查询</p>\n<pre><code>db.xuncs.find({age:{$gt: 15}}, {age: 1})\n</code></pre><p>13.排序</p>\n<pre><code>db.xuncs.find().sort({age: 1})  // 升序\ndb.xuncs.find().sort({age: -1}) // 降序\n</code></pre><p>14.查询指定数据</p>\n<pre><code>db.xuncs.find()({title: &#39;xuncs&#39;}) // 查询title = &#39;xuncs&#39; 的data\n</code></pre><p>15.查询前n条数据</p>\n<pre><code>db.xuncs.find().limit(n)\n</code></pre><p>16.查询n条之后的数据</p>\n<pre><code>db.xuncs.find().skip(n)\n</code></pre><p>17.查询n-m之间的数据</p>\n<pre><code>db.xuncs.find().limit(m).skip(n)\n</code></pre><p>18.or与查询</p>\n<pre><code>db.xuncs.find({$or:[{age: 18},{age: 28}]})  // 查询 age = 18 || age = 28\n</code></pre><p>19.查询第一条数据</p>\n<pre><code>db.xuncs.findOne()\n</code></pre><p>20.查询某个结果集的记录条数</p>\n<pre><code>db.xuncs.find({age: {$gte:18}}).count()\n</code></pre><p>21.查询某列含有该键值的数据</p>\n<pre><code>db.xuncs.find({title: {$exists: true}})\n</code></pre><h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>1.创建索引</p>\n<pre><code>db.xuncs.ensureIndex({title: 1})\ndb.xuncs.ensureIndex({title: 1, ts: -1})\n</code></pre><p>2.查询当前聚合集合所有索引</p>\n<pre><code>db.xuncs.getIdexes()\n</code></pre><p>3.查看总索引记录大小</p>\n<pre><code>db.xuncs.totalIndexSize()\n</code></pre><p>4.读取当前集合的所有index信息</p>\n<pre><code>db.xuncs.reIndex()\n</code></pre><p>5.删除指定索引</p>\n<pre><code>db.xuncs.dropIndex(&#39;title_1&#39;)\n</code></pre><p>6.删除所有索引</p>\n<pre><code>db.xuncs.dropIndexes()\n</code></pre><h3 id=\"增删改\"><a href=\"#增删改\" class=\"headerlink\" title=\"增删改\"></a>增删改</h3><p>1.添加</p>\n<pre><code>db.xuncs.save({title: &#39;xuncs&#39;, age: 18, sex: true, date: new Date()})\ndb.xuncs.insert({title: &quot;insert&quot;})\ndb.xuncs.batchInsert([{&#39;title&#39;: &#39;batch1&#39;},{&#39;title&#39;: &#39;batch2&#39;}])  // 批量添加\n</code></pre><p>2.修改</p>\n<pre><code>db.xuncs.update({title: &#39;xuncs&#39;}, {$set: {age: 20}})\n// 修改数据中第一条title = &#39;xuncs&#39;的age为20\ndb.xuncs.update({title: &#39;xuncs&#39;}, {$set: {age: 22}}, false, true)\n// 修改数据中所有条目title = &#39;xuncs&#39;的age为22\ndb.xuncs.update({title: &#39;xuncs&#39;}, {$inc: {age: 50}})\n// $inc 增加\n</code></pre><p>3.删除</p>\n<pre><code>db.xuncs.remove // 删除xuncs集合中所有文档\ndb.xuncs.remove({age: 18})\n</code></pre><p>4.查询修改删除</p>\n<pre><code>db.xuncs.findAndModify({\n  query: {age: {$gte:18}},\n  sort: {age: -1},\n  update: {$set: {name: &#39;aaa&#39;}, $inc: {age:2}}\n})\ndb.runCommand({ findandmodify: &quot;xuncs&quot;,\n  query: {age: {$gte:18}},\n  sort: {age: -1},\n  /*update: {$set: {name: &#39;aaa&#39;}, $inc: {age:2}}*/\n  remove: true\n})\n// update与remove中有一个必须参数，其他参数可选\n</code></pre>","site":{"data":{}},"excerpt":"<p>我要学习！！<br>","more":"</p>\n<h3 id=\"Collection集合中的基本操作\"><a href=\"#Collection集合中的基本操作\" class=\"headerlink\" title=\"Collection集合中的基本操作\"></a>Collection集合中的基本操作</h3><p>1.查看帮助</p>\n<pre><code>db.test.help()\n</code></pre><p>2.查询当前集合的数据条数</p>\n<pre><code>db.test.count()\n</code></pre><p>3.查看数据空间大小</p>\n<pre><code>db.test.dataSize()\n</code></pre><p>4.得到当前聚合所在的db</p>\n<pre><code>db.test.getDB()\n</code></pre><p>5.得到当前聚合的状态</p>\n<pre><code>db.test.stats()\n</code></pre><p>6.聚合集合总大小</p>\n<pre><code>db.test.totalSize()\n</code></pre><p>7.聚合集合存储空间大小</p>\n<pre><code>db.test.storageSize()\n</code></pre><p>8.shard版本信息</p>\n<pre><code>db.test.getShardVersion()\n</code></pre><p>9.聚合集合重命名</p>\n<pre><code>db.test.renameCollection(&#39;newName&#39;)\n</code></pre><p>10.删除当前聚集集合</p>\n<pre><code>db.test.drop()\n</code></pre><h3 id=\"聚集集合查询\"><a href=\"#聚集集合查询\" class=\"headerlink\" title=\"聚集集合查询\"></a>聚集集合查询</h3><p>1.查询所有记录</p>\n<pre><code>db.test.find()\n// 默认每页显示20条记录，可用 it 迭代查询下一页数据\n// 可以用 DBquery.shellBatchSize = 50 更改每页数据\n</code></pre><p>2.查询过滤指定键中含有的重复数据</p>\n<pre><code>db.test.distinct(&quot;name&quot;)\n</code></pre><p>3.查询 title = 指定值的数据</p>\n<pre><code>db.test.find({title:&quot;xuncs&quot;})\n</code></pre><p>4.查询 age &gt; 18 的数据</p>\n<pre><code>db.test.find({age:{$gt:18}})\n</code></pre><p>5.查询 age &lt; 18 的数据</p>\n<pre><code>db.test.find({age:{$lt:18}})\n</code></pre><p>6.查询 age &gt;= 18 的数据</p>\n<pre><code>db.test.find({age:{$gte:18}})\n</code></pre><p>7.查询 age &lt;= 18 的数据</p>\n<pre><code>db.test.find({age:{$lte:18}})\n</code></pre><p>8.查询 age &gt; 18&amp;&amp; age &lt; 24</p>\n<pre><code>db.test.find({age:{$gt:18,$lt:24}})\n</code></pre><p>9.查询 title中包含 xun 的数据</p>\n<pre><code>db.xuncs.find({title:/xun/})\n</code></pre><p>10.查询 title 中以 xun 开头的数据</p>\n<pre><code>db.xuncs.find({title:/^xun/})\n</code></pre><p>11.查询指定列, title，date数据</p>\n<pre><code>db.xuncs.find({},{title: 1,date: 1})\n</code></pre><p>12.查询指定列 且有要求查询</p>\n<pre><code>db.xuncs.find({age:{$gt: 15}}, {age: 1})\n</code></pre><p>13.排序</p>\n<pre><code>db.xuncs.find().sort({age: 1})  // 升序\ndb.xuncs.find().sort({age: -1}) // 降序\n</code></pre><p>14.查询指定数据</p>\n<pre><code>db.xuncs.find()({title: &#39;xuncs&#39;}) // 查询title = &#39;xuncs&#39; 的data\n</code></pre><p>15.查询前n条数据</p>\n<pre><code>db.xuncs.find().limit(n)\n</code></pre><p>16.查询n条之后的数据</p>\n<pre><code>db.xuncs.find().skip(n)\n</code></pre><p>17.查询n-m之间的数据</p>\n<pre><code>db.xuncs.find().limit(m).skip(n)\n</code></pre><p>18.or与查询</p>\n<pre><code>db.xuncs.find({$or:[{age: 18},{age: 28}]})  // 查询 age = 18 || age = 28\n</code></pre><p>19.查询第一条数据</p>\n<pre><code>db.xuncs.findOne()\n</code></pre><p>20.查询某个结果集的记录条数</p>\n<pre><code>db.xuncs.find({age: {$gte:18}}).count()\n</code></pre><p>21.查询某列含有该键值的数据</p>\n<pre><code>db.xuncs.find({title: {$exists: true}})\n</code></pre><h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>1.创建索引</p>\n<pre><code>db.xuncs.ensureIndex({title: 1})\ndb.xuncs.ensureIndex({title: 1, ts: -1})\n</code></pre><p>2.查询当前聚合集合所有索引</p>\n<pre><code>db.xuncs.getIdexes()\n</code></pre><p>3.查看总索引记录大小</p>\n<pre><code>db.xuncs.totalIndexSize()\n</code></pre><p>4.读取当前集合的所有index信息</p>\n<pre><code>db.xuncs.reIndex()\n</code></pre><p>5.删除指定索引</p>\n<pre><code>db.xuncs.dropIndex(&#39;title_1&#39;)\n</code></pre><p>6.删除所有索引</p>\n<pre><code>db.xuncs.dropIndexes()\n</code></pre><h3 id=\"增删改\"><a href=\"#增删改\" class=\"headerlink\" title=\"增删改\"></a>增删改</h3><p>1.添加</p>\n<pre><code>db.xuncs.save({title: &#39;xuncs&#39;, age: 18, sex: true, date: new Date()})\ndb.xuncs.insert({title: &quot;insert&quot;})\ndb.xuncs.batchInsert([{&#39;title&#39;: &#39;batch1&#39;},{&#39;title&#39;: &#39;batch2&#39;}])  // 批量添加\n</code></pre><p>2.修改</p>\n<pre><code>db.xuncs.update({title: &#39;xuncs&#39;}, {$set: {age: 20}})\n// 修改数据中第一条title = &#39;xuncs&#39;的age为20\ndb.xuncs.update({title: &#39;xuncs&#39;}, {$set: {age: 22}}, false, true)\n// 修改数据中所有条目title = &#39;xuncs&#39;的age为22\ndb.xuncs.update({title: &#39;xuncs&#39;}, {$inc: {age: 50}})\n// $inc 增加\n</code></pre><p>3.删除</p>\n<pre><code>db.xuncs.remove // 删除xuncs集合中所有文档\ndb.xuncs.remove({age: 18})\n</code></pre><p>4.查询修改删除</p>\n<pre><code>db.xuncs.findAndModify({\n  query: {age: {$gte:18}},\n  sort: {age: -1},\n  update: {$set: {name: &#39;aaa&#39;}, $inc: {age:2}}\n})\ndb.runCommand({ findandmodify: &quot;xuncs&quot;,\n  query: {age: {$gte:18}},\n  sort: {age: -1},\n  /*update: {$set: {name: &#39;aaa&#39;}, $inc: {age:2}}*/\n  remove: true\n})\n// update与remove中有一个必须参数，其他参数可选\n</code></pre>"},{"title":"redux学习笔记","date":"2017-05-04T01:38:19.000Z","_content":"愿这次笔记能记好。\n\n<!--more-->\n\n<!--# <strong class=\"title\">React</strong>\n\n## <strong class=\"title\">创建项目</strong>\n\n``` shell\n$ git clone -o react-starter-kit -b master --single-branch       https://github.com/kriasoft/react-starter-kit.git myapp\n$ cd myapp\n$ yarn install\n$ yarn start\n```-->\n\n<!--## jsx-->\n\n\n\n### <strong class=\"title\">redux(一种架构模式)</strong>\n不同的组件之间需要共享读写一些数据。\n\n### <strong class=\"title\">dispatch</strong>\n定义 dispatch 专门负责数据的修改:\n``` js\nfunction dispatch (action) {\n  switch (action.type) {\n    case 'UPDATE_USER_NAME':\n      usrState.name = action.name;\n      break;\n    case 'UPDATE_USER_AGE':\n      userState.age = action.age;\n      break;\n    default:\n      break;\n  };\n};\n```\n\n对数据的操作必须通过dispatch函数，\n`action`是一个对象，包含`type`,`data`等内容。\n\n``` js\nconst params = {type: 'UPDATE_USER_NAME', name: 'name'};\ndispacth(params);\n// 修改了name\n```\n\n所有的全局变量数据必须先通过 dispatch, 并且必须用 action 通过 switch 确定修改什么。\n因此，无需再担心共享数据状态修改的问题。\n\n\n### <strong class=\"title\">store 构建state/dispatch 的集合</strong>\n\n`createStore`\n``` js\nfunction createStore (state, stateChanger) {\n  const getState = () => state\n  const dispatch = (action) => stateChanger(state, action)\n  return {getState, dispatch}\n}\n```\n`state`：应用程序状态。\n`stateChanger`:变化方法。\n`getState`:获取state的数据。\n`dispatch`:修改数据，接收action。\n\n如下修改数据生成的方式\n``` js\nlet usrState = {\n  name: 'xun',\n  age: 18\n};\n\nconst renderApp = (user) => {\n  const userDOM = document.getElementById('user');\n  userDOM.innerHTML = `${user.name},age:${user.age}`;\n};\n\nconst createStore = (state, stateChanger) => {\n  const getState = () => state;\n  const dispatch = (action) => stateChanger(state, action);\n  return {getState, dispatch};\n};\n\nconst stateChanger = (state, action) => {\n  switch (action.type) {\n    case 'UPDATE_USER_NAME':\n      usrState.name = action.name;\n      break;\n    case 'UPDATE_USER_AGE':\n      userState.age = action.age;\n      break;\n    default:\n      break;\n  };\n};\n\nconst store = createStore(usrState, stateChanger);\n\nrenderApp(store.getState()); // 首次渲染页面\n\nconst params = {type: 'UPDATE_USER_NAME', name: 'name'};\nstore.dispatch(params);\n\nrednerApp(store.getState()); // 渲染新数据\n```\n通过`store.dispatch`修改数据\n通过`store.getState`获取数据\n\n### <strong class=\"title\">监控数据变化</strong>\n上面的代码如果不手动renderApp的话，页面数据不会更新，因此需要自动渲染数据。\n修改`createStore`\n``` js\nconst createStore = (state, stateChanger) => {\n  const listeners = [];\n  const subscribe = (listener) => listeners.push(listener);\n  const getState = () => state;\n  const dispatch = (action) => {\n    stateChanger(state, action);\n    listeners.forEach((listener) => listener());\n  };\n  return {getState, dispatch, subscribe};\n};\n```\n通过`store.subscribe(listener)`传入监听函数，并存入数组中\n初始化时把`renderApp`传入数组中\n``` js\nconst store = createStore(appState, stateChanger)\nstore.subscribe(() => renderApp(store.getState()))\n\nrenderApp(store.getState()) // 首次渲染页面\n\nconst params = {type: 'UPDATE_USER_NAME', name: 'name'};\nstore.dispatch(params);\n// 自动更新数据...\n```\n\n### <strong class=\"title\">纯函数</strong>\n- 函数的返回结果只依赖于它的参数\n- 执行过程中不产生任何副作用\n\n### <strong class=\"title\">共享结构的对象,优化性能</strong>\n更新时，部分属性无改变，但仍旧重新渲染，耗费性能。\n`解决方案`:在渲染函数执行之前判断传入的新数据和已有的数据是否相同。\n``` js\nconst obj = { a: 1, b: 2}\nconst obj2 = { ...obj, b: 3, c: 4 } // => { a: 1, b: 3, c: 4 }\n```\n`obj2`潜复制`obj`,并能覆盖，拓展。为新旧数据对比提供支持。\n\n``` js\nlet usrState = {\n  name: 'xun',\n  age: 18\n};\n\nconst createStore = (state, stateChanger) => {\n  const listeners = [];\n  const subscribe = (listener) => listeners.push(listener);\n  const getState = () => state;\n  const dispatch = (action) => {\n    state = stateChanger(state, action);  // 覆盖原对象\n    listeners.forEach((listener) => listener());\n  };\n  return {getState, dispatch, subscribe};\n};\n\nconst renderApp = (newAppState, oldAppState = {}) => { // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = {}\n  if (newAppState === oldAppState) return; // 数据没有变化就不渲染了\n  console.log('render app...');\n  renderName(newAppState.name, oldAppState.name);\n  renderAge(newAppState.age, oldAppState.age);\n};\n\nconst renderName = (newName, oldName = {}) => {\n  if (newName === oldName) return; // 数据没有变化就不渲染了\n  console.log('render name...');\n  const nameDom = document.getElementById('name');\n  nameDom.innerHTML = newName.name;\n};\nconst renderAge = (newAge, oldAge = {}) => {\n  if (newAge === oldAge) return; // 数据没有变化就不渲染了\n  console.log('render age...');\n  const ageDom = document.getElementById('age');\n  ageDom.innerHTML = newAge.age;\n};\n\nconst stateChanger = (state, action) => {\n  switch (action.type) {\n    case 'UPDATE_USER_NAME':\n      return {\n        ...state,\n        name: action.name\n      }\n      break;\n    case 'UPDATE_USER_AGE':\n      return {\n        ...state,\n        age: action.age\n      }\n      break;\n    default:\n      return state;\n  };\n};\n\nconst store = createStore(usrState, stateChanger);\nlet oldState = store.getState(); // 缓存oldState\n\nstore.subscribe(() => {\n  const newState = store.getState(); // 数据可能变化，获取新的 state\n  renderApp(newState, oldState); // 把新旧的 state 传进去渲染\n  oldState = newState; // 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染\n});\n\nrenderApp(store.getState()); // 首次渲染页面\n\nconst params = {type: 'UPDATE_USER_NAME', name: 'name'};\nstore.dispatch(params);\n\nrednerApp(store.getState()); // 渲染新数据\n```\n### <strong class=\"title\">reducer</strong>\n让`createStore`接受一个纯函数`reducer`为参数\n`reducer`接受`action`&`state`两个参数\n如果没有传入state，返回初始化的数据，否则根据action复制/覆盖产生新state\n\n``` js\nconst createStore = (reducer) => {\n let state = null\n  const listeners = []\n  const subscribe = (listener) => listeners.push(listener)\n  const getState = () => state\n  const dispatch = (action) => {\n    state = reducer(state, action)\n    listeners.forEach((listener) => listener())\n  }\n  dispatch({}) // 初始化 state\n  return { getState, dispatch, subscribe }\n}\nconst themeReducer (state, action) => {\n  if (!state) return {\n    themeName: 'Red Theme',\n    themeColor: 'red'\n  }\n  switch (action.type) {\n    case 'UPATE_THEME_NAME':\n      return { ...state, themeName: action.themeName }\n    case 'UPATE_THEME_COLOR':\n      return { ...state, themeColor: action.themeColor }\n    default:\n      return state\n  }\n}\n\nconst store = createStore(themeReducer)\n```\n\n### <strong class=\"title\">REDUX的套路</strong>\n``` js\n/ 定一个 reducer\nfunction reducer (state, action) {\n  /* 初始化 state 和 switch case */\n}\n\n// 生成 store\nconst store = createStore(reducer)\n\n// 监听数据变化重新渲染页面\nstore.subscribe(() => renderApp(store.getState()))\n\n// 首次渲染页面\nrenderApp(store.getState()) \n\n// 后面可以随意 dispatch 了，页面自动更新\nstore.dispatch(...)\n```\n<style>\n.title {\n  color: RGBA(92, 201, 245, 1.00);\n}\n</style>","source":"_posts/react学习.md","raw":"---\ntitle: redux学习笔记\ndate: 2017-05-04 09:38:19\ntags: \n  - react\n  - javascript\n---\n愿这次笔记能记好。\n\n<!--more-->\n\n<!--# <strong class=\"title\">React</strong>\n\n## <strong class=\"title\">创建项目</strong>\n\n``` shell\n$ git clone -o react-starter-kit -b master --single-branch       https://github.com/kriasoft/react-starter-kit.git myapp\n$ cd myapp\n$ yarn install\n$ yarn start\n```-->\n\n<!--## jsx-->\n\n\n\n### <strong class=\"title\">redux(一种架构模式)</strong>\n不同的组件之间需要共享读写一些数据。\n\n### <strong class=\"title\">dispatch</strong>\n定义 dispatch 专门负责数据的修改:\n``` js\nfunction dispatch (action) {\n  switch (action.type) {\n    case 'UPDATE_USER_NAME':\n      usrState.name = action.name;\n      break;\n    case 'UPDATE_USER_AGE':\n      userState.age = action.age;\n      break;\n    default:\n      break;\n  };\n};\n```\n\n对数据的操作必须通过dispatch函数，\n`action`是一个对象，包含`type`,`data`等内容。\n\n``` js\nconst params = {type: 'UPDATE_USER_NAME', name: 'name'};\ndispacth(params);\n// 修改了name\n```\n\n所有的全局变量数据必须先通过 dispatch, 并且必须用 action 通过 switch 确定修改什么。\n因此，无需再担心共享数据状态修改的问题。\n\n\n### <strong class=\"title\">store 构建state/dispatch 的集合</strong>\n\n`createStore`\n``` js\nfunction createStore (state, stateChanger) {\n  const getState = () => state\n  const dispatch = (action) => stateChanger(state, action)\n  return {getState, dispatch}\n}\n```\n`state`：应用程序状态。\n`stateChanger`:变化方法。\n`getState`:获取state的数据。\n`dispatch`:修改数据，接收action。\n\n如下修改数据生成的方式\n``` js\nlet usrState = {\n  name: 'xun',\n  age: 18\n};\n\nconst renderApp = (user) => {\n  const userDOM = document.getElementById('user');\n  userDOM.innerHTML = `${user.name},age:${user.age}`;\n};\n\nconst createStore = (state, stateChanger) => {\n  const getState = () => state;\n  const dispatch = (action) => stateChanger(state, action);\n  return {getState, dispatch};\n};\n\nconst stateChanger = (state, action) => {\n  switch (action.type) {\n    case 'UPDATE_USER_NAME':\n      usrState.name = action.name;\n      break;\n    case 'UPDATE_USER_AGE':\n      userState.age = action.age;\n      break;\n    default:\n      break;\n  };\n};\n\nconst store = createStore(usrState, stateChanger);\n\nrenderApp(store.getState()); // 首次渲染页面\n\nconst params = {type: 'UPDATE_USER_NAME', name: 'name'};\nstore.dispatch(params);\n\nrednerApp(store.getState()); // 渲染新数据\n```\n通过`store.dispatch`修改数据\n通过`store.getState`获取数据\n\n### <strong class=\"title\">监控数据变化</strong>\n上面的代码如果不手动renderApp的话，页面数据不会更新，因此需要自动渲染数据。\n修改`createStore`\n``` js\nconst createStore = (state, stateChanger) => {\n  const listeners = [];\n  const subscribe = (listener) => listeners.push(listener);\n  const getState = () => state;\n  const dispatch = (action) => {\n    stateChanger(state, action);\n    listeners.forEach((listener) => listener());\n  };\n  return {getState, dispatch, subscribe};\n};\n```\n通过`store.subscribe(listener)`传入监听函数，并存入数组中\n初始化时把`renderApp`传入数组中\n``` js\nconst store = createStore(appState, stateChanger)\nstore.subscribe(() => renderApp(store.getState()))\n\nrenderApp(store.getState()) // 首次渲染页面\n\nconst params = {type: 'UPDATE_USER_NAME', name: 'name'};\nstore.dispatch(params);\n// 自动更新数据...\n```\n\n### <strong class=\"title\">纯函数</strong>\n- 函数的返回结果只依赖于它的参数\n- 执行过程中不产生任何副作用\n\n### <strong class=\"title\">共享结构的对象,优化性能</strong>\n更新时，部分属性无改变，但仍旧重新渲染，耗费性能。\n`解决方案`:在渲染函数执行之前判断传入的新数据和已有的数据是否相同。\n``` js\nconst obj = { a: 1, b: 2}\nconst obj2 = { ...obj, b: 3, c: 4 } // => { a: 1, b: 3, c: 4 }\n```\n`obj2`潜复制`obj`,并能覆盖，拓展。为新旧数据对比提供支持。\n\n``` js\nlet usrState = {\n  name: 'xun',\n  age: 18\n};\n\nconst createStore = (state, stateChanger) => {\n  const listeners = [];\n  const subscribe = (listener) => listeners.push(listener);\n  const getState = () => state;\n  const dispatch = (action) => {\n    state = stateChanger(state, action);  // 覆盖原对象\n    listeners.forEach((listener) => listener());\n  };\n  return {getState, dispatch, subscribe};\n};\n\nconst renderApp = (newAppState, oldAppState = {}) => { // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = {}\n  if (newAppState === oldAppState) return; // 数据没有变化就不渲染了\n  console.log('render app...');\n  renderName(newAppState.name, oldAppState.name);\n  renderAge(newAppState.age, oldAppState.age);\n};\n\nconst renderName = (newName, oldName = {}) => {\n  if (newName === oldName) return; // 数据没有变化就不渲染了\n  console.log('render name...');\n  const nameDom = document.getElementById('name');\n  nameDom.innerHTML = newName.name;\n};\nconst renderAge = (newAge, oldAge = {}) => {\n  if (newAge === oldAge) return; // 数据没有变化就不渲染了\n  console.log('render age...');\n  const ageDom = document.getElementById('age');\n  ageDom.innerHTML = newAge.age;\n};\n\nconst stateChanger = (state, action) => {\n  switch (action.type) {\n    case 'UPDATE_USER_NAME':\n      return {\n        ...state,\n        name: action.name\n      }\n      break;\n    case 'UPDATE_USER_AGE':\n      return {\n        ...state,\n        age: action.age\n      }\n      break;\n    default:\n      return state;\n  };\n};\n\nconst store = createStore(usrState, stateChanger);\nlet oldState = store.getState(); // 缓存oldState\n\nstore.subscribe(() => {\n  const newState = store.getState(); // 数据可能变化，获取新的 state\n  renderApp(newState, oldState); // 把新旧的 state 传进去渲染\n  oldState = newState; // 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染\n});\n\nrenderApp(store.getState()); // 首次渲染页面\n\nconst params = {type: 'UPDATE_USER_NAME', name: 'name'};\nstore.dispatch(params);\n\nrednerApp(store.getState()); // 渲染新数据\n```\n### <strong class=\"title\">reducer</strong>\n让`createStore`接受一个纯函数`reducer`为参数\n`reducer`接受`action`&`state`两个参数\n如果没有传入state，返回初始化的数据，否则根据action复制/覆盖产生新state\n\n``` js\nconst createStore = (reducer) => {\n let state = null\n  const listeners = []\n  const subscribe = (listener) => listeners.push(listener)\n  const getState = () => state\n  const dispatch = (action) => {\n    state = reducer(state, action)\n    listeners.forEach((listener) => listener())\n  }\n  dispatch({}) // 初始化 state\n  return { getState, dispatch, subscribe }\n}\nconst themeReducer (state, action) => {\n  if (!state) return {\n    themeName: 'Red Theme',\n    themeColor: 'red'\n  }\n  switch (action.type) {\n    case 'UPATE_THEME_NAME':\n      return { ...state, themeName: action.themeName }\n    case 'UPATE_THEME_COLOR':\n      return { ...state, themeColor: action.themeColor }\n    default:\n      return state\n  }\n}\n\nconst store = createStore(themeReducer)\n```\n\n### <strong class=\"title\">REDUX的套路</strong>\n``` js\n/ 定一个 reducer\nfunction reducer (state, action) {\n  /* 初始化 state 和 switch case */\n}\n\n// 生成 store\nconst store = createStore(reducer)\n\n// 监听数据变化重新渲染页面\nstore.subscribe(() => renderApp(store.getState()))\n\n// 首次渲染页面\nrenderApp(store.getState()) \n\n// 后面可以随意 dispatch 了，页面自动更新\nstore.dispatch(...)\n```\n<style>\n.title {\n  color: RGBA(92, 201, 245, 1.00);\n}\n</style>","slug":"react学习","published":1,"updated":"2017-05-05T01:58:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2t000sttwpi44admn4","content":"<p>愿这次笔记能记好。</p>\n<a id=\"more\"></a>\n<!--# <strong class=\"title\">React</strong>\n\n## <strong class=\"title\">创建项目</strong>\n\n``` shell\n$ git clone -o react-starter-kit -b master --single-branch       https://github.com/kriasoft/react-starter-kit.git myapp\n$ cd myapp\n$ yarn install\n$ yarn start\n```-->\n<!--## jsx-->\n<h3 id=\"redux-一种架构模式\"><a href=\"#redux-一种架构模式\" class=\"headerlink\" title=\"redux(一种架构模式)\"></a><strong class=\"title\">redux(一种架构模式)</strong></h3><p>不同的组件之间需要共享读写一些数据。</p>\n<h3 id=\"dispatch\"><a href=\"#dispatch\" class=\"headerlink\" title=\"dispatch\"></a><strong class=\"title\">dispatch</strong></h3><p>定义 dispatch 专门负责数据的修改:</p>\n<pre><code class=\"js\">function dispatch (action) {\n  switch (action.type) {\n    case &#39;UPDATE_USER_NAME&#39;:\n      usrState.name = action.name;\n      break;\n    case &#39;UPDATE_USER_AGE&#39;:\n      userState.age = action.age;\n      break;\n    default:\n      break;\n  };\n};\n</code></pre>\n<p>对数据的操作必须通过dispatch函数，<br><code>action</code>是一个对象，包含<code>type</code>,<code>data</code>等内容。</p>\n<pre><code class=\"js\">const params = {type: &#39;UPDATE_USER_NAME&#39;, name: &#39;name&#39;};\ndispacth(params);\n// 修改了name\n</code></pre>\n<p>所有的全局变量数据必须先通过 dispatch, 并且必须用 action 通过 switch 确定修改什么。<br>因此，无需再担心共享数据状态修改的问题。</p>\n<h3 id=\"store-构建state-dispatch-的集合\"><a href=\"#store-构建state-dispatch-的集合\" class=\"headerlink\" title=\"store 构建state/dispatch 的集合\"></a><strong class=\"title\">store 构建state/dispatch 的集合</strong></h3><p><code>createStore</code></p>\n<pre><code class=\"js\">function createStore (state, stateChanger) {\n  const getState = () =&gt; state\n  const dispatch = (action) =&gt; stateChanger(state, action)\n  return {getState, dispatch}\n}\n</code></pre>\n<p><code>state</code>：应用程序状态。<br><code>stateChanger</code>:变化方法。<br><code>getState</code>:获取state的数据。<br><code>dispatch</code>:修改数据，接收action。</p>\n<p>如下修改数据生成的方式</p>\n<pre><code class=\"js\">let usrState = {\n  name: &#39;xun&#39;,\n  age: 18\n};\n\nconst renderApp = (user) =&gt; {\n  const userDOM = document.getElementById(&#39;user&#39;);\n  userDOM.innerHTML = `${user.name},age:${user.age}`;\n};\n\nconst createStore = (state, stateChanger) =&gt; {\n  const getState = () =&gt; state;\n  const dispatch = (action) =&gt; stateChanger(state, action);\n  return {getState, dispatch};\n};\n\nconst stateChanger = (state, action) =&gt; {\n  switch (action.type) {\n    case &#39;UPDATE_USER_NAME&#39;:\n      usrState.name = action.name;\n      break;\n    case &#39;UPDATE_USER_AGE&#39;:\n      userState.age = action.age;\n      break;\n    default:\n      break;\n  };\n};\n\nconst store = createStore(usrState, stateChanger);\n\nrenderApp(store.getState()); // 首次渲染页面\n\nconst params = {type: &#39;UPDATE_USER_NAME&#39;, name: &#39;name&#39;};\nstore.dispatch(params);\n\nrednerApp(store.getState()); // 渲染新数据\n</code></pre>\n<p>通过<code>store.dispatch</code>修改数据<br>通过<code>store.getState</code>获取数据</p>\n<h3 id=\"监控数据变化\"><a href=\"#监控数据变化\" class=\"headerlink\" title=\"监控数据变化\"></a><strong class=\"title\">监控数据变化</strong></h3><p>上面的代码如果不手动renderApp的话，页面数据不会更新，因此需要自动渲染数据。<br>修改<code>createStore</code></p>\n<pre><code class=\"js\">const createStore = (state, stateChanger) =&gt; {\n  const listeners = [];\n  const subscribe = (listener) =&gt; listeners.push(listener);\n  const getState = () =&gt; state;\n  const dispatch = (action) =&gt; {\n    stateChanger(state, action);\n    listeners.forEach((listener) =&gt; listener());\n  };\n  return {getState, dispatch, subscribe};\n};\n</code></pre>\n<p>通过<code>store.subscribe(listener)</code>传入监听函数，并存入数组中<br>初始化时把<code>renderApp</code>传入数组中</p>\n<pre><code class=\"js\">const store = createStore(appState, stateChanger)\nstore.subscribe(() =&gt; renderApp(store.getState()))\n\nrenderApp(store.getState()) // 首次渲染页面\n\nconst params = {type: &#39;UPDATE_USER_NAME&#39;, name: &#39;name&#39;};\nstore.dispatch(params);\n// 自动更新数据...\n</code></pre>\n<h3 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a><strong class=\"title\">纯函数</strong></h3><ul>\n<li>函数的返回结果只依赖于它的参数</li>\n<li>执行过程中不产生任何副作用</li>\n</ul>\n<h3 id=\"共享结构的对象-优化性能\"><a href=\"#共享结构的对象-优化性能\" class=\"headerlink\" title=\"共享结构的对象,优化性能\"></a><strong class=\"title\">共享结构的对象,优化性能</strong></h3><p>更新时，部分属性无改变，但仍旧重新渲染，耗费性能。<br><code>解决方案</code>:在渲染函数执行之前判断传入的新数据和已有的数据是否相同。</p>\n<pre><code class=\"js\">const obj = { a: 1, b: 2}\nconst obj2 = { ...obj, b: 3, c: 4 } // =&gt; { a: 1, b: 3, c: 4 }\n</code></pre>\n<p><code>obj2</code>潜复制<code>obj</code>,并能覆盖，拓展。为新旧数据对比提供支持。</p>\n<pre><code class=\"js\">let usrState = {\n  name: &#39;xun&#39;,\n  age: 18\n};\n\nconst createStore = (state, stateChanger) =&gt; {\n  const listeners = [];\n  const subscribe = (listener) =&gt; listeners.push(listener);\n  const getState = () =&gt; state;\n  const dispatch = (action) =&gt; {\n    state = stateChanger(state, action);  // 覆盖原对象\n    listeners.forEach((listener) =&gt; listener());\n  };\n  return {getState, dispatch, subscribe};\n};\n\nconst renderApp = (newAppState, oldAppState = {}) =&gt; { // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = {}\n  if (newAppState === oldAppState) return; // 数据没有变化就不渲染了\n  console.log(&#39;render app...&#39;);\n  renderName(newAppState.name, oldAppState.name);\n  renderAge(newAppState.age, oldAppState.age);\n};\n\nconst renderName = (newName, oldName = {}) =&gt; {\n  if (newName === oldName) return; // 数据没有变化就不渲染了\n  console.log(&#39;render name...&#39;);\n  const nameDom = document.getElementById(&#39;name&#39;);\n  nameDom.innerHTML = newName.name;\n};\nconst renderAge = (newAge, oldAge = {}) =&gt; {\n  if (newAge === oldAge) return; // 数据没有变化就不渲染了\n  console.log(&#39;render age...&#39;);\n  const ageDom = document.getElementById(&#39;age&#39;);\n  ageDom.innerHTML = newAge.age;\n};\n\nconst stateChanger = (state, action) =&gt; {\n  switch (action.type) {\n    case &#39;UPDATE_USER_NAME&#39;:\n      return {\n        ...state,\n        name: action.name\n      }\n      break;\n    case &#39;UPDATE_USER_AGE&#39;:\n      return {\n        ...state,\n        age: action.age\n      }\n      break;\n    default:\n      return state;\n  };\n};\n\nconst store = createStore(usrState, stateChanger);\nlet oldState = store.getState(); // 缓存oldState\n\nstore.subscribe(() =&gt; {\n  const newState = store.getState(); // 数据可能变化，获取新的 state\n  renderApp(newState, oldState); // 把新旧的 state 传进去渲染\n  oldState = newState; // 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染\n});\n\nrenderApp(store.getState()); // 首次渲染页面\n\nconst params = {type: &#39;UPDATE_USER_NAME&#39;, name: &#39;name&#39;};\nstore.dispatch(params);\n\nrednerApp(store.getState()); // 渲染新数据\n</code></pre>\n<h3 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a><strong class=\"title\">reducer</strong></h3><p>让<code>createStore</code>接受一个纯函数<code>reducer</code>为参数<br><code>reducer</code>接受<code>action</code>&amp;<code>state</code>两个参数<br>如果没有传入state，返回初始化的数据，否则根据action复制/覆盖产生新state</p>\n<pre><code class=\"js\">const createStore = (reducer) =&gt; {\n let state = null\n  const listeners = []\n  const subscribe = (listener) =&gt; listeners.push(listener)\n  const getState = () =&gt; state\n  const dispatch = (action) =&gt; {\n    state = reducer(state, action)\n    listeners.forEach((listener) =&gt; listener())\n  }\n  dispatch({}) // 初始化 state\n  return { getState, dispatch, subscribe }\n}\nconst themeReducer (state, action) =&gt; {\n  if (!state) return {\n    themeName: &#39;Red Theme&#39;,\n    themeColor: &#39;red&#39;\n  }\n  switch (action.type) {\n    case &#39;UPATE_THEME_NAME&#39;:\n      return { ...state, themeName: action.themeName }\n    case &#39;UPATE_THEME_COLOR&#39;:\n      return { ...state, themeColor: action.themeColor }\n    default:\n      return state\n  }\n}\n\nconst store = createStore(themeReducer)\n</code></pre>\n<h3 id=\"REDUX的套路\"><a href=\"#REDUX的套路\" class=\"headerlink\" title=\"REDUX的套路\"></a><strong class=\"title\">REDUX的套路</strong></h3><pre><code class=\"js\">/ 定一个 reducer\nfunction reducer (state, action) {\n  /* 初始化 state 和 switch case */\n}\n\n// 生成 store\nconst store = createStore(reducer)\n\n// 监听数据变化重新渲染页面\nstore.subscribe(() =&gt; renderApp(store.getState()))\n\n// 首次渲染页面\nrenderApp(store.getState()) \n\n// 后面可以随意 dispatch 了，页面自动更新\nstore.dispatch(...)\n</code></pre>\n<style>\n.title {\n  color: RGBA(92, 201, 245, 1.00);\n}\n</style>","site":{"data":{}},"excerpt":"<p>愿这次笔记能记好。</p>","more":"<!--# <strong class=\"title\">React</strong>\n\n## <strong class=\"title\">创建项目</strong>\n\n``` shell\n$ git clone -o react-starter-kit -b master --single-branch       https://github.com/kriasoft/react-starter-kit.git myapp\n$ cd myapp\n$ yarn install\n$ yarn start\n```-->\n<!--## jsx-->\n<h3 id=\"redux-一种架构模式\"><a href=\"#redux-一种架构模式\" class=\"headerlink\" title=\"redux(一种架构模式)\"></a><strong class=\"title\">redux(一种架构模式)</strong></h3><p>不同的组件之间需要共享读写一些数据。</p>\n<h3 id=\"dispatch\"><a href=\"#dispatch\" class=\"headerlink\" title=\"dispatch\"></a><strong class=\"title\">dispatch</strong></h3><p>定义 dispatch 专门负责数据的修改:</p>\n<pre><code class=\"js\">function dispatch (action) {\n  switch (action.type) {\n    case &#39;UPDATE_USER_NAME&#39;:\n      usrState.name = action.name;\n      break;\n    case &#39;UPDATE_USER_AGE&#39;:\n      userState.age = action.age;\n      break;\n    default:\n      break;\n  };\n};\n</code></pre>\n<p>对数据的操作必须通过dispatch函数，<br><code>action</code>是一个对象，包含<code>type</code>,<code>data</code>等内容。</p>\n<pre><code class=\"js\">const params = {type: &#39;UPDATE_USER_NAME&#39;, name: &#39;name&#39;};\ndispacth(params);\n// 修改了name\n</code></pre>\n<p>所有的全局变量数据必须先通过 dispatch, 并且必须用 action 通过 switch 确定修改什么。<br>因此，无需再担心共享数据状态修改的问题。</p>\n<h3 id=\"store-构建state-dispatch-的集合\"><a href=\"#store-构建state-dispatch-的集合\" class=\"headerlink\" title=\"store 构建state/dispatch 的集合\"></a><strong class=\"title\">store 构建state/dispatch 的集合</strong></h3><p><code>createStore</code></p>\n<pre><code class=\"js\">function createStore (state, stateChanger) {\n  const getState = () =&gt; state\n  const dispatch = (action) =&gt; stateChanger(state, action)\n  return {getState, dispatch}\n}\n</code></pre>\n<p><code>state</code>：应用程序状态。<br><code>stateChanger</code>:变化方法。<br><code>getState</code>:获取state的数据。<br><code>dispatch</code>:修改数据，接收action。</p>\n<p>如下修改数据生成的方式</p>\n<pre><code class=\"js\">let usrState = {\n  name: &#39;xun&#39;,\n  age: 18\n};\n\nconst renderApp = (user) =&gt; {\n  const userDOM = document.getElementById(&#39;user&#39;);\n  userDOM.innerHTML = `${user.name},age:${user.age}`;\n};\n\nconst createStore = (state, stateChanger) =&gt; {\n  const getState = () =&gt; state;\n  const dispatch = (action) =&gt; stateChanger(state, action);\n  return {getState, dispatch};\n};\n\nconst stateChanger = (state, action) =&gt; {\n  switch (action.type) {\n    case &#39;UPDATE_USER_NAME&#39;:\n      usrState.name = action.name;\n      break;\n    case &#39;UPDATE_USER_AGE&#39;:\n      userState.age = action.age;\n      break;\n    default:\n      break;\n  };\n};\n\nconst store = createStore(usrState, stateChanger);\n\nrenderApp(store.getState()); // 首次渲染页面\n\nconst params = {type: &#39;UPDATE_USER_NAME&#39;, name: &#39;name&#39;};\nstore.dispatch(params);\n\nrednerApp(store.getState()); // 渲染新数据\n</code></pre>\n<p>通过<code>store.dispatch</code>修改数据<br>通过<code>store.getState</code>获取数据</p>\n<h3 id=\"监控数据变化\"><a href=\"#监控数据变化\" class=\"headerlink\" title=\"监控数据变化\"></a><strong class=\"title\">监控数据变化</strong></h3><p>上面的代码如果不手动renderApp的话，页面数据不会更新，因此需要自动渲染数据。<br>修改<code>createStore</code></p>\n<pre><code class=\"js\">const createStore = (state, stateChanger) =&gt; {\n  const listeners = [];\n  const subscribe = (listener) =&gt; listeners.push(listener);\n  const getState = () =&gt; state;\n  const dispatch = (action) =&gt; {\n    stateChanger(state, action);\n    listeners.forEach((listener) =&gt; listener());\n  };\n  return {getState, dispatch, subscribe};\n};\n</code></pre>\n<p>通过<code>store.subscribe(listener)</code>传入监听函数，并存入数组中<br>初始化时把<code>renderApp</code>传入数组中</p>\n<pre><code class=\"js\">const store = createStore(appState, stateChanger)\nstore.subscribe(() =&gt; renderApp(store.getState()))\n\nrenderApp(store.getState()) // 首次渲染页面\n\nconst params = {type: &#39;UPDATE_USER_NAME&#39;, name: &#39;name&#39;};\nstore.dispatch(params);\n// 自动更新数据...\n</code></pre>\n<h3 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a><strong class=\"title\">纯函数</strong></h3><ul>\n<li>函数的返回结果只依赖于它的参数</li>\n<li>执行过程中不产生任何副作用</li>\n</ul>\n<h3 id=\"共享结构的对象-优化性能\"><a href=\"#共享结构的对象-优化性能\" class=\"headerlink\" title=\"共享结构的对象,优化性能\"></a><strong class=\"title\">共享结构的对象,优化性能</strong></h3><p>更新时，部分属性无改变，但仍旧重新渲染，耗费性能。<br><code>解决方案</code>:在渲染函数执行之前判断传入的新数据和已有的数据是否相同。</p>\n<pre><code class=\"js\">const obj = { a: 1, b: 2}\nconst obj2 = { ...obj, b: 3, c: 4 } // =&gt; { a: 1, b: 3, c: 4 }\n</code></pre>\n<p><code>obj2</code>潜复制<code>obj</code>,并能覆盖，拓展。为新旧数据对比提供支持。</p>\n<pre><code class=\"js\">let usrState = {\n  name: &#39;xun&#39;,\n  age: 18\n};\n\nconst createStore = (state, stateChanger) =&gt; {\n  const listeners = [];\n  const subscribe = (listener) =&gt; listeners.push(listener);\n  const getState = () =&gt; state;\n  const dispatch = (action) =&gt; {\n    state = stateChanger(state, action);  // 覆盖原对象\n    listeners.forEach((listener) =&gt; listener());\n  };\n  return {getState, dispatch, subscribe};\n};\n\nconst renderApp = (newAppState, oldAppState = {}) =&gt; { // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = {}\n  if (newAppState === oldAppState) return; // 数据没有变化就不渲染了\n  console.log(&#39;render app...&#39;);\n  renderName(newAppState.name, oldAppState.name);\n  renderAge(newAppState.age, oldAppState.age);\n};\n\nconst renderName = (newName, oldName = {}) =&gt; {\n  if (newName === oldName) return; // 数据没有变化就不渲染了\n  console.log(&#39;render name...&#39;);\n  const nameDom = document.getElementById(&#39;name&#39;);\n  nameDom.innerHTML = newName.name;\n};\nconst renderAge = (newAge, oldAge = {}) =&gt; {\n  if (newAge === oldAge) return; // 数据没有变化就不渲染了\n  console.log(&#39;render age...&#39;);\n  const ageDom = document.getElementById(&#39;age&#39;);\n  ageDom.innerHTML = newAge.age;\n};\n\nconst stateChanger = (state, action) =&gt; {\n  switch (action.type) {\n    case &#39;UPDATE_USER_NAME&#39;:\n      return {\n        ...state,\n        name: action.name\n      }\n      break;\n    case &#39;UPDATE_USER_AGE&#39;:\n      return {\n        ...state,\n        age: action.age\n      }\n      break;\n    default:\n      return state;\n  };\n};\n\nconst store = createStore(usrState, stateChanger);\nlet oldState = store.getState(); // 缓存oldState\n\nstore.subscribe(() =&gt; {\n  const newState = store.getState(); // 数据可能变化，获取新的 state\n  renderApp(newState, oldState); // 把新旧的 state 传进去渲染\n  oldState = newState; // 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染\n});\n\nrenderApp(store.getState()); // 首次渲染页面\n\nconst params = {type: &#39;UPDATE_USER_NAME&#39;, name: &#39;name&#39;};\nstore.dispatch(params);\n\nrednerApp(store.getState()); // 渲染新数据\n</code></pre>\n<h3 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a><strong class=\"title\">reducer</strong></h3><p>让<code>createStore</code>接受一个纯函数<code>reducer</code>为参数<br><code>reducer</code>接受<code>action</code>&amp;<code>state</code>两个参数<br>如果没有传入state，返回初始化的数据，否则根据action复制/覆盖产生新state</p>\n<pre><code class=\"js\">const createStore = (reducer) =&gt; {\n let state = null\n  const listeners = []\n  const subscribe = (listener) =&gt; listeners.push(listener)\n  const getState = () =&gt; state\n  const dispatch = (action) =&gt; {\n    state = reducer(state, action)\n    listeners.forEach((listener) =&gt; listener())\n  }\n  dispatch({}) // 初始化 state\n  return { getState, dispatch, subscribe }\n}\nconst themeReducer (state, action) =&gt; {\n  if (!state) return {\n    themeName: &#39;Red Theme&#39;,\n    themeColor: &#39;red&#39;\n  }\n  switch (action.type) {\n    case &#39;UPATE_THEME_NAME&#39;:\n      return { ...state, themeName: action.themeName }\n    case &#39;UPATE_THEME_COLOR&#39;:\n      return { ...state, themeColor: action.themeColor }\n    default:\n      return state\n  }\n}\n\nconst store = createStore(themeReducer)\n</code></pre>\n<h3 id=\"REDUX的套路\"><a href=\"#REDUX的套路\" class=\"headerlink\" title=\"REDUX的套路\"></a><strong class=\"title\">REDUX的套路</strong></h3><pre><code class=\"js\">/ 定一个 reducer\nfunction reducer (state, action) {\n  /* 初始化 state 和 switch case */\n}\n\n// 生成 store\nconst store = createStore(reducer)\n\n// 监听数据变化重新渲染页面\nstore.subscribe(() =&gt; renderApp(store.getState()))\n\n// 首次渲染页面\nrenderApp(store.getState()) \n\n// 后面可以随意 dispatch 了，页面自动更新\nstore.dispatch(...)\n</code></pre>\n<style>\n.title {\n  color: RGBA(92, 201, 245, 1.00);\n}\n</style>"},{"title":"three.js入门","date":"2017-03-06T15:03:49.000Z","_content":"非常想学习webGL和three.js，这次借着百度前端学院来学一波！\n\n<!--more-->\n\n## 起步\n直接引用 three.js\n\n### 三大组件\n场景 (scene)，相机 (camera)，渲染器 (renderer)\n\n#### scene\n场景是所有物体的容器\n```js\nvar scene = new THREE.Scene();\n```\n\n#### camera\n相机决定了场景中那个角度的景色会显示出来,角度不同看到的景色也不同\n```js\nvar camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);// 透视相机\n```\n\n#### renderer\n渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制\n```js\nvar renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n```\n渲染器renderer的domElement元素，表示渲染器中的画布，所有的渲染都是画在domElement上的\n\n- 添加物体到场景中\n\n```js\nvar geometry = new THREE.CubeGeometry(1,1,1);\nvar material = new THREE.MeshBasicMaterial({color: 0x00ff00});\nvar cube = new THREE.Mesh(geometry, material);\nscene.add(cube);\n```\n\n- 渲染\n\n```js\nrenderer.render(scene, camera);\n```\n\n### 画一条线\n\n#### 定义几何体\n\n```js\nvar geometry = new THREE.Geometry();\n```\n几何体中的变量`vertices`可以存放点\n\n##### 定义线条的材质\n\n```js\nTHREE.LineBasicMaterial(parameters)\nparameters: {\n  Color: '线条的颜色，用16进制来表示，默认的颜色是白色',\n  Linewidth: '线条的宽度，默认为1'，\n  Linecap: '线条两端的外观，默认是圆角端点',\n  Linejoin: '两个线条的连接点处的外观，默认是“round”，表示圆角',\n  VertexColors: '定义线条材质是否使用顶点颜色，这是一个boolean值。意思是，线条各部分的颜色会根据顶点的颜色来进行插值',\n  Fog: '定义材质的颜色是否受全局雾效的影响'\n}\n```\n\n```js\nvar material = new THREE.LineBasicMaterial( { vertexColors: true } )\n```\n\n#### 定义顶点颜色\n\n```js\nvar color1 = new THREE.Color( 0x444444 );\nvar color2 = new THREE.Color( 0xFF0000 );\n```\n\n#### 定义顶点位置,存放到几何体geometry中\n\n```js\nvar p1 = new THREE.Vector3( -100, 0, 100 );\nvar p2 = new THREE.Vector3( 100, 0, -100 );\ngeometry.vertices.push(p1);\ngeometry.vertices.push(p2);\n```\n\n#### 给顶点设置颜色\n\n```js\ngeometry.colors.push( color1, color2 );\n```\n\n#### 定义一条线\n\n```js\nvar line = new THREE.Line( geometry, material, THREE.LinePieces );\nscene.add(line);\n```\n\n#### 右手坐标系\nx轴正方向向右，y轴正方向向上，z轴由屏幕从里向外。\n\n#### 线条的深入理解\n","source":"_posts/three-js入门.md","raw":"---\ntitle: three.js入门\ndate: 2017-03-06 23:03:49\ntags:\n---\n非常想学习webGL和three.js，这次借着百度前端学院来学一波！\n\n<!--more-->\n\n## 起步\n直接引用 three.js\n\n### 三大组件\n场景 (scene)，相机 (camera)，渲染器 (renderer)\n\n#### scene\n场景是所有物体的容器\n```js\nvar scene = new THREE.Scene();\n```\n\n#### camera\n相机决定了场景中那个角度的景色会显示出来,角度不同看到的景色也不同\n```js\nvar camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);// 透视相机\n```\n\n#### renderer\n渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制\n```js\nvar renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n```\n渲染器renderer的domElement元素，表示渲染器中的画布，所有的渲染都是画在domElement上的\n\n- 添加物体到场景中\n\n```js\nvar geometry = new THREE.CubeGeometry(1,1,1);\nvar material = new THREE.MeshBasicMaterial({color: 0x00ff00});\nvar cube = new THREE.Mesh(geometry, material);\nscene.add(cube);\n```\n\n- 渲染\n\n```js\nrenderer.render(scene, camera);\n```\n\n### 画一条线\n\n#### 定义几何体\n\n```js\nvar geometry = new THREE.Geometry();\n```\n几何体中的变量`vertices`可以存放点\n\n##### 定义线条的材质\n\n```js\nTHREE.LineBasicMaterial(parameters)\nparameters: {\n  Color: '线条的颜色，用16进制来表示，默认的颜色是白色',\n  Linewidth: '线条的宽度，默认为1'，\n  Linecap: '线条两端的外观，默认是圆角端点',\n  Linejoin: '两个线条的连接点处的外观，默认是“round”，表示圆角',\n  VertexColors: '定义线条材质是否使用顶点颜色，这是一个boolean值。意思是，线条各部分的颜色会根据顶点的颜色来进行插值',\n  Fog: '定义材质的颜色是否受全局雾效的影响'\n}\n```\n\n```js\nvar material = new THREE.LineBasicMaterial( { vertexColors: true } )\n```\n\n#### 定义顶点颜色\n\n```js\nvar color1 = new THREE.Color( 0x444444 );\nvar color2 = new THREE.Color( 0xFF0000 );\n```\n\n#### 定义顶点位置,存放到几何体geometry中\n\n```js\nvar p1 = new THREE.Vector3( -100, 0, 100 );\nvar p2 = new THREE.Vector3( 100, 0, -100 );\ngeometry.vertices.push(p1);\ngeometry.vertices.push(p2);\n```\n\n#### 给顶点设置颜色\n\n```js\ngeometry.colors.push( color1, color2 );\n```\n\n#### 定义一条线\n\n```js\nvar line = new THREE.Line( geometry, material, THREE.LinePieces );\nscene.add(line);\n```\n\n#### 右手坐标系\nx轴正方向向右，y轴正方向向上，z轴由屏幕从里向外。\n\n#### 线条的深入理解\n","slug":"three-js入门","published":1,"updated":"2017-10-15T02:51:50.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2u000tttwps0l3879u","content":"<p>非常想学习webGL和three.js，这次借着百度前端学院来学一波！</p>\n<a id=\"more\"></a>\n<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><p>直接引用 three.js</p>\n<h3 id=\"三大组件\"><a href=\"#三大组件\" class=\"headerlink\" title=\"三大组件\"></a>三大组件</h3><p>场景 (scene)，相机 (camera)，渲染器 (renderer)</p>\n<h4 id=\"scene\"><a href=\"#scene\" class=\"headerlink\" title=\"scene\"></a>scene</h4><p>场景是所有物体的容器</p>\n<pre><code class=\"js\">var scene = new THREE.Scene();\n</code></pre>\n<h4 id=\"camera\"><a href=\"#camera\" class=\"headerlink\" title=\"camera\"></a>camera</h4><p>相机决定了场景中那个角度的景色会显示出来,角度不同看到的景色也不同</p>\n<pre><code class=\"js\">var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);// 透视相机\n</code></pre>\n<h4 id=\"renderer\"><a href=\"#renderer\" class=\"headerlink\" title=\"renderer\"></a>renderer</h4><p>渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制</p>\n<pre><code class=\"js\">var renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n</code></pre>\n<p>渲染器renderer的domElement元素，表示渲染器中的画布，所有的渲染都是画在domElement上的</p>\n<ul>\n<li>添加物体到场景中</li>\n</ul>\n<pre><code class=\"js\">var geometry = new THREE.CubeGeometry(1,1,1);\nvar material = new THREE.MeshBasicMaterial({color: 0x00ff00});\nvar cube = new THREE.Mesh(geometry, material);\nscene.add(cube);\n</code></pre>\n<ul>\n<li>渲染</li>\n</ul>\n<pre><code class=\"js\">renderer.render(scene, camera);\n</code></pre>\n<h3 id=\"画一条线\"><a href=\"#画一条线\" class=\"headerlink\" title=\"画一条线\"></a>画一条线</h3><h4 id=\"定义几何体\"><a href=\"#定义几何体\" class=\"headerlink\" title=\"定义几何体\"></a>定义几何体</h4><pre><code class=\"js\">var geometry = new THREE.Geometry();\n</code></pre>\n<p>几何体中的变量<code>vertices</code>可以存放点</p>\n<h5 id=\"定义线条的材质\"><a href=\"#定义线条的材质\" class=\"headerlink\" title=\"定义线条的材质\"></a>定义线条的材质</h5><pre><code class=\"js\">THREE.LineBasicMaterial(parameters)\nparameters: {\n  Color: &#39;线条的颜色，用16进制来表示，默认的颜色是白色&#39;,\n  Linewidth: &#39;线条的宽度，默认为1&#39;，\n  Linecap: &#39;线条两端的外观，默认是圆角端点&#39;,\n  Linejoin: &#39;两个线条的连接点处的外观，默认是“round”，表示圆角&#39;,\n  VertexColors: &#39;定义线条材质是否使用顶点颜色，这是一个boolean值。意思是，线条各部分的颜色会根据顶点的颜色来进行插值&#39;,\n  Fog: &#39;定义材质的颜色是否受全局雾效的影响&#39;\n}\n</code></pre>\n<pre><code class=\"js\">var material = new THREE.LineBasicMaterial( { vertexColors: true } )\n</code></pre>\n<h4 id=\"定义顶点颜色\"><a href=\"#定义顶点颜色\" class=\"headerlink\" title=\"定义顶点颜色\"></a>定义顶点颜色</h4><pre><code class=\"js\">var color1 = new THREE.Color( 0x444444 );\nvar color2 = new THREE.Color( 0xFF0000 );\n</code></pre>\n<h4 id=\"定义顶点位置-存放到几何体geometry中\"><a href=\"#定义顶点位置-存放到几何体geometry中\" class=\"headerlink\" title=\"定义顶点位置,存放到几何体geometry中\"></a>定义顶点位置,存放到几何体geometry中</h4><pre><code class=\"js\">var p1 = new THREE.Vector3( -100, 0, 100 );\nvar p2 = new THREE.Vector3( 100, 0, -100 );\ngeometry.vertices.push(p1);\ngeometry.vertices.push(p2);\n</code></pre>\n<h4 id=\"给顶点设置颜色\"><a href=\"#给顶点设置颜色\" class=\"headerlink\" title=\"给顶点设置颜色\"></a>给顶点设置颜色</h4><pre><code class=\"js\">geometry.colors.push( color1, color2 );\n</code></pre>\n<h4 id=\"定义一条线\"><a href=\"#定义一条线\" class=\"headerlink\" title=\"定义一条线\"></a>定义一条线</h4><pre><code class=\"js\">var line = new THREE.Line( geometry, material, THREE.LinePieces );\nscene.add(line);\n</code></pre>\n<h4 id=\"右手坐标系\"><a href=\"#右手坐标系\" class=\"headerlink\" title=\"右手坐标系\"></a>右手坐标系</h4><p>x轴正方向向右，y轴正方向向上，z轴由屏幕从里向外。</p>\n<h4 id=\"线条的深入理解\"><a href=\"#线条的深入理解\" class=\"headerlink\" title=\"线条的深入理解\"></a>线条的深入理解</h4>","site":{"data":{}},"excerpt":"<p>非常想学习webGL和three.js，这次借着百度前端学院来学一波！</p>","more":"<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><p>直接引用 three.js</p>\n<h3 id=\"三大组件\"><a href=\"#三大组件\" class=\"headerlink\" title=\"三大组件\"></a>三大组件</h3><p>场景 (scene)，相机 (camera)，渲染器 (renderer)</p>\n<h4 id=\"scene\"><a href=\"#scene\" class=\"headerlink\" title=\"scene\"></a>scene</h4><p>场景是所有物体的容器</p>\n<pre><code class=\"js\">var scene = new THREE.Scene();\n</code></pre>\n<h4 id=\"camera\"><a href=\"#camera\" class=\"headerlink\" title=\"camera\"></a>camera</h4><p>相机决定了场景中那个角度的景色会显示出来,角度不同看到的景色也不同</p>\n<pre><code class=\"js\">var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);// 透视相机\n</code></pre>\n<h4 id=\"renderer\"><a href=\"#renderer\" class=\"headerlink\" title=\"renderer\"></a>renderer</h4><p>渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制</p>\n<pre><code class=\"js\">var renderer = new THREE.WebGLRenderer();\nrenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(renderer.domElement);\n</code></pre>\n<p>渲染器renderer的domElement元素，表示渲染器中的画布，所有的渲染都是画在domElement上的</p>\n<ul>\n<li>添加物体到场景中</li>\n</ul>\n<pre><code class=\"js\">var geometry = new THREE.CubeGeometry(1,1,1);\nvar material = new THREE.MeshBasicMaterial({color: 0x00ff00});\nvar cube = new THREE.Mesh(geometry, material);\nscene.add(cube);\n</code></pre>\n<ul>\n<li>渲染</li>\n</ul>\n<pre><code class=\"js\">renderer.render(scene, camera);\n</code></pre>\n<h3 id=\"画一条线\"><a href=\"#画一条线\" class=\"headerlink\" title=\"画一条线\"></a>画一条线</h3><h4 id=\"定义几何体\"><a href=\"#定义几何体\" class=\"headerlink\" title=\"定义几何体\"></a>定义几何体</h4><pre><code class=\"js\">var geometry = new THREE.Geometry();\n</code></pre>\n<p>几何体中的变量<code>vertices</code>可以存放点</p>\n<h5 id=\"定义线条的材质\"><a href=\"#定义线条的材质\" class=\"headerlink\" title=\"定义线条的材质\"></a>定义线条的材质</h5><pre><code class=\"js\">THREE.LineBasicMaterial(parameters)\nparameters: {\n  Color: &#39;线条的颜色，用16进制来表示，默认的颜色是白色&#39;,\n  Linewidth: &#39;线条的宽度，默认为1&#39;，\n  Linecap: &#39;线条两端的外观，默认是圆角端点&#39;,\n  Linejoin: &#39;两个线条的连接点处的外观，默认是“round”，表示圆角&#39;,\n  VertexColors: &#39;定义线条材质是否使用顶点颜色，这是一个boolean值。意思是，线条各部分的颜色会根据顶点的颜色来进行插值&#39;,\n  Fog: &#39;定义材质的颜色是否受全局雾效的影响&#39;\n}\n</code></pre>\n<pre><code class=\"js\">var material = new THREE.LineBasicMaterial( { vertexColors: true } )\n</code></pre>\n<h4 id=\"定义顶点颜色\"><a href=\"#定义顶点颜色\" class=\"headerlink\" title=\"定义顶点颜色\"></a>定义顶点颜色</h4><pre><code class=\"js\">var color1 = new THREE.Color( 0x444444 );\nvar color2 = new THREE.Color( 0xFF0000 );\n</code></pre>\n<h4 id=\"定义顶点位置-存放到几何体geometry中\"><a href=\"#定义顶点位置-存放到几何体geometry中\" class=\"headerlink\" title=\"定义顶点位置,存放到几何体geometry中\"></a>定义顶点位置,存放到几何体geometry中</h4><pre><code class=\"js\">var p1 = new THREE.Vector3( -100, 0, 100 );\nvar p2 = new THREE.Vector3( 100, 0, -100 );\ngeometry.vertices.push(p1);\ngeometry.vertices.push(p2);\n</code></pre>\n<h4 id=\"给顶点设置颜色\"><a href=\"#给顶点设置颜色\" class=\"headerlink\" title=\"给顶点设置颜色\"></a>给顶点设置颜色</h4><pre><code class=\"js\">geometry.colors.push( color1, color2 );\n</code></pre>\n<h4 id=\"定义一条线\"><a href=\"#定义一条线\" class=\"headerlink\" title=\"定义一条线\"></a>定义一条线</h4><pre><code class=\"js\">var line = new THREE.Line( geometry, material, THREE.LinePieces );\nscene.add(line);\n</code></pre>\n<h4 id=\"右手坐标系\"><a href=\"#右手坐标系\" class=\"headerlink\" title=\"右手坐标系\"></a>右手坐标系</h4><p>x轴正方向向右，y轴正方向向上，z轴由屏幕从里向外。</p>\n<h4 id=\"线条的深入理解\"><a href=\"#线条的深入理解\" class=\"headerlink\" title=\"线条的深入理解\"></a>线条的深入理解</h4>"},{"title":"ts数据结构","date":"2017-10-15T02:49:43.000Z","_content":"学习TypeScript...\n<!--more-->\n\n### 栈\n后进先出\n```ts\nexport default class Stack<T> {\n  private count: number;\n  private items: any;\n\n  constructor() {\n    this.count = 0;\n    this.items = {};\n  }\n\n  push(element: T) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n\n  isEmpty() {\n    return this.count === 0;\n  }\n\n  size() {\n    return this.count;\n  }\n\n  clear() {\n    this.items = {};\n    this.count = 0;\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString;\n    for (let i = 0; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n```\n\n### 队列\nFIFO 先进先出\n```ts\n// object\nexport default class Queue<T> {\n  private count: number;\n  private lowestCount: number;\n  private items: any;\n\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n  /**\n   * @description 向队列尾部添加一个\n   * @param el 新的项\n   */\n  enqueue(el: T) {\n    this.items[this.count] = el;\n    this.count++;\n  }\n  /**\n   * @description 移除队列的第一项，并返回移除的元素\n   */\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const res = this.items[this.lowestCount];\n    delete this.items[this.lowestCount];\n    this.lowestCount++;\n    return res;\n  }\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n  toString() {\n    let objString = 'obj:';\n    for (let i = this.lowestCount; i < this.count; i++) {\n      objString += `${this.items[i]},`;\n    }\n    return objString;\n  }\n  size() {\n    return this.count - this.lowestCount;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n}\n\n// array\nexport default class Queue<T> {\n  private items: T[];\n\n  constructor() {\n    this.items = [];\n  }\n  enqueue(el: T) {\n    this.items.push(el);\n  }\n\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items.shift();\n  }\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[0];\n  }\n  clear() {\n    this.items = [];\n\n  }\n  toString() {\n    let objString = 'obj:';\n    for (const i of this.items) {\n      objString += `${i}`;\n    }\n    return objString;\n  }\n  size() {\n    return this.items.length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n}\n```","source":"_posts/ts数据结构.md","raw":"---\ntitle: ts数据结构\ndate: 2017-10-15 10:49:43\ntags:\n---\n学习TypeScript...\n<!--more-->\n\n### 栈\n后进先出\n```ts\nexport default class Stack<T> {\n  private count: number;\n  private items: any;\n\n  constructor() {\n    this.count = 0;\n    this.items = {};\n  }\n\n  push(element: T) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n\n  isEmpty() {\n    return this.count === 0;\n  }\n\n  size() {\n    return this.count;\n  }\n\n  clear() {\n    this.items = {};\n    this.count = 0;\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return '';\n    }\n    let objString;\n    for (let i = 0; i < this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n```\n\n### 队列\nFIFO 先进先出\n```ts\n// object\nexport default class Queue<T> {\n  private count: number;\n  private lowestCount: number;\n  private items: any;\n\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n  /**\n   * @description 向队列尾部添加一个\n   * @param el 新的项\n   */\n  enqueue(el: T) {\n    this.items[this.count] = el;\n    this.count++;\n  }\n  /**\n   * @description 移除队列的第一项，并返回移除的元素\n   */\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const res = this.items[this.lowestCount];\n    delete this.items[this.lowestCount];\n    this.lowestCount++;\n    return res;\n  }\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n  toString() {\n    let objString = 'obj:';\n    for (let i = this.lowestCount; i < this.count; i++) {\n      objString += `${this.items[i]},`;\n    }\n    return objString;\n  }\n  size() {\n    return this.count - this.lowestCount;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n}\n\n// array\nexport default class Queue<T> {\n  private items: T[];\n\n  constructor() {\n    this.items = [];\n  }\n  enqueue(el: T) {\n    this.items.push(el);\n  }\n\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items.shift();\n  }\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[0];\n  }\n  clear() {\n    this.items = [];\n\n  }\n  toString() {\n    let objString = 'obj:';\n    for (const i of this.items) {\n      objString += `${i}`;\n    }\n    return objString;\n  }\n  size() {\n    return this.items.length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n}\n```","slug":"ts数据结构","published":1,"updated":"2017-10-15T07:19:26.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2v000vttwpb5q9thu2","content":"<p>学习TypeScript…<br><a id=\"more\"></a></p>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>后进先出</p>\n<pre><code class=\"ts\">export default class Stack&lt;T&gt; {\n  private count: number;\n  private items: any;\n\n  constructor() {\n    this.count = 0;\n    this.items = {};\n  }\n\n  push(element: T) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n\n  isEmpty() {\n    return this.count === 0;\n  }\n\n  size() {\n    return this.count;\n  }\n\n  clear() {\n    this.items = {};\n    this.count = 0;\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return &#39;&#39;;\n    }\n    let objString;\n    for (let i = 0; i &lt; this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n</code></pre>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>FIFO 先进先出</p>\n<pre><code class=\"ts\">// object\nexport default class Queue&lt;T&gt; {\n  private count: number;\n  private lowestCount: number;\n  private items: any;\n\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n  /**\n   * @description 向队列尾部添加一个\n   * @param el 新的项\n   */\n  enqueue(el: T) {\n    this.items[this.count] = el;\n    this.count++;\n  }\n  /**\n   * @description 移除队列的第一项，并返回移除的元素\n   */\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const res = this.items[this.lowestCount];\n    delete this.items[this.lowestCount];\n    this.lowestCount++;\n    return res;\n  }\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n  toString() {\n    let objString = &#39;obj:&#39;;\n    for (let i = this.lowestCount; i &lt; this.count; i++) {\n      objString += `${this.items[i]},`;\n    }\n    return objString;\n  }\n  size() {\n    return this.count - this.lowestCount;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n}\n\n// array\nexport default class Queue&lt;T&gt; {\n  private items: T[];\n\n  constructor() {\n    this.items = [];\n  }\n  enqueue(el: T) {\n    this.items.push(el);\n  }\n\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items.shift();\n  }\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[0];\n  }\n  clear() {\n    this.items = [];\n\n  }\n  toString() {\n    let objString = &#39;obj:&#39;;\n    for (const i of this.items) {\n      objString += `${i}`;\n    }\n    return objString;\n  }\n  size() {\n    return this.items.length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n}\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>学习TypeScript…<br>","more":"</p>\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><p>后进先出</p>\n<pre><code class=\"ts\">export default class Stack&lt;T&gt; {\n  private count: number;\n  private items: any;\n\n  constructor() {\n    this.count = 0;\n    this.items = {};\n  }\n\n  push(element: T) {\n    this.items[this.count] = element;\n    this.count++;\n  }\n\n  pop() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    this.count--;\n    const result = this.items[this.count];\n    delete this.items[this.count];\n    return result;\n  }\n\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.count - 1];\n  }\n\n  isEmpty() {\n    return this.count === 0;\n  }\n\n  size() {\n    return this.count;\n  }\n\n  clear() {\n    this.items = {};\n    this.count = 0;\n  }\n\n  toString() {\n    if (this.isEmpty()) {\n      return &#39;&#39;;\n    }\n    let objString;\n    for (let i = 0; i &lt; this.count; i++) {\n      objString = `${objString},${this.items[i]}`;\n    }\n    return objString;\n  }\n}\n</code></pre>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>FIFO 先进先出</p>\n<pre><code class=\"ts\">// object\nexport default class Queue&lt;T&gt; {\n  private count: number;\n  private lowestCount: number;\n  private items: any;\n\n  constructor() {\n    this.count = 0;\n    this.lowestCount = 0;\n    this.items = {};\n  }\n  /**\n   * @description 向队列尾部添加一个\n   * @param el 新的项\n   */\n  enqueue(el: T) {\n    this.items[this.count] = el;\n    this.count++;\n  }\n  /**\n   * @description 移除队列的第一项，并返回移除的元素\n   */\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    const res = this.items[this.lowestCount];\n    delete this.items[this.lowestCount];\n    this.lowestCount++;\n    return res;\n  }\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[this.lowestCount];\n  }\n  clear() {\n    this.items = {};\n    this.count = 0;\n    this.lowestCount = 0;\n  }\n  toString() {\n    let objString = &#39;obj:&#39;;\n    for (let i = this.lowestCount; i &lt; this.count; i++) {\n      objString += `${this.items[i]},`;\n    }\n    return objString;\n  }\n  size() {\n    return this.count - this.lowestCount;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n}\n\n// array\nexport default class Queue&lt;T&gt; {\n  private items: T[];\n\n  constructor() {\n    this.items = [];\n  }\n  enqueue(el: T) {\n    this.items.push(el);\n  }\n\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items.shift();\n  }\n  peek() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n    return this.items[0];\n  }\n  clear() {\n    this.items = [];\n\n  }\n  toString() {\n    let objString = &#39;obj:&#39;;\n    for (const i of this.items) {\n      objString += `${i}`;\n    }\n    return objString;\n  }\n  size() {\n    return this.items.length;\n  }\n  isEmpty() {\n    return this.size() === 0;\n  }\n}\n</code></pre>"},{"title":"translate-koa2","date":"2017-04-03T06:54:21.000Z","_content":"\n边学英语边学koa\n\n<!--more-->\n\n## KOA\n\n### koa\n基于node.js的下一代web框架\n\n### Introduction\nkoa是由Express开发团队设计的新型Web框架，旨在为Web应用和Apis提供更小，更具表现力和更强大基础。通过组合利用generators，可以避免回调嵌套并大大提高处理错误的能力。koa不在核心中捆绑任何中间件，仅仅提供了一套轻量优雅的方法库，使得编写服务更加便捷。\n\n### 安装\nkoa需要 node >= ^7.6.0版本来支持ES2015和async。\n你可以安装node版本控制器来升级到需求版本。\n```\nnpm install n -g\nn 7.6.0\nnpm install koa\nnode my-koa-app.js\n```\n\n### Async与Babel\n要想在node低于^7.6.0的环境，koa中使用Async函数，我们推荐使用[babel's require hook](https://babeljs.io/docs/usage/babel-register/)\n```\nrequire('babel-core/register');\n// require the rest of the app that needs to be transpiled after the hook\nconst app = require('./app');\n```\n为了解析和转换Async函数， 你至少应该有[transform-async-to-generator](http://babeljs.io/docs/plugins/transform-async-to-generator/)或[transform-async-to-module-method](http://babeljs.io/docs/plugins/transform-async-to-module-method/)插件。\n举个例，在你的`.babelrc`文件中，你应该有如下配置:\n```\n{\n  \"plugins\": [\"transform-async-to-generator\"]\n}\n```\n你当然也可以使用[Stage 3 preset](http://babeljs.io/docs/plugins/preset-stage-3/)代替\n> 讲道理干嘛这么麻烦。。不如用node^7.6.0\n\n### Application\nkoa应用是一个包含一系列中间件的对象，这些中间件函数根据request请求按照类似堆栈的方式构成依次执行。Koa类似于其他您可能使用过的中间件系统（如Ruby‘s Rack，Connect等）。然而Koa的核心设计思路是为其他低等级的中间件层提供高级语法糖，以提高其可操作性和稳定性，并使编写中间件变得更便捷。\n\nKoa包含了像content-negotiation(内容协商)、cache freshness（缓存刷新）、proxy support（代理支持）和 redirection（重定向）等常用任务方法。尽管有相当大数量的函数支持，Koa仅仅包含很小一部分，因为Koa没有中间件捆绑。\n\n编写一个 hello world 应用：\n```\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(ctx => {\n  ctx.body = 'Hello World';\n});\n\napp.listen(3000);\n```\n\n### Cascading—级联\nKoa中间件以更传统的方式级联，像你习惯使用的一些类似工具——在过去这使得用户很难友好的使用node频繁回调。然而通过使用Async函数，我们能\"真正\"实现中间件。Connect的实现是简单地通过一系列的函数传递控制权，直到一个函数返回。而Koa则是通调用下一个中间件，然后将控制权逐级返还到上级中间件。\n\n下面的例子将返回 `Hello World`，然而当请求开始时，将先经过x-response-time和logging中间件，记录中间件执行起始时间，然后继续通过response中间件得到控制权。当一个中间件调用 next() 时，该函数暂停并将控制权传递给定义的下一个中间件。当没有更多的下级中间件执行，堆栈将释放，并且将逆序执行每个中间件的代码。\n\n> 原文并未使用箭头函数\n\n  ```\n const Koa = require('koa');\n const app = new Koa();\n\n// x-response-time\n\napp.use(async (ctx, next) => {\n  const start = new Date();\n  await next();\n  const ms = new Date() - start;\n  ctx.set('X-Response-Time', `${ms}ms`);\n });\n\n // logger\n\n app.use(async (ctx, next) => {\n  const start = new Date();\n  await next();\n  const ms = new Date() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}`);\n });\n\n// response\n\napp.use(ctx => {\n  ctx.body = 'Hello World';\n});\n\napp.listen(3000);\n```\n\n### Settings\n应用配置是实例app的属性，目前支持以下配置：\n  - app.env 默认为NODE_DEV或development\n  - app.proxy 如果为true，则header域将被信任\n  - app.subdomainOffset 默认为2 表示.subdomains所忽略的字符偏移量\n\n### app.listen(...)\n Koa应用并不是一个HTTP服务器的单一映射表现方式。一个或多个Koa应用可以被一起挂载，形成一个具有单一HTTP服务器的较大型的应用。\n\n 创建并返回一个HTTP服务器，将给定的参数传递给Server#listen()。[(参数配置参考)](https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback)\n 以下为创建一个绑定3000端口的简单Koa应用：\n\n  ```\n const Koa = require('koa');\nconst app = new Koa();\napp.listen(3000);\n```\n\napp.listen(...)实际上以下代码的语法糖：\n\n```\nconst http = require('http');\nconst Koa = require('koa');\nconst app = new Koa();\nhttp.createServer(app.callback().listen(3000));\n```\n\n这意味这你可以同时启动HTTP和HTTPS或多个地址相同的引用程序：\n\n```\nconst http = require('http');\nconst Koa = require('koa');\nconst app = new Koa();\nhttp.createServer(app.callback().listen(3000));\nhttp.createServer(app.callback().listen(3000));\n```\n\n### app.callback()\n返回一个适用于http。createServer()方法的回调函数来处理请求。你也可以使用这个回调函数将你的Koa应用挂载到 Connect/Express 应用上。\n\n### app.use(function)\n将给定的中间件添加到应用中[(参考Middleware)](https://github.com/koajs/koa/wiki#middleware)\n\n### app.keys =\n设置签名Cookie密钥\n该密钥将会被传递给[KEyGrip](https://github.com/koajs/koa/wiki#middleware)。\n你也可以传递自己生成的KEyGrip实例。如下：\n```\napp.keys = [ 'im a newer secret', 'i like turtle'];\napp.keys = new KeyGrip(['im a newer secret', 'i like turtle'], 'sha256');\n```\n在进行cookie签名时。，这些键只有在设置signed 为 true 时才会使用密钥进行加密：\n```\nthis.cookies.set('name', 'tobi', {signed: true});\n```\n\n### app.context\napp.context是从ctx中创建的原型。你可以通过编辑app.context添加额外的属性到ctx上。这对于添加属性或方法到ctx上在整个应用程序上使用非常有用，这也可能会更为有效（无中间件）并更容易（更少使用require())牺牲更多依赖在ctx上，这可以被视为反模式。\n\n举个例，添加一个数据库引用到ctx:\n```\napp.context.db = db();\napp.use(async (ctx) => {\n  console.log(ctx.db);\n});\n```\n---\nNote：\n - ctx上的许多属性定义时使用了，getters，setters和Object.defineProperty()。你只能编辑这些属性（不推荐）通过使用Object.defineProperty app.context()。[(See more)](https://github.com/koajs/koa/issues/652)\n - 这一段有点晕。。。\n\n### 错误处理\n默认情况下，Koa会讲所有错误日志输出到stderr中，除非 app。silent = true。默认错误处理页不会在 err.status = 404 或 err.expose = true 时输出错误。想要执行自定义错误处理逻辑（例如 centralized logging），你可以添加“error”事件监听器。\n```\napp.on('error', err => {\n  log.error('serrver error', err);\n});\n```\n\n如果在 req／res 周期中出现error，并且不能够影响客户端时，Context实例也会被传递到error事件监听器的回调函数中：\n```\napp.on('error', (err, ctx) => {\n  log.error('server error', err, ctx);\n});\n```\n\n当发生错误并且仍然可以响应客户端时，例如没有数据被写入到socker中时，Koa将返回一个 500／服务器内部错误。\n无论哪种情况，Koa都会生成一个应用级别的错误，来实现日志记录。\n\n## Context\nKoa Context将node的request和response对象封装到一个单独的对象中，为编写web应用和API提供了很多有用的方法。这些操作在开发HTTP服务器中经常被使用，因此被添加在context这一层级总而不是更高层级的框架中，这将迫使中间件需要重新实现这些公共的方法。\nContext 根据每个request创建，并在中间件中作为接收器（receiver ）或通过 ctx 标识符来引用\n如下代码展示：\n```\napp.use(async (ctx, next) => {\n  ctx; // is the Context\n  ctx.request; // is a koa Request\n  ctx.response; // is a koa Response\n})\n```\n许多Context的访问器和方法为了方便起见，简单地委托给ctx.request和ctx.response 所对应的等价方法。\n举个例子，ctx.type和ctx.length 代理了 response对象中对应的方法， ctx.path和ctx.method代理了 resquest 对象中对应的方法。\n\n### API\nContext 具体的方法和访问器。\n\n### ctx.req\nNode的request对象\n\n### ctx.res\nNode的response对象\n\nKoa不支持直接调用底层response处理。请避免使用以下Node属性：\n  - res.statusCode\n  - res.writeHead()\n  - res.write()\n  - res.end()\n\n### ctx.request\nKoa 的 Request 对象。\n\n### ctx.response\nKoa 的 Response 对象。\n\n### ctx.state\n自定义命名空间，用于将信息从中间件传递到前端视图层\n```\nctx.state.user = await User.find(id);\n```\n\n### ctx.app\n应用实例引用。\n\n### ctx.cookies.get(name, [options])\n获取 cookie 中 name 的值 options为可选参数。\n  - signed：对cookie请求时需要设置签名。\n\nKoa 使用 [cookies模块](https://github.com/pillarjs/cookies),options参数只是简单地直接传递。\n\n### ctx.cookies.set(name, value, [options])\n设置 cookie 中 name值， options为可选参数。\n  - maxAge: 表示 Date.now() 到期的毫米数， number.\n  - signed: Cookie 签名\n  - expires: Cookie有效时间\n  - path: Cookie路径，默认为`/'`\n  - domain: Cookie的域\n  - secure: Cookie安全协议 false表示Cookie通过HTTP协议传送，true表示Cookie通过HTTPS协议传送。\n  - httpOnly: 服务器可访问的Cookie 默认为true\n  - overwrite: 一个布尔值，表示是否覆盖重写以前设置的同名的Cookie（默认为false）如果为true，在设置这个新Cookie时，将在同一个请求中设置所有相同名称的Cookie（不论路径或域）并从Set-Cookie头部中过滤掉。\n\nKoa 使用 [cookies模块](https://github.com/pillarjs/cookies),options参数只是简单地直接传递。\n\n### ctx.throw([msg], [status], [properties])\nHelper方法抛出一个.status属性默认为500的错误。该方法允许Koa准确的响应处理状态。\nKoa允许以下组合：\n```\nctx.throw(403);\nctx.throw('name required', 400);\nctx.throw(400, 'name required');\nctx.throw('something exploded');\n```\n举个例子 `ctx.throw('name required', 400)`等价于：\n```\nconst err = new Error('name required');\nerr.status = 400;\nerr.expose = true;\nthrow err;\n```\n请注意，这些是用户级错误，并会被标记为err.expose,这意味着消息会被准确描述为对客户端的响应，而并非使用在您不想泄漏失败细节的情景中。\n\n你可以根据需要将合并后的属性对象船钓错误中去，这对于向上级中间件请求的友好的机器化错误有着很好的装饰作用\n```\nctx.throw(401, 'access_denied', { user: user });\nctx.throw('access_denied', { user: user });\n```\nKoa 使用[http-errors](https://github.com/jshttp/http-errors)来创建错误。\n\n### ctx.assert(value, [status], [msg], [properties])\n当 !value时，Helper方法抛出类似于.throw()的错误。\n相当于node中的[assert](https://nodejs.org/api/assert.html)方法\n```\nctx.assert(ctx.state.user, 401, 'User not found. Please login!');\n```\nKoa 使用[http-assert](https://github.com/jshttp/http-assert)判断\n\n### ctx.respond\n为了避免Koa的内置响应处理，你可以直接设置 ctx.respond = false;\n如果你想使用原生的res对象代替Koa操作response，那么请使用这种方法。\n\n请注意，Koa并不支持这种使用方式，因为这有可能破坏Koa中间件和Koa本身的一些功能。\n这只能作为一种hack的方式，并只对希望在Koa的函数和中间件中使用传统的fn(req, res)的人带来便捷。\n\n### Request aliases\n以下的访问器别名与 [Request](#Request) 等价：\n```\nctx.header\nctx.headers\nctx.method\nctx.method=\nctx.url\nctx.url=\nctx.originalUrl\nctx.originalUrlctx.href\nctx.path\nctx.path=\nctx.query\nctx.query=\nctx.querystring\nctx.querystring=\nctx.host\nctx.hostname\nctx.fresh\nctx.stale\nctx.socket\nctx.protocol\nctx.secure\nctx.ip\nctx.ips\nctx.subdomains\nctx.is()\nctx.accepts()\nctx.acceptsEncodings()\nctx.acceptsLanguages()\nctx.get()\n```\n\n### Response aliases\n以下访问器别名与 [Response](#response)等价:\n```\nctx.body\nctx.body=\nctx.status\nctx.status=\nctx.message\nctx.message=\nctx.length\nctx.length=\nctx.type\nctx.type=\nctx.headerSent\nctx.rdirect()\nctx.attachment()\nctx.set()\nctx.append()\nctx.remove()\nctx.lastModified=\nctx.etag=\n```\n\n## <span id=\"request\">Request</span>\nKoa的Request对象是对node的Request对象进一步抽象，封装。\n提供了对日常HTTP服务器开发有用的一些功能函数\n\n### API\n\n#### request.header\n请求头对象\n\n#### request.headers\n请求头对象的别名\n\n#### request.method\n请求方法\n\n#### request.method=\n设置请求方法，在实现中间件时有很大作用，例如methodOverride()\n\n#### request.length\n以数字的形式返回request的内容长度(Content-lenght),或者返回undefined\n\n#### request.url\n获取请求url地址\n\n#### request.url=\n设置请求地址，用于重写url\n\n#### request.originalUrl\n获取请求原始url\n\n#### request.origin\n获取url来源，包括protocol和host\n```\nctx.request.origin\n// => http://example.com\n```\n\n#### request.href\n获取请求完整的URL，包括protpcol，host和url\n```\nctx.request.href\n// => http://example.com/foo/bar?q=1\n```\n\n#### request.path\n获取请求路径名。\n\n#### request.path=\n设置请求路径名，并保存'?'后面的部分（请求参数）\n\n#### request.querystring\n获取请求的查询参数(url中?后边的部分)不包含？\n\n#### request.querystring=\n设置查询参数\n\n#### request.search\n获取请求的查询参数，包含?\n\n#### request.search=\n设置请求的查询参数。\n\n#### request.host\n获取当前host(hostname: port) 当 app.proxy = true 时, 支持X-Forwarded-Host。\n\n#### request.hostname\n获取hostname，当 app.proxy = ture 时, 支持X-Forwarded-Host.\n\n#### request.type\n获取当前请求的 Conetent-Type 不包含如`charset`这样的参数。\n```\nconst ct = ctx.request.type\n// => \"image/png\"\n```\n\n#### request.charset\n获取当前请求的 charset 没有则返回undefined\n```\nctx.request.charset\n// => \"utf-8\"\n```\n\n#### request.query\n获取解析后的查询字符串，当请求中没有查询字符串时则返回一个空对象。\n请注意，这个方法不支持嵌套对象。\n例如：`color=blue&size=small`\n```\n{\n  color: 'blue',\n  size: 'small'\n}\n```\n\n#### request.query=\n根据给定的对象设置查询字符串。\n请注意，这个方法不支持嵌套对象。\n```\nctx.query = {next: '/login'}\n```\n\n#### request.fresh\n\n\n## <span id=\"response\">Response</span>\n","source":"_posts/translate-koa2.md","raw":"---\ntitle: translate-koa2\ndate: 2017-04-03 14:54:21\ntags:\n  - javascript\n  - node\n  - koa2\n---\n\n边学英语边学koa\n\n<!--more-->\n\n## KOA\n\n### koa\n基于node.js的下一代web框架\n\n### Introduction\nkoa是由Express开发团队设计的新型Web框架，旨在为Web应用和Apis提供更小，更具表现力和更强大基础。通过组合利用generators，可以避免回调嵌套并大大提高处理错误的能力。koa不在核心中捆绑任何中间件，仅仅提供了一套轻量优雅的方法库，使得编写服务更加便捷。\n\n### 安装\nkoa需要 node >= ^7.6.0版本来支持ES2015和async。\n你可以安装node版本控制器来升级到需求版本。\n```\nnpm install n -g\nn 7.6.0\nnpm install koa\nnode my-koa-app.js\n```\n\n### Async与Babel\n要想在node低于^7.6.0的环境，koa中使用Async函数，我们推荐使用[babel's require hook](https://babeljs.io/docs/usage/babel-register/)\n```\nrequire('babel-core/register');\n// require the rest of the app that needs to be transpiled after the hook\nconst app = require('./app');\n```\n为了解析和转换Async函数， 你至少应该有[transform-async-to-generator](http://babeljs.io/docs/plugins/transform-async-to-generator/)或[transform-async-to-module-method](http://babeljs.io/docs/plugins/transform-async-to-module-method/)插件。\n举个例，在你的`.babelrc`文件中，你应该有如下配置:\n```\n{\n  \"plugins\": [\"transform-async-to-generator\"]\n}\n```\n你当然也可以使用[Stage 3 preset](http://babeljs.io/docs/plugins/preset-stage-3/)代替\n> 讲道理干嘛这么麻烦。。不如用node^7.6.0\n\n### Application\nkoa应用是一个包含一系列中间件的对象，这些中间件函数根据request请求按照类似堆栈的方式构成依次执行。Koa类似于其他您可能使用过的中间件系统（如Ruby‘s Rack，Connect等）。然而Koa的核心设计思路是为其他低等级的中间件层提供高级语法糖，以提高其可操作性和稳定性，并使编写中间件变得更便捷。\n\nKoa包含了像content-negotiation(内容协商)、cache freshness（缓存刷新）、proxy support（代理支持）和 redirection（重定向）等常用任务方法。尽管有相当大数量的函数支持，Koa仅仅包含很小一部分，因为Koa没有中间件捆绑。\n\n编写一个 hello world 应用：\n```\nconst Koa = require('koa');\nconst app = new Koa();\n\napp.use(ctx => {\n  ctx.body = 'Hello World';\n});\n\napp.listen(3000);\n```\n\n### Cascading—级联\nKoa中间件以更传统的方式级联，像你习惯使用的一些类似工具——在过去这使得用户很难友好的使用node频繁回调。然而通过使用Async函数，我们能\"真正\"实现中间件。Connect的实现是简单地通过一系列的函数传递控制权，直到一个函数返回。而Koa则是通调用下一个中间件，然后将控制权逐级返还到上级中间件。\n\n下面的例子将返回 `Hello World`，然而当请求开始时，将先经过x-response-time和logging中间件，记录中间件执行起始时间，然后继续通过response中间件得到控制权。当一个中间件调用 next() 时，该函数暂停并将控制权传递给定义的下一个中间件。当没有更多的下级中间件执行，堆栈将释放，并且将逆序执行每个中间件的代码。\n\n> 原文并未使用箭头函数\n\n  ```\n const Koa = require('koa');\n const app = new Koa();\n\n// x-response-time\n\napp.use(async (ctx, next) => {\n  const start = new Date();\n  await next();\n  const ms = new Date() - start;\n  ctx.set('X-Response-Time', `${ms}ms`);\n });\n\n // logger\n\n app.use(async (ctx, next) => {\n  const start = new Date();\n  await next();\n  const ms = new Date() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}`);\n });\n\n// response\n\napp.use(ctx => {\n  ctx.body = 'Hello World';\n});\n\napp.listen(3000);\n```\n\n### Settings\n应用配置是实例app的属性，目前支持以下配置：\n  - app.env 默认为NODE_DEV或development\n  - app.proxy 如果为true，则header域将被信任\n  - app.subdomainOffset 默认为2 表示.subdomains所忽略的字符偏移量\n\n### app.listen(...)\n Koa应用并不是一个HTTP服务器的单一映射表现方式。一个或多个Koa应用可以被一起挂载，形成一个具有单一HTTP服务器的较大型的应用。\n\n 创建并返回一个HTTP服务器，将给定的参数传递给Server#listen()。[(参数配置参考)](https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback)\n 以下为创建一个绑定3000端口的简单Koa应用：\n\n  ```\n const Koa = require('koa');\nconst app = new Koa();\napp.listen(3000);\n```\n\napp.listen(...)实际上以下代码的语法糖：\n\n```\nconst http = require('http');\nconst Koa = require('koa');\nconst app = new Koa();\nhttp.createServer(app.callback().listen(3000));\n```\n\n这意味这你可以同时启动HTTP和HTTPS或多个地址相同的引用程序：\n\n```\nconst http = require('http');\nconst Koa = require('koa');\nconst app = new Koa();\nhttp.createServer(app.callback().listen(3000));\nhttp.createServer(app.callback().listen(3000));\n```\n\n### app.callback()\n返回一个适用于http。createServer()方法的回调函数来处理请求。你也可以使用这个回调函数将你的Koa应用挂载到 Connect/Express 应用上。\n\n### app.use(function)\n将给定的中间件添加到应用中[(参考Middleware)](https://github.com/koajs/koa/wiki#middleware)\n\n### app.keys =\n设置签名Cookie密钥\n该密钥将会被传递给[KEyGrip](https://github.com/koajs/koa/wiki#middleware)。\n你也可以传递自己生成的KEyGrip实例。如下：\n```\napp.keys = [ 'im a newer secret', 'i like turtle'];\napp.keys = new KeyGrip(['im a newer secret', 'i like turtle'], 'sha256');\n```\n在进行cookie签名时。，这些键只有在设置signed 为 true 时才会使用密钥进行加密：\n```\nthis.cookies.set('name', 'tobi', {signed: true});\n```\n\n### app.context\napp.context是从ctx中创建的原型。你可以通过编辑app.context添加额外的属性到ctx上。这对于添加属性或方法到ctx上在整个应用程序上使用非常有用，这也可能会更为有效（无中间件）并更容易（更少使用require())牺牲更多依赖在ctx上，这可以被视为反模式。\n\n举个例，添加一个数据库引用到ctx:\n```\napp.context.db = db();\napp.use(async (ctx) => {\n  console.log(ctx.db);\n});\n```\n---\nNote：\n - ctx上的许多属性定义时使用了，getters，setters和Object.defineProperty()。你只能编辑这些属性（不推荐）通过使用Object.defineProperty app.context()。[(See more)](https://github.com/koajs/koa/issues/652)\n - 这一段有点晕。。。\n\n### 错误处理\n默认情况下，Koa会讲所有错误日志输出到stderr中，除非 app。silent = true。默认错误处理页不会在 err.status = 404 或 err.expose = true 时输出错误。想要执行自定义错误处理逻辑（例如 centralized logging），你可以添加“error”事件监听器。\n```\napp.on('error', err => {\n  log.error('serrver error', err);\n});\n```\n\n如果在 req／res 周期中出现error，并且不能够影响客户端时，Context实例也会被传递到error事件监听器的回调函数中：\n```\napp.on('error', (err, ctx) => {\n  log.error('server error', err, ctx);\n});\n```\n\n当发生错误并且仍然可以响应客户端时，例如没有数据被写入到socker中时，Koa将返回一个 500／服务器内部错误。\n无论哪种情况，Koa都会生成一个应用级别的错误，来实现日志记录。\n\n## Context\nKoa Context将node的request和response对象封装到一个单独的对象中，为编写web应用和API提供了很多有用的方法。这些操作在开发HTTP服务器中经常被使用，因此被添加在context这一层级总而不是更高层级的框架中，这将迫使中间件需要重新实现这些公共的方法。\nContext 根据每个request创建，并在中间件中作为接收器（receiver ）或通过 ctx 标识符来引用\n如下代码展示：\n```\napp.use(async (ctx, next) => {\n  ctx; // is the Context\n  ctx.request; // is a koa Request\n  ctx.response; // is a koa Response\n})\n```\n许多Context的访问器和方法为了方便起见，简单地委托给ctx.request和ctx.response 所对应的等价方法。\n举个例子，ctx.type和ctx.length 代理了 response对象中对应的方法， ctx.path和ctx.method代理了 resquest 对象中对应的方法。\n\n### API\nContext 具体的方法和访问器。\n\n### ctx.req\nNode的request对象\n\n### ctx.res\nNode的response对象\n\nKoa不支持直接调用底层response处理。请避免使用以下Node属性：\n  - res.statusCode\n  - res.writeHead()\n  - res.write()\n  - res.end()\n\n### ctx.request\nKoa 的 Request 对象。\n\n### ctx.response\nKoa 的 Response 对象。\n\n### ctx.state\n自定义命名空间，用于将信息从中间件传递到前端视图层\n```\nctx.state.user = await User.find(id);\n```\n\n### ctx.app\n应用实例引用。\n\n### ctx.cookies.get(name, [options])\n获取 cookie 中 name 的值 options为可选参数。\n  - signed：对cookie请求时需要设置签名。\n\nKoa 使用 [cookies模块](https://github.com/pillarjs/cookies),options参数只是简单地直接传递。\n\n### ctx.cookies.set(name, value, [options])\n设置 cookie 中 name值， options为可选参数。\n  - maxAge: 表示 Date.now() 到期的毫米数， number.\n  - signed: Cookie 签名\n  - expires: Cookie有效时间\n  - path: Cookie路径，默认为`/'`\n  - domain: Cookie的域\n  - secure: Cookie安全协议 false表示Cookie通过HTTP协议传送，true表示Cookie通过HTTPS协议传送。\n  - httpOnly: 服务器可访问的Cookie 默认为true\n  - overwrite: 一个布尔值，表示是否覆盖重写以前设置的同名的Cookie（默认为false）如果为true，在设置这个新Cookie时，将在同一个请求中设置所有相同名称的Cookie（不论路径或域）并从Set-Cookie头部中过滤掉。\n\nKoa 使用 [cookies模块](https://github.com/pillarjs/cookies),options参数只是简单地直接传递。\n\n### ctx.throw([msg], [status], [properties])\nHelper方法抛出一个.status属性默认为500的错误。该方法允许Koa准确的响应处理状态。\nKoa允许以下组合：\n```\nctx.throw(403);\nctx.throw('name required', 400);\nctx.throw(400, 'name required');\nctx.throw('something exploded');\n```\n举个例子 `ctx.throw('name required', 400)`等价于：\n```\nconst err = new Error('name required');\nerr.status = 400;\nerr.expose = true;\nthrow err;\n```\n请注意，这些是用户级错误，并会被标记为err.expose,这意味着消息会被准确描述为对客户端的响应，而并非使用在您不想泄漏失败细节的情景中。\n\n你可以根据需要将合并后的属性对象船钓错误中去，这对于向上级中间件请求的友好的机器化错误有着很好的装饰作用\n```\nctx.throw(401, 'access_denied', { user: user });\nctx.throw('access_denied', { user: user });\n```\nKoa 使用[http-errors](https://github.com/jshttp/http-errors)来创建错误。\n\n### ctx.assert(value, [status], [msg], [properties])\n当 !value时，Helper方法抛出类似于.throw()的错误。\n相当于node中的[assert](https://nodejs.org/api/assert.html)方法\n```\nctx.assert(ctx.state.user, 401, 'User not found. Please login!');\n```\nKoa 使用[http-assert](https://github.com/jshttp/http-assert)判断\n\n### ctx.respond\n为了避免Koa的内置响应处理，你可以直接设置 ctx.respond = false;\n如果你想使用原生的res对象代替Koa操作response，那么请使用这种方法。\n\n请注意，Koa并不支持这种使用方式，因为这有可能破坏Koa中间件和Koa本身的一些功能。\n这只能作为一种hack的方式，并只对希望在Koa的函数和中间件中使用传统的fn(req, res)的人带来便捷。\n\n### Request aliases\n以下的访问器别名与 [Request](#Request) 等价：\n```\nctx.header\nctx.headers\nctx.method\nctx.method=\nctx.url\nctx.url=\nctx.originalUrl\nctx.originalUrlctx.href\nctx.path\nctx.path=\nctx.query\nctx.query=\nctx.querystring\nctx.querystring=\nctx.host\nctx.hostname\nctx.fresh\nctx.stale\nctx.socket\nctx.protocol\nctx.secure\nctx.ip\nctx.ips\nctx.subdomains\nctx.is()\nctx.accepts()\nctx.acceptsEncodings()\nctx.acceptsLanguages()\nctx.get()\n```\n\n### Response aliases\n以下访问器别名与 [Response](#response)等价:\n```\nctx.body\nctx.body=\nctx.status\nctx.status=\nctx.message\nctx.message=\nctx.length\nctx.length=\nctx.type\nctx.type=\nctx.headerSent\nctx.rdirect()\nctx.attachment()\nctx.set()\nctx.append()\nctx.remove()\nctx.lastModified=\nctx.etag=\n```\n\n## <span id=\"request\">Request</span>\nKoa的Request对象是对node的Request对象进一步抽象，封装。\n提供了对日常HTTP服务器开发有用的一些功能函数\n\n### API\n\n#### request.header\n请求头对象\n\n#### request.headers\n请求头对象的别名\n\n#### request.method\n请求方法\n\n#### request.method=\n设置请求方法，在实现中间件时有很大作用，例如methodOverride()\n\n#### request.length\n以数字的形式返回request的内容长度(Content-lenght),或者返回undefined\n\n#### request.url\n获取请求url地址\n\n#### request.url=\n设置请求地址，用于重写url\n\n#### request.originalUrl\n获取请求原始url\n\n#### request.origin\n获取url来源，包括protocol和host\n```\nctx.request.origin\n// => http://example.com\n```\n\n#### request.href\n获取请求完整的URL，包括protpcol，host和url\n```\nctx.request.href\n// => http://example.com/foo/bar?q=1\n```\n\n#### request.path\n获取请求路径名。\n\n#### request.path=\n设置请求路径名，并保存'?'后面的部分（请求参数）\n\n#### request.querystring\n获取请求的查询参数(url中?后边的部分)不包含？\n\n#### request.querystring=\n设置查询参数\n\n#### request.search\n获取请求的查询参数，包含?\n\n#### request.search=\n设置请求的查询参数。\n\n#### request.host\n获取当前host(hostname: port) 当 app.proxy = true 时, 支持X-Forwarded-Host。\n\n#### request.hostname\n获取hostname，当 app.proxy = ture 时, 支持X-Forwarded-Host.\n\n#### request.type\n获取当前请求的 Conetent-Type 不包含如`charset`这样的参数。\n```\nconst ct = ctx.request.type\n// => \"image/png\"\n```\n\n#### request.charset\n获取当前请求的 charset 没有则返回undefined\n```\nctx.request.charset\n// => \"utf-8\"\n```\n\n#### request.query\n获取解析后的查询字符串，当请求中没有查询字符串时则返回一个空对象。\n请注意，这个方法不支持嵌套对象。\n例如：`color=blue&size=small`\n```\n{\n  color: 'blue',\n  size: 'small'\n}\n```\n\n#### request.query=\n根据给定的对象设置查询字符串。\n请注意，这个方法不支持嵌套对象。\n```\nctx.query = {next: '/login'}\n```\n\n#### request.fresh\n\n\n## <span id=\"response\">Response</span>\n","slug":"translate-koa2","published":1,"updated":"2017-04-04T11:46:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2x000wttwpch23v54s","content":"<p>边学英语边学koa</p>\n<a id=\"more\"></a>\n<h2 id=\"KOA\"><a href=\"#KOA\" class=\"headerlink\" title=\"KOA\"></a>KOA</h2><h3 id=\"koa\"><a href=\"#koa\" class=\"headerlink\" title=\"koa\"></a>koa</h3><p>基于node.js的下一代web框架</p>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>koa是由Express开发团队设计的新型Web框架，旨在为Web应用和Apis提供更小，更具表现力和更强大基础。通过组合利用generators，可以避免回调嵌套并大大提高处理错误的能力。koa不在核心中捆绑任何中间件，仅仅提供了一套轻量优雅的方法库，使得编写服务更加便捷。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>koa需要 node &gt;= ^7.6.0版本来支持ES2015和async。<br>你可以安装node版本控制器来升级到需求版本。</p>\n<pre><code>npm install n -g\nn 7.6.0\nnpm install koa\nnode my-koa-app.js\n</code></pre><h3 id=\"Async与Babel\"><a href=\"#Async与Babel\" class=\"headerlink\" title=\"Async与Babel\"></a>Async与Babel</h3><p>要想在node低于^7.6.0的环境，koa中使用Async函数，我们推荐使用<a href=\"https://babeljs.io/docs/usage/babel-register/\" target=\"_blank\" rel=\"external\">babel’s require hook</a></p>\n<pre><code>require(&#39;babel-core/register&#39;);\n// require the rest of the app that needs to be transpiled after the hook\nconst app = require(&#39;./app&#39;);\n</code></pre><p>为了解析和转换Async函数， 你至少应该有<a href=\"http://babeljs.io/docs/plugins/transform-async-to-generator/\" target=\"_blank\" rel=\"external\">transform-async-to-generator</a>或<a href=\"http://babeljs.io/docs/plugins/transform-async-to-module-method/\" target=\"_blank\" rel=\"external\">transform-async-to-module-method</a>插件。<br>举个例，在你的<code>.babelrc</code>文件中，你应该有如下配置:</p>\n<pre><code>{\n  &quot;plugins&quot;: [&quot;transform-async-to-generator&quot;]\n}\n</code></pre><p>你当然也可以使用<a href=\"http://babeljs.io/docs/plugins/preset-stage-3/\" target=\"_blank\" rel=\"external\">Stage 3 preset</a>代替</p>\n<blockquote>\n<p>讲道理干嘛这么麻烦。。不如用node^7.6.0</p>\n</blockquote>\n<h3 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h3><p>koa应用是一个包含一系列中间件的对象，这些中间件函数根据request请求按照类似堆栈的方式构成依次执行。Koa类似于其他您可能使用过的中间件系统（如Ruby‘s Rack，Connect等）。然而Koa的核心设计思路是为其他低等级的中间件层提供高级语法糖，以提高其可操作性和稳定性，并使编写中间件变得更便捷。</p>\n<p>Koa包含了像content-negotiation(内容协商)、cache freshness（缓存刷新）、proxy support（代理支持）和 redirection（重定向）等常用任务方法。尽管有相当大数量的函数支持，Koa仅仅包含很小一部分，因为Koa没有中间件捆绑。</p>\n<p>编写一个 hello world 应用：</p>\n<pre><code>const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\n\napp.use(ctx =&gt; {\n  ctx.body = &#39;Hello World&#39;;\n});\n\napp.listen(3000);\n</code></pre><h3 id=\"Cascading—级联\"><a href=\"#Cascading—级联\" class=\"headerlink\" title=\"Cascading—级联\"></a>Cascading—级联</h3><p>Koa中间件以更传统的方式级联，像你习惯使用的一些类似工具——在过去这使得用户很难友好的使用node频繁回调。然而通过使用Async函数，我们能”真正”实现中间件。Connect的实现是简单地通过一系列的函数传递控制权，直到一个函数返回。而Koa则是通调用下一个中间件，然后将控制权逐级返还到上级中间件。</p>\n<p>下面的例子将返回 <code>Hello World</code>，然而当请求开始时，将先经过x-response-time和logging中间件，记录中间件执行起始时间，然后继续通过response中间件得到控制权。当一个中间件调用 next() 时，该函数暂停并将控制权传递给定义的下一个中间件。当没有更多的下级中间件执行，堆栈将释放，并且将逆序执行每个中间件的代码。</p>\n<blockquote>\n<p>原文并未使用箭头函数</p>\n</blockquote>\n<pre><code> const Koa = require(&#39;koa&#39;);\n const app = new Koa();\n\n// x-response-time\n\napp.use(async (ctx, next) =&gt; {\n  const start = new Date();\n  await next();\n  const ms = new Date() - start;\n  ctx.set(&#39;X-Response-Time&#39;, `${ms}ms`);\n });\n\n // logger\n\n app.use(async (ctx, next) =&gt; {\n  const start = new Date();\n  await next();\n  const ms = new Date() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}`);\n });\n\n// response\n\napp.use(ctx =&gt; {\n  ctx.body = &#39;Hello World&#39;;\n});\n\napp.listen(3000);\n</code></pre><h3 id=\"Settings\"><a href=\"#Settings\" class=\"headerlink\" title=\"Settings\"></a>Settings</h3><p>应用配置是实例app的属性，目前支持以下配置：</p>\n<ul>\n<li>app.env 默认为NODE_DEV或development</li>\n<li>app.proxy 如果为true，则header域将被信任</li>\n<li>app.subdomainOffset 默认为2 表示.subdomains所忽略的字符偏移量</li>\n</ul>\n<h3 id=\"app-listen-…\"><a href=\"#app-listen-…\" class=\"headerlink\" title=\"app.listen(…)\"></a>app.listen(…)</h3><p> Koa应用并不是一个HTTP服务器的单一映射表现方式。一个或多个Koa应用可以被一起挂载，形成一个具有单一HTTP服务器的较大型的应用。</p>\n<p> 创建并返回一个HTTP服务器，将给定的参数传递给Server#listen()。<a href=\"https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback\" target=\"_blank\" rel=\"external\">(参数配置参考)</a><br> 以下为创建一个绑定3000端口的简单Koa应用：</p>\n<pre><code> const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\napp.listen(3000);\n</code></pre><p>app.listen(…)实际上以下代码的语法糖：</p>\n<pre><code>const http = require(&#39;http&#39;);\nconst Koa = require(&#39;koa&#39;);\nconst app = new Koa();\nhttp.createServer(app.callback().listen(3000));\n</code></pre><p>这意味这你可以同时启动HTTP和HTTPS或多个地址相同的引用程序：</p>\n<pre><code>const http = require(&#39;http&#39;);\nconst Koa = require(&#39;koa&#39;);\nconst app = new Koa();\nhttp.createServer(app.callback().listen(3000));\nhttp.createServer(app.callback().listen(3000));\n</code></pre><h3 id=\"app-callback\"><a href=\"#app-callback\" class=\"headerlink\" title=\"app.callback()\"></a>app.callback()</h3><p>返回一个适用于http。createServer()方法的回调函数来处理请求。你也可以使用这个回调函数将你的Koa应用挂载到 Connect/Express 应用上。</p>\n<h3 id=\"app-use-function\"><a href=\"#app-use-function\" class=\"headerlink\" title=\"app.use(function)\"></a>app.use(function)</h3><p>将给定的中间件添加到应用中<a href=\"https://github.com/koajs/koa/wiki#middleware\" target=\"_blank\" rel=\"external\">(参考Middleware)</a></p>\n<h3 id=\"app-keys\"><a href=\"#app-keys\" class=\"headerlink\" title=\"app.keys =\"></a>app.keys =</h3><p>设置签名Cookie密钥<br>该密钥将会被传递给<a href=\"https://github.com/koajs/koa/wiki#middleware\" target=\"_blank\" rel=\"external\">KEyGrip</a>。<br>你也可以传递自己生成的KEyGrip实例。如下：</p>\n<pre><code>app.keys = [ &#39;im a newer secret&#39;, &#39;i like turtle&#39;];\napp.keys = new KeyGrip([&#39;im a newer secret&#39;, &#39;i like turtle&#39;], &#39;sha256&#39;);\n</code></pre><p>在进行cookie签名时。，这些键只有在设置signed 为 true 时才会使用密钥进行加密：</p>\n<pre><code>this.cookies.set(&#39;name&#39;, &#39;tobi&#39;, {signed: true});\n</code></pre><h3 id=\"app-context\"><a href=\"#app-context\" class=\"headerlink\" title=\"app.context\"></a>app.context</h3><p>app.context是从ctx中创建的原型。你可以通过编辑app.context添加额外的属性到ctx上。这对于添加属性或方法到ctx上在整个应用程序上使用非常有用，这也可能会更为有效（无中间件）并更容易（更少使用require())牺牲更多依赖在ctx上，这可以被视为反模式。</p>\n<p>举个例，添加一个数据库引用到ctx:</p>\n<pre><code>app.context.db = db();\napp.use(async (ctx) =&gt; {\n  console.log(ctx.db);\n});\n</code></pre><hr>\n<p>Note：</p>\n<ul>\n<li>ctx上的许多属性定义时使用了，getters，setters和Object.defineProperty()。你只能编辑这些属性（不推荐）通过使用Object.defineProperty app.context()。<a href=\"https://github.com/koajs/koa/issues/652\" target=\"_blank\" rel=\"external\">(See more)</a></li>\n<li>这一段有点晕。。。</li>\n</ul>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>默认情况下，Koa会讲所有错误日志输出到stderr中，除非 app。silent = true。默认错误处理页不会在 err.status = 404 或 err.expose = true 时输出错误。想要执行自定义错误处理逻辑（例如 centralized logging），你可以添加“error”事件监听器。</p>\n<pre><code>app.on(&#39;error&#39;, err =&gt; {\n  log.error(&#39;serrver error&#39;, err);\n});\n</code></pre><p>如果在 req／res 周期中出现error，并且不能够影响客户端时，Context实例也会被传递到error事件监听器的回调函数中：</p>\n<pre><code>app.on(&#39;error&#39;, (err, ctx) =&gt; {\n  log.error(&#39;server error&#39;, err, ctx);\n});\n</code></pre><p>当发生错误并且仍然可以响应客户端时，例如没有数据被写入到socker中时，Koa将返回一个 500／服务器内部错误。<br>无论哪种情况，Koa都会生成一个应用级别的错误，来实现日志记录。</p>\n<h2 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h2><p>Koa Context将node的request和response对象封装到一个单独的对象中，为编写web应用和API提供了很多有用的方法。这些操作在开发HTTP服务器中经常被使用，因此被添加在context这一层级总而不是更高层级的框架中，这将迫使中间件需要重新实现这些公共的方法。<br>Context 根据每个request创建，并在中间件中作为接收器（receiver ）或通过 ctx 标识符来引用<br>如下代码展示：</p>\n<pre><code>app.use(async (ctx, next) =&gt; {\n  ctx; // is the Context\n  ctx.request; // is a koa Request\n  ctx.response; // is a koa Response\n})\n</code></pre><p>许多Context的访问器和方法为了方便起见，简单地委托给ctx.request和ctx.response 所对应的等价方法。<br>举个例子，ctx.type和ctx.length 代理了 response对象中对应的方法， ctx.path和ctx.method代理了 resquest 对象中对应的方法。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><p>Context 具体的方法和访问器。</p>\n<h3 id=\"ctx-req\"><a href=\"#ctx-req\" class=\"headerlink\" title=\"ctx.req\"></a>ctx.req</h3><p>Node的request对象</p>\n<h3 id=\"ctx-res\"><a href=\"#ctx-res\" class=\"headerlink\" title=\"ctx.res\"></a>ctx.res</h3><p>Node的response对象</p>\n<p>Koa不支持直接调用底层response处理。请避免使用以下Node属性：</p>\n<ul>\n<li>res.statusCode</li>\n<li>res.writeHead()</li>\n<li>res.write()</li>\n<li>res.end()</li>\n</ul>\n<h3 id=\"ctx-request\"><a href=\"#ctx-request\" class=\"headerlink\" title=\"ctx.request\"></a>ctx.request</h3><p>Koa 的 Request 对象。</p>\n<h3 id=\"ctx-response\"><a href=\"#ctx-response\" class=\"headerlink\" title=\"ctx.response\"></a>ctx.response</h3><p>Koa 的 Response 对象。</p>\n<h3 id=\"ctx-state\"><a href=\"#ctx-state\" class=\"headerlink\" title=\"ctx.state\"></a>ctx.state</h3><p>自定义命名空间，用于将信息从中间件传递到前端视图层</p>\n<pre><code>ctx.state.user = await User.find(id);\n</code></pre><h3 id=\"ctx-app\"><a href=\"#ctx-app\" class=\"headerlink\" title=\"ctx.app\"></a>ctx.app</h3><p>应用实例引用。</p>\n<h3 id=\"ctx-cookies-get-name-options\"><a href=\"#ctx-cookies-get-name-options\" class=\"headerlink\" title=\"ctx.cookies.get(name, [options])\"></a>ctx.cookies.get(name, [options])</h3><p>获取 cookie 中 name 的值 options为可选参数。</p>\n<ul>\n<li>signed：对cookie请求时需要设置签名。</li>\n</ul>\n<p>Koa 使用 <a href=\"https://github.com/pillarjs/cookies\" target=\"_blank\" rel=\"external\">cookies模块</a>,options参数只是简单地直接传递。</p>\n<h3 id=\"ctx-cookies-set-name-value-options\"><a href=\"#ctx-cookies-set-name-value-options\" class=\"headerlink\" title=\"ctx.cookies.set(name, value, [options])\"></a>ctx.cookies.set(name, value, [options])</h3><p>设置 cookie 中 name值， options为可选参数。</p>\n<ul>\n<li>maxAge: 表示 Date.now() 到期的毫米数， number.</li>\n<li>signed: Cookie 签名</li>\n<li>expires: Cookie有效时间</li>\n<li>path: Cookie路径，默认为<code>/&#39;</code></li>\n<li>domain: Cookie的域</li>\n<li>secure: Cookie安全协议 false表示Cookie通过HTTP协议传送，true表示Cookie通过HTTPS协议传送。</li>\n<li>httpOnly: 服务器可访问的Cookie 默认为true</li>\n<li>overwrite: 一个布尔值，表示是否覆盖重写以前设置的同名的Cookie（默认为false）如果为true，在设置这个新Cookie时，将在同一个请求中设置所有相同名称的Cookie（不论路径或域）并从Set-Cookie头部中过滤掉。</li>\n</ul>\n<p>Koa 使用 <a href=\"https://github.com/pillarjs/cookies\" target=\"_blank\" rel=\"external\">cookies模块</a>,options参数只是简单地直接传递。</p>\n<h3 id=\"ctx-throw-msg-status-properties\"><a href=\"#ctx-throw-msg-status-properties\" class=\"headerlink\" title=\"ctx.throw([msg], [status], [properties])\"></a>ctx.throw([msg], [status], [properties])</h3><p>Helper方法抛出一个.status属性默认为500的错误。该方法允许Koa准确的响应处理状态。<br>Koa允许以下组合：</p>\n<pre><code>ctx.throw(403);\nctx.throw(&#39;name required&#39;, 400);\nctx.throw(400, &#39;name required&#39;);\nctx.throw(&#39;something exploded&#39;);\n</code></pre><p>举个例子 <code>ctx.throw(&#39;name required&#39;, 400)</code>等价于：</p>\n<pre><code>const err = new Error(&#39;name required&#39;);\nerr.status = 400;\nerr.expose = true;\nthrow err;\n</code></pre><p>请注意，这些是用户级错误，并会被标记为err.expose,这意味着消息会被准确描述为对客户端的响应，而并非使用在您不想泄漏失败细节的情景中。</p>\n<p>你可以根据需要将合并后的属性对象船钓错误中去，这对于向上级中间件请求的友好的机器化错误有着很好的装饰作用</p>\n<pre><code>ctx.throw(401, &#39;access_denied&#39;, { user: user });\nctx.throw(&#39;access_denied&#39;, { user: user });\n</code></pre><p>Koa 使用<a href=\"https://github.com/jshttp/http-errors\" target=\"_blank\" rel=\"external\">http-errors</a>来创建错误。</p>\n<h3 id=\"ctx-assert-value-status-msg-properties\"><a href=\"#ctx-assert-value-status-msg-properties\" class=\"headerlink\" title=\"ctx.assert(value, [status], [msg], [properties])\"></a>ctx.assert(value, [status], [msg], [properties])</h3><p>当 !value时，Helper方法抛出类似于.throw()的错误。<br>相当于node中的<a href=\"https://nodejs.org/api/assert.html\" target=\"_blank\" rel=\"external\">assert</a>方法</p>\n<pre><code>ctx.assert(ctx.state.user, 401, &#39;User not found. Please login!&#39;);\n</code></pre><p>Koa 使用<a href=\"https://github.com/jshttp/http-assert\" target=\"_blank\" rel=\"external\">http-assert</a>判断</p>\n<h3 id=\"ctx-respond\"><a href=\"#ctx-respond\" class=\"headerlink\" title=\"ctx.respond\"></a>ctx.respond</h3><p>为了避免Koa的内置响应处理，你可以直接设置 ctx.respond = false;<br>如果你想使用原生的res对象代替Koa操作response，那么请使用这种方法。</p>\n<p>请注意，Koa并不支持这种使用方式，因为这有可能破坏Koa中间件和Koa本身的一些功能。<br>这只能作为一种hack的方式，并只对希望在Koa的函数和中间件中使用传统的fn(req, res)的人带来便捷。</p>\n<h3 id=\"Request-aliases\"><a href=\"#Request-aliases\" class=\"headerlink\" title=\"Request aliases\"></a>Request aliases</h3><p>以下的访问器别名与 <a href=\"#Request\">Request</a> 等价：</p>\n<pre><code>ctx.header\nctx.headers\nctx.method\nctx.method=\nctx.url\nctx.url=\nctx.originalUrl\nctx.originalUrlctx.href\nctx.path\nctx.path=\nctx.query\nctx.query=\nctx.querystring\nctx.querystring=\nctx.host\nctx.hostname\nctx.fresh\nctx.stale\nctx.socket\nctx.protocol\nctx.secure\nctx.ip\nctx.ips\nctx.subdomains\nctx.is()\nctx.accepts()\nctx.acceptsEncodings()\nctx.acceptsLanguages()\nctx.get()\n</code></pre><h3 id=\"Response-aliases\"><a href=\"#Response-aliases\" class=\"headerlink\" title=\"Response aliases\"></a>Response aliases</h3><p>以下访问器别名与 <a href=\"#response\">Response</a>等价:</p>\n<pre><code>ctx.body\nctx.body=\nctx.status\nctx.status=\nctx.message\nctx.message=\nctx.length\nctx.length=\nctx.type\nctx.type=\nctx.headerSent\nctx.rdirect()\nctx.attachment()\nctx.set()\nctx.append()\nctx.remove()\nctx.lastModified=\nctx.etag=\n</code></pre><h2 id=\"Request\"><a href=\"#Request\" class=\"headerlink\" title=\"Request\"></a><span id=\"request\">Request</span></h2><p>Koa的Request对象是对node的Request对象进一步抽象，封装。<br>提供了对日常HTTP服务器开发有用的一些功能函数</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><h4 id=\"request-header\"><a href=\"#request-header\" class=\"headerlink\" title=\"request.header\"></a>request.header</h4><p>请求头对象</p>\n<h4 id=\"request-headers\"><a href=\"#request-headers\" class=\"headerlink\" title=\"request.headers\"></a>request.headers</h4><p>请求头对象的别名</p>\n<h4 id=\"request-method\"><a href=\"#request-method\" class=\"headerlink\" title=\"request.method\"></a>request.method</h4><p>请求方法</p>\n<h4 id=\"request-method-1\"><a href=\"#request-method-1\" class=\"headerlink\" title=\"request.method=\"></a>request.method=</h4><p>设置请求方法，在实现中间件时有很大作用，例如methodOverride()</p>\n<h4 id=\"request-length\"><a href=\"#request-length\" class=\"headerlink\" title=\"request.length\"></a>request.length</h4><p>以数字的形式返回request的内容长度(Content-lenght),或者返回undefined</p>\n<h4 id=\"request-url\"><a href=\"#request-url\" class=\"headerlink\" title=\"request.url\"></a>request.url</h4><p>获取请求url地址</p>\n<h4 id=\"request-url-1\"><a href=\"#request-url-1\" class=\"headerlink\" title=\"request.url=\"></a>request.url=</h4><p>设置请求地址，用于重写url</p>\n<h4 id=\"request-originalUrl\"><a href=\"#request-originalUrl\" class=\"headerlink\" title=\"request.originalUrl\"></a>request.originalUrl</h4><p>获取请求原始url</p>\n<h4 id=\"request-origin\"><a href=\"#request-origin\" class=\"headerlink\" title=\"request.origin\"></a>request.origin</h4><p>获取url来源，包括protocol和host</p>\n<pre><code>ctx.request.origin\n// =&gt; http://example.com\n</code></pre><h4 id=\"request-href\"><a href=\"#request-href\" class=\"headerlink\" title=\"request.href\"></a>request.href</h4><p>获取请求完整的URL，包括protpcol，host和url</p>\n<pre><code>ctx.request.href\n// =&gt; http://example.com/foo/bar?q=1\n</code></pre><h4 id=\"request-path\"><a href=\"#request-path\" class=\"headerlink\" title=\"request.path\"></a>request.path</h4><p>获取请求路径名。</p>\n<h4 id=\"request-path-1\"><a href=\"#request-path-1\" class=\"headerlink\" title=\"request.path=\"></a>request.path=</h4><p>设置请求路径名，并保存’?’后面的部分（请求参数）</p>\n<h4 id=\"request-querystring\"><a href=\"#request-querystring\" class=\"headerlink\" title=\"request.querystring\"></a>request.querystring</h4><p>获取请求的查询参数(url中?后边的部分)不包含？</p>\n<h4 id=\"request-querystring-1\"><a href=\"#request-querystring-1\" class=\"headerlink\" title=\"request.querystring=\"></a>request.querystring=</h4><p>设置查询参数</p>\n<h4 id=\"request-search\"><a href=\"#request-search\" class=\"headerlink\" title=\"request.search\"></a>request.search</h4><p>获取请求的查询参数，包含?</p>\n<h4 id=\"request-search-1\"><a href=\"#request-search-1\" class=\"headerlink\" title=\"request.search=\"></a>request.search=</h4><p>设置请求的查询参数。</p>\n<h4 id=\"request-host\"><a href=\"#request-host\" class=\"headerlink\" title=\"request.host\"></a>request.host</h4><p>获取当前host(hostname: port) 当 app.proxy = true 时, 支持X-Forwarded-Host。</p>\n<h4 id=\"request-hostname\"><a href=\"#request-hostname\" class=\"headerlink\" title=\"request.hostname\"></a>request.hostname</h4><p>获取hostname，当 app.proxy = ture 时, 支持X-Forwarded-Host.</p>\n<h4 id=\"request-type\"><a href=\"#request-type\" class=\"headerlink\" title=\"request.type\"></a>request.type</h4><p>获取当前请求的 Conetent-Type 不包含如<code>charset</code>这样的参数。</p>\n<pre><code>const ct = ctx.request.type\n// =&gt; &quot;image/png&quot;\n</code></pre><h4 id=\"request-charset\"><a href=\"#request-charset\" class=\"headerlink\" title=\"request.charset\"></a>request.charset</h4><p>获取当前请求的 charset 没有则返回undefined</p>\n<pre><code>ctx.request.charset\n// =&gt; &quot;utf-8&quot;\n</code></pre><h4 id=\"request-query\"><a href=\"#request-query\" class=\"headerlink\" title=\"request.query\"></a>request.query</h4><p>获取解析后的查询字符串，当请求中没有查询字符串时则返回一个空对象。<br>请注意，这个方法不支持嵌套对象。<br>例如：<code>color=blue&amp;size=small</code></p>\n<pre><code>{\n  color: &#39;blue&#39;,\n  size: &#39;small&#39;\n}\n</code></pre><h4 id=\"request-query-1\"><a href=\"#request-query-1\" class=\"headerlink\" title=\"request.query=\"></a>request.query=</h4><p>根据给定的对象设置查询字符串。<br>请注意，这个方法不支持嵌套对象。</p>\n<pre><code>ctx.query = {next: &#39;/login&#39;}\n</code></pre><h4 id=\"request-fresh\"><a href=\"#request-fresh\" class=\"headerlink\" title=\"request.fresh\"></a>request.fresh</h4><h2 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a><span id=\"response\">Response</span></h2>","site":{"data":{}},"excerpt":"<p>边学英语边学koa</p>","more":"<h2 id=\"KOA\"><a href=\"#KOA\" class=\"headerlink\" title=\"KOA\"></a>KOA</h2><h3 id=\"koa\"><a href=\"#koa\" class=\"headerlink\" title=\"koa\"></a>koa</h3><p>基于node.js的下一代web框架</p>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>koa是由Express开发团队设计的新型Web框架，旨在为Web应用和Apis提供更小，更具表现力和更强大基础。通过组合利用generators，可以避免回调嵌套并大大提高处理错误的能力。koa不在核心中捆绑任何中间件，仅仅提供了一套轻量优雅的方法库，使得编写服务更加便捷。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>koa需要 node &gt;= ^7.6.0版本来支持ES2015和async。<br>你可以安装node版本控制器来升级到需求版本。</p>\n<pre><code>npm install n -g\nn 7.6.0\nnpm install koa\nnode my-koa-app.js\n</code></pre><h3 id=\"Async与Babel\"><a href=\"#Async与Babel\" class=\"headerlink\" title=\"Async与Babel\"></a>Async与Babel</h3><p>要想在node低于^7.6.0的环境，koa中使用Async函数，我们推荐使用<a href=\"https://babeljs.io/docs/usage/babel-register/\" target=\"_blank\" rel=\"external\">babel’s require hook</a></p>\n<pre><code>require(&#39;babel-core/register&#39;);\n// require the rest of the app that needs to be transpiled after the hook\nconst app = require(&#39;./app&#39;);\n</code></pre><p>为了解析和转换Async函数， 你至少应该有<a href=\"http://babeljs.io/docs/plugins/transform-async-to-generator/\" target=\"_blank\" rel=\"external\">transform-async-to-generator</a>或<a href=\"http://babeljs.io/docs/plugins/transform-async-to-module-method/\" target=\"_blank\" rel=\"external\">transform-async-to-module-method</a>插件。<br>举个例，在你的<code>.babelrc</code>文件中，你应该有如下配置:</p>\n<pre><code>{\n  &quot;plugins&quot;: [&quot;transform-async-to-generator&quot;]\n}\n</code></pre><p>你当然也可以使用<a href=\"http://babeljs.io/docs/plugins/preset-stage-3/\" target=\"_blank\" rel=\"external\">Stage 3 preset</a>代替</p>\n<blockquote>\n<p>讲道理干嘛这么麻烦。。不如用node^7.6.0</p>\n</blockquote>\n<h3 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h3><p>koa应用是一个包含一系列中间件的对象，这些中间件函数根据request请求按照类似堆栈的方式构成依次执行。Koa类似于其他您可能使用过的中间件系统（如Ruby‘s Rack，Connect等）。然而Koa的核心设计思路是为其他低等级的中间件层提供高级语法糖，以提高其可操作性和稳定性，并使编写中间件变得更便捷。</p>\n<p>Koa包含了像content-negotiation(内容协商)、cache freshness（缓存刷新）、proxy support（代理支持）和 redirection（重定向）等常用任务方法。尽管有相当大数量的函数支持，Koa仅仅包含很小一部分，因为Koa没有中间件捆绑。</p>\n<p>编写一个 hello world 应用：</p>\n<pre><code>const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\n\napp.use(ctx =&gt; {\n  ctx.body = &#39;Hello World&#39;;\n});\n\napp.listen(3000);\n</code></pre><h3 id=\"Cascading—级联\"><a href=\"#Cascading—级联\" class=\"headerlink\" title=\"Cascading—级联\"></a>Cascading—级联</h3><p>Koa中间件以更传统的方式级联，像你习惯使用的一些类似工具——在过去这使得用户很难友好的使用node频繁回调。然而通过使用Async函数，我们能”真正”实现中间件。Connect的实现是简单地通过一系列的函数传递控制权，直到一个函数返回。而Koa则是通调用下一个中间件，然后将控制权逐级返还到上级中间件。</p>\n<p>下面的例子将返回 <code>Hello World</code>，然而当请求开始时，将先经过x-response-time和logging中间件，记录中间件执行起始时间，然后继续通过response中间件得到控制权。当一个中间件调用 next() 时，该函数暂停并将控制权传递给定义的下一个中间件。当没有更多的下级中间件执行，堆栈将释放，并且将逆序执行每个中间件的代码。</p>\n<blockquote>\n<p>原文并未使用箭头函数</p>\n</blockquote>\n<pre><code> const Koa = require(&#39;koa&#39;);\n const app = new Koa();\n\n// x-response-time\n\napp.use(async (ctx, next) =&gt; {\n  const start = new Date();\n  await next();\n  const ms = new Date() - start;\n  ctx.set(&#39;X-Response-Time&#39;, `${ms}ms`);\n });\n\n // logger\n\n app.use(async (ctx, next) =&gt; {\n  const start = new Date();\n  await next();\n  const ms = new Date() - start;\n  console.log(`${ctx.method} ${ctx.url} - ${ms}`);\n });\n\n// response\n\napp.use(ctx =&gt; {\n  ctx.body = &#39;Hello World&#39;;\n});\n\napp.listen(3000);\n</code></pre><h3 id=\"Settings\"><a href=\"#Settings\" class=\"headerlink\" title=\"Settings\"></a>Settings</h3><p>应用配置是实例app的属性，目前支持以下配置：</p>\n<ul>\n<li>app.env 默认为NODE_DEV或development</li>\n<li>app.proxy 如果为true，则header域将被信任</li>\n<li>app.subdomainOffset 默认为2 表示.subdomains所忽略的字符偏移量</li>\n</ul>\n<h3 id=\"app-listen-…\"><a href=\"#app-listen-…\" class=\"headerlink\" title=\"app.listen(…)\"></a>app.listen(…)</h3><p> Koa应用并不是一个HTTP服务器的单一映射表现方式。一个或多个Koa应用可以被一起挂载，形成一个具有单一HTTP服务器的较大型的应用。</p>\n<p> 创建并返回一个HTTP服务器，将给定的参数传递给Server#listen()。<a href=\"https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback\" target=\"_blank\" rel=\"external\">(参数配置参考)</a><br> 以下为创建一个绑定3000端口的简单Koa应用：</p>\n<pre><code> const Koa = require(&#39;koa&#39;);\nconst app = new Koa();\napp.listen(3000);\n</code></pre><p>app.listen(…)实际上以下代码的语法糖：</p>\n<pre><code>const http = require(&#39;http&#39;);\nconst Koa = require(&#39;koa&#39;);\nconst app = new Koa();\nhttp.createServer(app.callback().listen(3000));\n</code></pre><p>这意味这你可以同时启动HTTP和HTTPS或多个地址相同的引用程序：</p>\n<pre><code>const http = require(&#39;http&#39;);\nconst Koa = require(&#39;koa&#39;);\nconst app = new Koa();\nhttp.createServer(app.callback().listen(3000));\nhttp.createServer(app.callback().listen(3000));\n</code></pre><h3 id=\"app-callback\"><a href=\"#app-callback\" class=\"headerlink\" title=\"app.callback()\"></a>app.callback()</h3><p>返回一个适用于http。createServer()方法的回调函数来处理请求。你也可以使用这个回调函数将你的Koa应用挂载到 Connect/Express 应用上。</p>\n<h3 id=\"app-use-function\"><a href=\"#app-use-function\" class=\"headerlink\" title=\"app.use(function)\"></a>app.use(function)</h3><p>将给定的中间件添加到应用中<a href=\"https://github.com/koajs/koa/wiki#middleware\" target=\"_blank\" rel=\"external\">(参考Middleware)</a></p>\n<h3 id=\"app-keys\"><a href=\"#app-keys\" class=\"headerlink\" title=\"app.keys =\"></a>app.keys =</h3><p>设置签名Cookie密钥<br>该密钥将会被传递给<a href=\"https://github.com/koajs/koa/wiki#middleware\" target=\"_blank\" rel=\"external\">KEyGrip</a>。<br>你也可以传递自己生成的KEyGrip实例。如下：</p>\n<pre><code>app.keys = [ &#39;im a newer secret&#39;, &#39;i like turtle&#39;];\napp.keys = new KeyGrip([&#39;im a newer secret&#39;, &#39;i like turtle&#39;], &#39;sha256&#39;);\n</code></pre><p>在进行cookie签名时。，这些键只有在设置signed 为 true 时才会使用密钥进行加密：</p>\n<pre><code>this.cookies.set(&#39;name&#39;, &#39;tobi&#39;, {signed: true});\n</code></pre><h3 id=\"app-context\"><a href=\"#app-context\" class=\"headerlink\" title=\"app.context\"></a>app.context</h3><p>app.context是从ctx中创建的原型。你可以通过编辑app.context添加额外的属性到ctx上。这对于添加属性或方法到ctx上在整个应用程序上使用非常有用，这也可能会更为有效（无中间件）并更容易（更少使用require())牺牲更多依赖在ctx上，这可以被视为反模式。</p>\n<p>举个例，添加一个数据库引用到ctx:</p>\n<pre><code>app.context.db = db();\napp.use(async (ctx) =&gt; {\n  console.log(ctx.db);\n});\n</code></pre><hr>\n<p>Note：</p>\n<ul>\n<li>ctx上的许多属性定义时使用了，getters，setters和Object.defineProperty()。你只能编辑这些属性（不推荐）通过使用Object.defineProperty app.context()。<a href=\"https://github.com/koajs/koa/issues/652\" target=\"_blank\" rel=\"external\">(See more)</a></li>\n<li>这一段有点晕。。。</li>\n</ul>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>默认情况下，Koa会讲所有错误日志输出到stderr中，除非 app。silent = true。默认错误处理页不会在 err.status = 404 或 err.expose = true 时输出错误。想要执行自定义错误处理逻辑（例如 centralized logging），你可以添加“error”事件监听器。</p>\n<pre><code>app.on(&#39;error&#39;, err =&gt; {\n  log.error(&#39;serrver error&#39;, err);\n});\n</code></pre><p>如果在 req／res 周期中出现error，并且不能够影响客户端时，Context实例也会被传递到error事件监听器的回调函数中：</p>\n<pre><code>app.on(&#39;error&#39;, (err, ctx) =&gt; {\n  log.error(&#39;server error&#39;, err, ctx);\n});\n</code></pre><p>当发生错误并且仍然可以响应客户端时，例如没有数据被写入到socker中时，Koa将返回一个 500／服务器内部错误。<br>无论哪种情况，Koa都会生成一个应用级别的错误，来实现日志记录。</p>\n<h2 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h2><p>Koa Context将node的request和response对象封装到一个单独的对象中，为编写web应用和API提供了很多有用的方法。这些操作在开发HTTP服务器中经常被使用，因此被添加在context这一层级总而不是更高层级的框架中，这将迫使中间件需要重新实现这些公共的方法。<br>Context 根据每个request创建，并在中间件中作为接收器（receiver ）或通过 ctx 标识符来引用<br>如下代码展示：</p>\n<pre><code>app.use(async (ctx, next) =&gt; {\n  ctx; // is the Context\n  ctx.request; // is a koa Request\n  ctx.response; // is a koa Response\n})\n</code></pre><p>许多Context的访问器和方法为了方便起见，简单地委托给ctx.request和ctx.response 所对应的等价方法。<br>举个例子，ctx.type和ctx.length 代理了 response对象中对应的方法， ctx.path和ctx.method代理了 resquest 对象中对应的方法。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><p>Context 具体的方法和访问器。</p>\n<h3 id=\"ctx-req\"><a href=\"#ctx-req\" class=\"headerlink\" title=\"ctx.req\"></a>ctx.req</h3><p>Node的request对象</p>\n<h3 id=\"ctx-res\"><a href=\"#ctx-res\" class=\"headerlink\" title=\"ctx.res\"></a>ctx.res</h3><p>Node的response对象</p>\n<p>Koa不支持直接调用底层response处理。请避免使用以下Node属性：</p>\n<ul>\n<li>res.statusCode</li>\n<li>res.writeHead()</li>\n<li>res.write()</li>\n<li>res.end()</li>\n</ul>\n<h3 id=\"ctx-request\"><a href=\"#ctx-request\" class=\"headerlink\" title=\"ctx.request\"></a>ctx.request</h3><p>Koa 的 Request 对象。</p>\n<h3 id=\"ctx-response\"><a href=\"#ctx-response\" class=\"headerlink\" title=\"ctx.response\"></a>ctx.response</h3><p>Koa 的 Response 对象。</p>\n<h3 id=\"ctx-state\"><a href=\"#ctx-state\" class=\"headerlink\" title=\"ctx.state\"></a>ctx.state</h3><p>自定义命名空间，用于将信息从中间件传递到前端视图层</p>\n<pre><code>ctx.state.user = await User.find(id);\n</code></pre><h3 id=\"ctx-app\"><a href=\"#ctx-app\" class=\"headerlink\" title=\"ctx.app\"></a>ctx.app</h3><p>应用实例引用。</p>\n<h3 id=\"ctx-cookies-get-name-options\"><a href=\"#ctx-cookies-get-name-options\" class=\"headerlink\" title=\"ctx.cookies.get(name, [options])\"></a>ctx.cookies.get(name, [options])</h3><p>获取 cookie 中 name 的值 options为可选参数。</p>\n<ul>\n<li>signed：对cookie请求时需要设置签名。</li>\n</ul>\n<p>Koa 使用 <a href=\"https://github.com/pillarjs/cookies\" target=\"_blank\" rel=\"external\">cookies模块</a>,options参数只是简单地直接传递。</p>\n<h3 id=\"ctx-cookies-set-name-value-options\"><a href=\"#ctx-cookies-set-name-value-options\" class=\"headerlink\" title=\"ctx.cookies.set(name, value, [options])\"></a>ctx.cookies.set(name, value, [options])</h3><p>设置 cookie 中 name值， options为可选参数。</p>\n<ul>\n<li>maxAge: 表示 Date.now() 到期的毫米数， number.</li>\n<li>signed: Cookie 签名</li>\n<li>expires: Cookie有效时间</li>\n<li>path: Cookie路径，默认为<code>/&#39;</code></li>\n<li>domain: Cookie的域</li>\n<li>secure: Cookie安全协议 false表示Cookie通过HTTP协议传送，true表示Cookie通过HTTPS协议传送。</li>\n<li>httpOnly: 服务器可访问的Cookie 默认为true</li>\n<li>overwrite: 一个布尔值，表示是否覆盖重写以前设置的同名的Cookie（默认为false）如果为true，在设置这个新Cookie时，将在同一个请求中设置所有相同名称的Cookie（不论路径或域）并从Set-Cookie头部中过滤掉。</li>\n</ul>\n<p>Koa 使用 <a href=\"https://github.com/pillarjs/cookies\" target=\"_blank\" rel=\"external\">cookies模块</a>,options参数只是简单地直接传递。</p>\n<h3 id=\"ctx-throw-msg-status-properties\"><a href=\"#ctx-throw-msg-status-properties\" class=\"headerlink\" title=\"ctx.throw([msg], [status], [properties])\"></a>ctx.throw([msg], [status], [properties])</h3><p>Helper方法抛出一个.status属性默认为500的错误。该方法允许Koa准确的响应处理状态。<br>Koa允许以下组合：</p>\n<pre><code>ctx.throw(403);\nctx.throw(&#39;name required&#39;, 400);\nctx.throw(400, &#39;name required&#39;);\nctx.throw(&#39;something exploded&#39;);\n</code></pre><p>举个例子 <code>ctx.throw(&#39;name required&#39;, 400)</code>等价于：</p>\n<pre><code>const err = new Error(&#39;name required&#39;);\nerr.status = 400;\nerr.expose = true;\nthrow err;\n</code></pre><p>请注意，这些是用户级错误，并会被标记为err.expose,这意味着消息会被准确描述为对客户端的响应，而并非使用在您不想泄漏失败细节的情景中。</p>\n<p>你可以根据需要将合并后的属性对象船钓错误中去，这对于向上级中间件请求的友好的机器化错误有着很好的装饰作用</p>\n<pre><code>ctx.throw(401, &#39;access_denied&#39;, { user: user });\nctx.throw(&#39;access_denied&#39;, { user: user });\n</code></pre><p>Koa 使用<a href=\"https://github.com/jshttp/http-errors\" target=\"_blank\" rel=\"external\">http-errors</a>来创建错误。</p>\n<h3 id=\"ctx-assert-value-status-msg-properties\"><a href=\"#ctx-assert-value-status-msg-properties\" class=\"headerlink\" title=\"ctx.assert(value, [status], [msg], [properties])\"></a>ctx.assert(value, [status], [msg], [properties])</h3><p>当 !value时，Helper方法抛出类似于.throw()的错误。<br>相当于node中的<a href=\"https://nodejs.org/api/assert.html\" target=\"_blank\" rel=\"external\">assert</a>方法</p>\n<pre><code>ctx.assert(ctx.state.user, 401, &#39;User not found. Please login!&#39;);\n</code></pre><p>Koa 使用<a href=\"https://github.com/jshttp/http-assert\" target=\"_blank\" rel=\"external\">http-assert</a>判断</p>\n<h3 id=\"ctx-respond\"><a href=\"#ctx-respond\" class=\"headerlink\" title=\"ctx.respond\"></a>ctx.respond</h3><p>为了避免Koa的内置响应处理，你可以直接设置 ctx.respond = false;<br>如果你想使用原生的res对象代替Koa操作response，那么请使用这种方法。</p>\n<p>请注意，Koa并不支持这种使用方式，因为这有可能破坏Koa中间件和Koa本身的一些功能。<br>这只能作为一种hack的方式，并只对希望在Koa的函数和中间件中使用传统的fn(req, res)的人带来便捷。</p>\n<h3 id=\"Request-aliases\"><a href=\"#Request-aliases\" class=\"headerlink\" title=\"Request aliases\"></a>Request aliases</h3><p>以下的访问器别名与 <a href=\"#Request\">Request</a> 等价：</p>\n<pre><code>ctx.header\nctx.headers\nctx.method\nctx.method=\nctx.url\nctx.url=\nctx.originalUrl\nctx.originalUrlctx.href\nctx.path\nctx.path=\nctx.query\nctx.query=\nctx.querystring\nctx.querystring=\nctx.host\nctx.hostname\nctx.fresh\nctx.stale\nctx.socket\nctx.protocol\nctx.secure\nctx.ip\nctx.ips\nctx.subdomains\nctx.is()\nctx.accepts()\nctx.acceptsEncodings()\nctx.acceptsLanguages()\nctx.get()\n</code></pre><h3 id=\"Response-aliases\"><a href=\"#Response-aliases\" class=\"headerlink\" title=\"Response aliases\"></a>Response aliases</h3><p>以下访问器别名与 <a href=\"#response\">Response</a>等价:</p>\n<pre><code>ctx.body\nctx.body=\nctx.status\nctx.status=\nctx.message\nctx.message=\nctx.length\nctx.length=\nctx.type\nctx.type=\nctx.headerSent\nctx.rdirect()\nctx.attachment()\nctx.set()\nctx.append()\nctx.remove()\nctx.lastModified=\nctx.etag=\n</code></pre><h2 id=\"Request\"><a href=\"#Request\" class=\"headerlink\" title=\"Request\"></a><span id=\"request\">Request</span></h2><p>Koa的Request对象是对node的Request对象进一步抽象，封装。<br>提供了对日常HTTP服务器开发有用的一些功能函数</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><h4 id=\"request-header\"><a href=\"#request-header\" class=\"headerlink\" title=\"request.header\"></a>request.header</h4><p>请求头对象</p>\n<h4 id=\"request-headers\"><a href=\"#request-headers\" class=\"headerlink\" title=\"request.headers\"></a>request.headers</h4><p>请求头对象的别名</p>\n<h4 id=\"request-method\"><a href=\"#request-method\" class=\"headerlink\" title=\"request.method\"></a>request.method</h4><p>请求方法</p>\n<h4 id=\"request-method-1\"><a href=\"#request-method-1\" class=\"headerlink\" title=\"request.method=\"></a>request.method=</h4><p>设置请求方法，在实现中间件时有很大作用，例如methodOverride()</p>\n<h4 id=\"request-length\"><a href=\"#request-length\" class=\"headerlink\" title=\"request.length\"></a>request.length</h4><p>以数字的形式返回request的内容长度(Content-lenght),或者返回undefined</p>\n<h4 id=\"request-url\"><a href=\"#request-url\" class=\"headerlink\" title=\"request.url\"></a>request.url</h4><p>获取请求url地址</p>\n<h4 id=\"request-url-1\"><a href=\"#request-url-1\" class=\"headerlink\" title=\"request.url=\"></a>request.url=</h4><p>设置请求地址，用于重写url</p>\n<h4 id=\"request-originalUrl\"><a href=\"#request-originalUrl\" class=\"headerlink\" title=\"request.originalUrl\"></a>request.originalUrl</h4><p>获取请求原始url</p>\n<h4 id=\"request-origin\"><a href=\"#request-origin\" class=\"headerlink\" title=\"request.origin\"></a>request.origin</h4><p>获取url来源，包括protocol和host</p>\n<pre><code>ctx.request.origin\n// =&gt; http://example.com\n</code></pre><h4 id=\"request-href\"><a href=\"#request-href\" class=\"headerlink\" title=\"request.href\"></a>request.href</h4><p>获取请求完整的URL，包括protpcol，host和url</p>\n<pre><code>ctx.request.href\n// =&gt; http://example.com/foo/bar?q=1\n</code></pre><h4 id=\"request-path\"><a href=\"#request-path\" class=\"headerlink\" title=\"request.path\"></a>request.path</h4><p>获取请求路径名。</p>\n<h4 id=\"request-path-1\"><a href=\"#request-path-1\" class=\"headerlink\" title=\"request.path=\"></a>request.path=</h4><p>设置请求路径名，并保存’?’后面的部分（请求参数）</p>\n<h4 id=\"request-querystring\"><a href=\"#request-querystring\" class=\"headerlink\" title=\"request.querystring\"></a>request.querystring</h4><p>获取请求的查询参数(url中?后边的部分)不包含？</p>\n<h4 id=\"request-querystring-1\"><a href=\"#request-querystring-1\" class=\"headerlink\" title=\"request.querystring=\"></a>request.querystring=</h4><p>设置查询参数</p>\n<h4 id=\"request-search\"><a href=\"#request-search\" class=\"headerlink\" title=\"request.search\"></a>request.search</h4><p>获取请求的查询参数，包含?</p>\n<h4 id=\"request-search-1\"><a href=\"#request-search-1\" class=\"headerlink\" title=\"request.search=\"></a>request.search=</h4><p>设置请求的查询参数。</p>\n<h4 id=\"request-host\"><a href=\"#request-host\" class=\"headerlink\" title=\"request.host\"></a>request.host</h4><p>获取当前host(hostname: port) 当 app.proxy = true 时, 支持X-Forwarded-Host。</p>\n<h4 id=\"request-hostname\"><a href=\"#request-hostname\" class=\"headerlink\" title=\"request.hostname\"></a>request.hostname</h4><p>获取hostname，当 app.proxy = ture 时, 支持X-Forwarded-Host.</p>\n<h4 id=\"request-type\"><a href=\"#request-type\" class=\"headerlink\" title=\"request.type\"></a>request.type</h4><p>获取当前请求的 Conetent-Type 不包含如<code>charset</code>这样的参数。</p>\n<pre><code>const ct = ctx.request.type\n// =&gt; &quot;image/png&quot;\n</code></pre><h4 id=\"request-charset\"><a href=\"#request-charset\" class=\"headerlink\" title=\"request.charset\"></a>request.charset</h4><p>获取当前请求的 charset 没有则返回undefined</p>\n<pre><code>ctx.request.charset\n// =&gt; &quot;utf-8&quot;\n</code></pre><h4 id=\"request-query\"><a href=\"#request-query\" class=\"headerlink\" title=\"request.query\"></a>request.query</h4><p>获取解析后的查询字符串，当请求中没有查询字符串时则返回一个空对象。<br>请注意，这个方法不支持嵌套对象。<br>例如：<code>color=blue&amp;size=small</code></p>\n<pre><code>{\n  color: &#39;blue&#39;,\n  size: &#39;small&#39;\n}\n</code></pre><h4 id=\"request-query-1\"><a href=\"#request-query-1\" class=\"headerlink\" title=\"request.query=\"></a>request.query=</h4><p>根据给定的对象设置查询字符串。<br>请注意，这个方法不支持嵌套对象。</p>\n<pre><code>ctx.query = {next: &#39;/login&#39;}\n</code></pre><h4 id=\"request-fresh\"><a href=\"#request-fresh\" class=\"headerlink\" title=\"request.fresh\"></a>request.fresh</h4><h2 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a><span id=\"response\">Response</span></h2>"},{"title":"一些方法","date":"2017-05-23T13:23:26.000Z","_content":"再不努力就完蛋惹。\n<!--more-->\n\n## 学啊学啊学\n\n### 数组去重\n  ```js\n  // 有数组\n  var arr = ['a', 'b', 'c', '1', 0, 'c', 1, '', 1, 0];\n  let unique = function(){};\n  unique(arr);\n  // ['a', 'b', 'c', '1', 0, 1, '']\n  ```\n\n方法一 将原数组中的元素和结果数组中的元素一一比较。\n```js\nfunction unique(arr){\n  let isUnique = [];\n  arr.map(val => {\n    if (isUnique.indexOf(val) === -1) {\n      isUnique.push(val);\n    }\n  })\n  return isUnique;\n}; \n// filter\nfunction unique(arr) {\n  var res = arr.filter( (item, index, array) => {\n    return array.indexOf(item) === index;   \n  })\n  return res;\n}\n```\n\n然而 `indexOf` 不支持 IE6-8.\n\n```js\n// 多用一层循环兼容\nvar indexOf = [].indexOf ?\n  function (arr, item) {\n    return arr.indexOf(item);\n  } :\n  function (arr, item) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] === item) {\n        return i;\n      }\n      else {\n        return -1;\n      }\n    };\n  };\nfunction unique(arr) {\n  var isUnique = [];\n  arr.map(function (val) {\n    if (indexOf(isUnique, val) === -1) {\n      isUnique.push(val);\n    }\n  });\n  return isUnique;\n}\n```\n\n方法二 将原数组中重复元素的最后一个元素放入结果数组中。\n```js\nfunction unique(arr) {\n  var res = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n      // 如果发现相同元素 则i自身进入下一个循环比较\n      if (arr[i] === arr[j]) {\n        j = ++i;\n      }\n    }\n    res.push(arr[i]);\n  }\n  return res;\n}\n```\n\n方法三 ES6\n```js\nvar unique = arr => [...new Set(arr)];\n```\n\n### 类继承与原型继承\n[类继承与原型继承原文](http://www.zcfy.cc/article/master-the-javascript-interview-what-s-the-difference-between-class-amp-prototypal-inheritance-2185.html)\nes6中的`class`是建立在构造函数之上的一种封装，本质依旧是函数。\n\n类继承：使用原型链连接子类与父类的`Prototype`,形成层级划分的代理模式。会产生父—子对象分类的副作用。\n- 紧耦合，脆弱基类\n- 层级僵化 （新用例的出现，最终会使所有涉及到的继承层次上都出现问题）\n- 必然重复性\n原型继承：原型是工作对象的实例，对象直接从其他对象继承属性，因此，对象实例可以由多个对象源所组成。\n\n\n### new出一个实例  [原文](https://rockjins.js.org/2017/01/18/2017-01-18-new-object/)\n\n```js\nvar createObject = function () {\n  // 创建一个空对象\n  console.log(arguments);\n  var obj = new Object(),\n  // 取到构造函数，赋值给Constructor\n    Constructor = [].shift.call(arguments);\n  console.log(Constructor);\n  // 把引用的Constructor的prototype 赋值给obj原型链\n  obj.__proto__ = Constructor.prototype;\n  console.log(obj);\n  // 用apply改变this的指向，用obj代替Constructor构造函数内部的this，并把arguments作为参数传入\n  var ret = Constructor.apply(obj, arguments);\n  \n  return typeof ret === 'object' ? ret : obj;\n};\n\nfunction People(name) {\n  this.name = name;\n};\nPeople.prototype.getName = function() {\n  return this.name;\n};\n\n// 生成实例\nvar Sam = createObject(People, 'Sam');\nvar Lary = new People('Lary');\nconsole.log(Lary);\n```\n\n","source":"_posts/基础题收集.md","raw":"---\ntitle: 一些方法\ndate: 2017-05-23 21:23:26\ntags:\n  - javaScript\n---\n再不努力就完蛋惹。\n<!--more-->\n\n## 学啊学啊学\n\n### 数组去重\n  ```js\n  // 有数组\n  var arr = ['a', 'b', 'c', '1', 0, 'c', 1, '', 1, 0];\n  let unique = function(){};\n  unique(arr);\n  // ['a', 'b', 'c', '1', 0, 1, '']\n  ```\n\n方法一 将原数组中的元素和结果数组中的元素一一比较。\n```js\nfunction unique(arr){\n  let isUnique = [];\n  arr.map(val => {\n    if (isUnique.indexOf(val) === -1) {\n      isUnique.push(val);\n    }\n  })\n  return isUnique;\n}; \n// filter\nfunction unique(arr) {\n  var res = arr.filter( (item, index, array) => {\n    return array.indexOf(item) === index;   \n  })\n  return res;\n}\n```\n\n然而 `indexOf` 不支持 IE6-8.\n\n```js\n// 多用一层循环兼容\nvar indexOf = [].indexOf ?\n  function (arr, item) {\n    return arr.indexOf(item);\n  } :\n  function (arr, item) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] === item) {\n        return i;\n      }\n      else {\n        return -1;\n      }\n    };\n  };\nfunction unique(arr) {\n  var isUnique = [];\n  arr.map(function (val) {\n    if (indexOf(isUnique, val) === -1) {\n      isUnique.push(val);\n    }\n  });\n  return isUnique;\n}\n```\n\n方法二 将原数组中重复元素的最后一个元素放入结果数组中。\n```js\nfunction unique(arr) {\n  var res = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n      // 如果发现相同元素 则i自身进入下一个循环比较\n      if (arr[i] === arr[j]) {\n        j = ++i;\n      }\n    }\n    res.push(arr[i]);\n  }\n  return res;\n}\n```\n\n方法三 ES6\n```js\nvar unique = arr => [...new Set(arr)];\n```\n\n### 类继承与原型继承\n[类继承与原型继承原文](http://www.zcfy.cc/article/master-the-javascript-interview-what-s-the-difference-between-class-amp-prototypal-inheritance-2185.html)\nes6中的`class`是建立在构造函数之上的一种封装，本质依旧是函数。\n\n类继承：使用原型链连接子类与父类的`Prototype`,形成层级划分的代理模式。会产生父—子对象分类的副作用。\n- 紧耦合，脆弱基类\n- 层级僵化 （新用例的出现，最终会使所有涉及到的继承层次上都出现问题）\n- 必然重复性\n原型继承：原型是工作对象的实例，对象直接从其他对象继承属性，因此，对象实例可以由多个对象源所组成。\n\n\n### new出一个实例  [原文](https://rockjins.js.org/2017/01/18/2017-01-18-new-object/)\n\n```js\nvar createObject = function () {\n  // 创建一个空对象\n  console.log(arguments);\n  var obj = new Object(),\n  // 取到构造函数，赋值给Constructor\n    Constructor = [].shift.call(arguments);\n  console.log(Constructor);\n  // 把引用的Constructor的prototype 赋值给obj原型链\n  obj.__proto__ = Constructor.prototype;\n  console.log(obj);\n  // 用apply改变this的指向，用obj代替Constructor构造函数内部的this，并把arguments作为参数传入\n  var ret = Constructor.apply(obj, arguments);\n  \n  return typeof ret === 'object' ? ret : obj;\n};\n\nfunction People(name) {\n  this.name = name;\n};\nPeople.prototype.getName = function() {\n  return this.name;\n};\n\n// 生成实例\nvar Sam = createObject(People, 'Sam');\nvar Lary = new People('Lary');\nconsole.log(Lary);\n```\n\n","slug":"基础题收集","published":1,"updated":"2017-07-24T03:12:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl2z000yttwpvlta5v4r","content":"<p>再不努力就完蛋惹。<br><a id=\"more\"></a></p>\n<h2 id=\"学啊学啊学\"><a href=\"#学啊学啊学\" class=\"headerlink\" title=\"学啊学啊学\"></a>学啊学啊学</h2><h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3><pre><code class=\"js\">  // 有数组\n  var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;1&#39;, 0, &#39;c&#39;, 1, &#39;&#39;, 1, 0];\n  let unique = function(){};\n  unique(arr);\n  // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;1&#39;, 0, 1, &#39;&#39;]\n</code></pre>\n<p>方法一 将原数组中的元素和结果数组中的元素一一比较。</p>\n<pre><code class=\"js\">function unique(arr){\n  let isUnique = [];\n  arr.map(val =&gt; {\n    if (isUnique.indexOf(val) === -1) {\n      isUnique.push(val);\n    }\n  })\n  return isUnique;\n}; \n// filter\nfunction unique(arr) {\n  var res = arr.filter( (item, index, array) =&gt; {\n    return array.indexOf(item) === index;   \n  })\n  return res;\n}\n</code></pre>\n<p>然而 <code>indexOf</code> 不支持 IE6-8.</p>\n<pre><code class=\"js\">// 多用一层循环兼容\nvar indexOf = [].indexOf ?\n  function (arr, item) {\n    return arr.indexOf(item);\n  } :\n  function (arr, item) {\n    for (var i = 0; i &lt; arr.length; i++) {\n      if (arr[i] === item) {\n        return i;\n      }\n      else {\n        return -1;\n      }\n    };\n  };\nfunction unique(arr) {\n  var isUnique = [];\n  arr.map(function (val) {\n    if (indexOf(isUnique, val) === -1) {\n      isUnique.push(val);\n    }\n  });\n  return isUnique;\n}\n</code></pre>\n<p>方法二 将原数组中重复元素的最后一个元素放入结果数组中。</p>\n<pre><code class=\"js\">function unique(arr) {\n  var res = [];\n\n  for (var i = 0; i &lt; arr.length; i++) {\n    for (var j = i + 1; j &lt; arr.length; j++) {\n      // 如果发现相同元素 则i自身进入下一个循环比较\n      if (arr[i] === arr[j]) {\n        j = ++i;\n      }\n    }\n    res.push(arr[i]);\n  }\n  return res;\n}\n</code></pre>\n<p>方法三 ES6</p>\n<pre><code class=\"js\">var unique = arr =&gt; [...new Set(arr)];\n</code></pre>\n<h3 id=\"类继承与原型继承\"><a href=\"#类继承与原型继承\" class=\"headerlink\" title=\"类继承与原型继承\"></a>类继承与原型继承</h3><p><a href=\"http://www.zcfy.cc/article/master-the-javascript-interview-what-s-the-difference-between-class-amp-prototypal-inheritance-2185.html\" target=\"_blank\" rel=\"external\">类继承与原型继承原文</a><br>es6中的<code>class</code>是建立在构造函数之上的一种封装，本质依旧是函数。</p>\n<p>类继承：使用原型链连接子类与父类的<code>Prototype</code>,形成层级划分的代理模式。会产生父—子对象分类的副作用。</p>\n<ul>\n<li>紧耦合，脆弱基类</li>\n<li>层级僵化 （新用例的出现，最终会使所有涉及到的继承层次上都出现问题）</li>\n<li>必然重复性<br>原型继承：原型是工作对象的实例，对象直接从其他对象继承属性，因此，对象实例可以由多个对象源所组成。</li>\n</ul>\n<h3 id=\"new出一个实例-原文\"><a href=\"#new出一个实例-原文\" class=\"headerlink\" title=\"new出一个实例  原文\"></a>new出一个实例  <a href=\"https://rockjins.js.org/2017/01/18/2017-01-18-new-object/\" target=\"_blank\" rel=\"external\">原文</a></h3><pre><code class=\"js\">var createObject = function () {\n  // 创建一个空对象\n  console.log(arguments);\n  var obj = new Object(),\n  // 取到构造函数，赋值给Constructor\n    Constructor = [].shift.call(arguments);\n  console.log(Constructor);\n  // 把引用的Constructor的prototype 赋值给obj原型链\n  obj.__proto__ = Constructor.prototype;\n  console.log(obj);\n  // 用apply改变this的指向，用obj代替Constructor构造函数内部的this，并把arguments作为参数传入\n  var ret = Constructor.apply(obj, arguments);\n\n  return typeof ret === &#39;object&#39; ? ret : obj;\n};\n\nfunction People(name) {\n  this.name = name;\n};\nPeople.prototype.getName = function() {\n  return this.name;\n};\n\n// 生成实例\nvar Sam = createObject(People, &#39;Sam&#39;);\nvar Lary = new People(&#39;Lary&#39;);\nconsole.log(Lary);\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>再不努力就完蛋惹。<br>","more":"</p>\n<h2 id=\"学啊学啊学\"><a href=\"#学啊学啊学\" class=\"headerlink\" title=\"学啊学啊学\"></a>学啊学啊学</h2><h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3><pre><code class=\"js\">  // 有数组\n  var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;1&#39;, 0, &#39;c&#39;, 1, &#39;&#39;, 1, 0];\n  let unique = function(){};\n  unique(arr);\n  // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;1&#39;, 0, 1, &#39;&#39;]\n</code></pre>\n<p>方法一 将原数组中的元素和结果数组中的元素一一比较。</p>\n<pre><code class=\"js\">function unique(arr){\n  let isUnique = [];\n  arr.map(val =&gt; {\n    if (isUnique.indexOf(val) === -1) {\n      isUnique.push(val);\n    }\n  })\n  return isUnique;\n}; \n// filter\nfunction unique(arr) {\n  var res = arr.filter( (item, index, array) =&gt; {\n    return array.indexOf(item) === index;   \n  })\n  return res;\n}\n</code></pre>\n<p>然而 <code>indexOf</code> 不支持 IE6-8.</p>\n<pre><code class=\"js\">// 多用一层循环兼容\nvar indexOf = [].indexOf ?\n  function (arr, item) {\n    return arr.indexOf(item);\n  } :\n  function (arr, item) {\n    for (var i = 0; i &lt; arr.length; i++) {\n      if (arr[i] === item) {\n        return i;\n      }\n      else {\n        return -1;\n      }\n    };\n  };\nfunction unique(arr) {\n  var isUnique = [];\n  arr.map(function (val) {\n    if (indexOf(isUnique, val) === -1) {\n      isUnique.push(val);\n    }\n  });\n  return isUnique;\n}\n</code></pre>\n<p>方法二 将原数组中重复元素的最后一个元素放入结果数组中。</p>\n<pre><code class=\"js\">function unique(arr) {\n  var res = [];\n\n  for (var i = 0; i &lt; arr.length; i++) {\n    for (var j = i + 1; j &lt; arr.length; j++) {\n      // 如果发现相同元素 则i自身进入下一个循环比较\n      if (arr[i] === arr[j]) {\n        j = ++i;\n      }\n    }\n    res.push(arr[i]);\n  }\n  return res;\n}\n</code></pre>\n<p>方法三 ES6</p>\n<pre><code class=\"js\">var unique = arr =&gt; [...new Set(arr)];\n</code></pre>\n<h3 id=\"类继承与原型继承\"><a href=\"#类继承与原型继承\" class=\"headerlink\" title=\"类继承与原型继承\"></a>类继承与原型继承</h3><p><a href=\"http://www.zcfy.cc/article/master-the-javascript-interview-what-s-the-difference-between-class-amp-prototypal-inheritance-2185.html\" target=\"_blank\" rel=\"external\">类继承与原型继承原文</a><br>es6中的<code>class</code>是建立在构造函数之上的一种封装，本质依旧是函数。</p>\n<p>类继承：使用原型链连接子类与父类的<code>Prototype</code>,形成层级划分的代理模式。会产生父—子对象分类的副作用。</p>\n<ul>\n<li>紧耦合，脆弱基类</li>\n<li>层级僵化 （新用例的出现，最终会使所有涉及到的继承层次上都出现问题）</li>\n<li>必然重复性<br>原型继承：原型是工作对象的实例，对象直接从其他对象继承属性，因此，对象实例可以由多个对象源所组成。</li>\n</ul>\n<h3 id=\"new出一个实例-原文\"><a href=\"#new出一个实例-原文\" class=\"headerlink\" title=\"new出一个实例  原文\"></a>new出一个实例  <a href=\"https://rockjins.js.org/2017/01/18/2017-01-18-new-object/\" target=\"_blank\" rel=\"external\">原文</a></h3><pre><code class=\"js\">var createObject = function () {\n  // 创建一个空对象\n  console.log(arguments);\n  var obj = new Object(),\n  // 取到构造函数，赋值给Constructor\n    Constructor = [].shift.call(arguments);\n  console.log(Constructor);\n  // 把引用的Constructor的prototype 赋值给obj原型链\n  obj.__proto__ = Constructor.prototype;\n  console.log(obj);\n  // 用apply改变this的指向，用obj代替Constructor构造函数内部的this，并把arguments作为参数传入\n  var ret = Constructor.apply(obj, arguments);\n\n  return typeof ret === &#39;object&#39; ? ret : obj;\n};\n\nfunction People(name) {\n  this.name = name;\n};\nPeople.prototype.getName = function() {\n  return this.name;\n};\n\n// 生成实例\nvar Sam = createObject(People, &#39;Sam&#39;);\nvar Lary = new People(&#39;Lary&#39;);\nconsole.log(Lary);\n</code></pre>"},{"title":"基于websocket实现服务器浏览器持续通信","date":"2016-12-10T13:14:18.000Z","_content":"\n为了网络程序设计大作业，了解了http,websocket,node及其框架...\n<!--more-->\n\n### http协议\n  * HTTP是超文本传输协议，是客户端浏览器或其他程序与Web服务器之间的应用层通信协议\n * HTTP使用TCP/IP建立连接\n![](http://upload-images.jianshu.io/upload_images/3767061-36776499e489d972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/3767061-25b34aab5fc17bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n * TCP客户端和服务器通过TCP套接字接口通信\n\n![](http://upload-images.jianshu.io/upload_images/3767061-ff829f1fafae57a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### Websocket\n - Websocket是一个持久化的协议\n  http1.0的生命周期很短，一个request一个response完成后就结束\n http1.1增加了一个keep-alive，在一个http连接中可以发送多个request，接收多个response\n\n![](http://upload-images.jianshu.io/upload_images/3767061-b512a13ed3c4cd9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/3767061-92194c7aa3f952d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这是一个 websocket的request和 response\n\n - websocket解决了http的部分难题\n  * **被动性** 服务端可以主动推送信息给客户端，不需要客户端不断请求\n  * **持久性** 只需要一次握手，整个通信建立在一次连接中，避免了中介反复解析\n\n### 基于express和socket.io构建聊天室\n\n - express\n  安装\n  ```\n npm install express -g\n```\nserver.js引用模块\n```\nvar express = require('express'),\napp = express(),\nserver = require('http').createServer(app);  //创建服务\napp.use('/', express.static(__dirname + '/www')); //调用静态文件\n```\n\n- socket.IO\n  可以接受所有与服务器相连接的客户端发送的消息，也可向客户端主动发送消息。\n  安装\n```\n npm install socket.io\n```\n引用\n```\nvar io = require('socket.io').listen(server);\nserver.listen(process.env.PORT || 3000);  //监听端口\n```\n\n- connect\n```\nio.sockets.on('connection', function(socket) {   //建立连接\n    //新用户\n    socket.on('login', function(usrName,user) {\n        if (users.indexOf(usrName) > -1) {\n            socket.emit('usrExisted');\n        } else {\n            socket.userIndex = users.length;\n            socket.usrName = usrName;\n            socket.users = users;\n            users.push(usrName);\n            date = new Date().toTimeString().substr(0, 8);\n            console.log(date+\"/\"+usrName+'加入了聊天');\n            socket.emit('loginSuccess');\n            io.sockets.emit('system', usrName, users.length, 'login');\n            io.sockets.emit('cuList', users);\n        };\n    });\n    //用户离开\n    socket.on('disconnect', function(user) {\n        if (socket.usrName != null) {\n        \tsocket.users = users;\n            users.splice(socket.userIndex, 1);\n            date = new Date().toTimeString().substr(0, 8);\n            console.log(date+\"/\"+socket.usrName+'滚蛋了');\n            socket.broadcast.emit('system', socket.usrName, users.length, 'logout');\n\t\t\tio.sockets.emit('cuList', users);\n        }\n    });\n    //用户列表\n\t//新消息\n    socket.on('postMsg', function(msg, color) {\n    \tdate = new Date().toTimeString().substr(0, 8);\n    \tconsole.log(date+\"/\"+socket.usrName+'：'+msg);\n        socket.broadcast.emit('newMsg', socket.usrName, msg, color);\n    });\n    //新图片\n    socket.on('img', function(imgData, color) {\n    \tdate = new Date().toTimeString().substr(0, 8);\n    \tconsole.log(date+\"/\"+socket.usrName+'：'+imgData);\n        socket.broadcast.emit('newImg', socket.usrName, imgData, color);\n    });\n});\n```\n- 客户端js,html,css\n```\nwindow.onload = function() {\n    var webchat = new WebChat();\n    webchat.init();\n};\nvar WebChat = function() {\n    this.socket = null;\n};\nWebChat.prototype = {\n    init: function() {\n        var that = this;\n        this.socket = io.connect();\n        //建立连接\n        this.socket.on('connect', function() {\n        \t$('#info').text('大爷儿，进来玩玩');\n        \t$('#inModal').css('display','block');\n        \t$('#usrName').focus();\n        });\n        //昵称占用\n        this.socket.on('usrExisted', function() {\n            $('#info').text('昵称已被使用，请换一个试试！');\n        });\n        //登陆成功\n        this.socket.on('loginSuccess', function() {\n        \tdocument.title ='webchat | ' + $('#usrName').val();\n        \t$('#loginArea').css('display','none');\n        \t$('#messageInput').focus();\n        });\n        //用户列表\n        this.socket.on('cuList',function(users){\n        \tvar cuList = $('#right');\n        \tvar addStr = \"\";\n        \tconsole.log(users);\n        \tusers.forEach(function(user){\n        \t\taddStr += user + '<br/>';\n        \t});\n        \tcuList.html('用户列表<br/>'+addStr);\n        })\n        //连接失败\n        this.socket.on('error', function(err) {\n            if ($('#loginArea').style.display == 'none') {\n                $('#onlineCount').text('连接失败！');\n            } else {\n                $('#info').text('连接失败！');\n            }\n        });\n        //系统通知用户加入或离开\n        this.socket.on('system', function(usrName, userCount, type) {\n            var msg = usrName + (type == 'login' ? '来了' : '滚了');\n            that._displayNewMsg('system ', msg, 'red');\n            $('#onlineCount').text(userCount + (userCount > 1 ? ' users' : ' user') + ' online');\n        });\n        //发送消息\n        this.socket.on('newMsg', function(user, msg, color) {\n            that._displayNewMsg(user, msg, color);\n        });\n        //发送图片\n        this.socket.on('newImg', function(user, img, color) {\n            that._displayImage(user, img, color);\n        });\n        \n        //底层监听事件\n        \n        //登陆按钮\n        $('#loginBtn').on('click tap', function() {\n            var usrName = $('#usrName').val();\n            if ($.trim(usrName).length != 0) {\n                that.socket.emit('login', usrName);\n                that.socket.emit('cuList', users);\n            } else {\n                $('#usrName').focus();\n            };\n        });\n        //登陆监听enter\n        $('#usrName').on('keyup', function(e) {\n            if (e.keyCode == 13) {\n                var usrName = $('#usrName').val();\n                if ($.trim(usrName).length != 0) {\n                    that.socket.emit('login', usrName);\n                    that.socket.emit('cuList', users);\n                };\n            };\n        });\n        //bind发送按钮\n        $('#sendBtn').on('click tap', function() {\n            var messageInput = $('#messageInput'),\n                msg = messageInput.val(),\n                color = $('#colorStyle').val();\n            messageInput.val(' ');\n            messageInput.focus();\n            if ($.trim(msg).length != 0) {\n                that.socket.emit('postMsg', msg, color);\n                that._displayNewMsg('me', msg, color);\n                return;\n            };\n        });\n        //bind发送\n        $('#messageInput').on('keyup', function(e) {\n            var messageInput = $('#messageInput'),\n                msg = messageInput.val(),\n                color = $('#colorStyle').val();\n            if (e.keyCode == 13 && $.trim(msg).length != 0) {\n                messageInput.val(' ');\n                that.socket.emit('postMsg', msg, color);\n                that._displayNewMsg('me', msg, color);\n            };\n        });\n        //清空\n        $('#clearBtn').on('click tap', function() {\n            $('#winChat').html(\" \");\n        });\n        //发送图片\n        $('#imgSend').on('change', function() {\n            if (this.files.length != 0) {\n                var file = this.files[0],\n                    reader = new FileReader(),\n                    color = $('#colorStyle').val();\n                if (!reader) {\n                    that._displayNewMsg('system', '辣鸡浏览器不支持上传文件', 'red');\n                    this.val(' ');\n                    return;\n                };\n                //接收图片\n                reader.onload = function(e) {\n                    that.socket.emit('img', e.target.result, color);\n                    that._displayImage('me', e.target.result, color);\n                };\n                reader.readAsDataURL(file);\n            };\n        });\n        //图片包\n        this._initialLxh();\n        //按钮\n        $('#lxh').on('click tap', function(e) {\n            var lxhwrapper = $('#lxhWrapper');\n            lxhwrapper.css('display','block');\n            e.stopPropagation();\n        });\n        //二级图片栏\n        $('body').on('click', function(e) {\n            var lxhwrapper = $('#lxhWrapper');\n            if (e.target != lxhwrapper) {\n                lxhwrapper.css('display','none');\n            };\n        });\n        $('#lxhWrapper').on('click tap', function(e) {\n            var target = e.target;\n            if (target.nodeName.toLowerCase() == 'img') {\n                var messageInput = $('#messageInput');\n                messageInput.focus();\n                messageInput.val(messageInput.val() + '[lxh:' + target.title + ']');\n            };\n        });\n    },\n    \t//发送图片\n    _initialLxh: function() {\n        var lxhContainer = $('#lxhWrapper'),\n            docFragment = document.createDocumentFragment();\n        for (var i = 100; i > 0; i--) {\n            var lxhItem = document.createElement('img');\n            lxhItem.src = '../content/lxh/' + i + '.gif';\n            lxhItem.title = i;\n            docFragment.appendChild(lxhItem);\n        };\n        lxhContainer.append(docFragment);\n    },\n    _displayNewMsg: function(user, msg, color) {\n        var container = $('#winChat'),\n            msgToDisplay = $('<p></p>'),\n            date = new Date().toTimeString().substr(0, 8),\n            msg = this._showLxh(msg);\n        msgToDisplay.css('color',color || '#000');\n        msgToDisplay.html(user + '<span class=\"timespan\">(' + date + '): </span>' + msg);\n        container.append(msgToDisplay);\n        container.scrollTop = container.scrollHeight;\n    },\n    _displayImage: function(user, imgData, color) {\n        var container = $('#winChat'),\n            msgToDisplay = $('<p></p>'),\n            date = new Date().toTimeString().substr(0, 8);\n        msgToDisplay.css('color',color || '#000');\n        msgToDisplay.html(user + '<span class=\"timespan\">(' + date + '): </span> <br/>' + '<a href=\"' + imgData + '\" target=\"_blank\"><img src=\"' + imgData + '\"/></a>');\n        container.append(msgToDisplay);\n        container.scrollTop = container.scrollHeight;\n    },\n    _showLxh: function(msg) {\n        var match, \n        \tresult = msg,\n            reg = /\\[lxh:\\d+\\]/g,\n            lxhIndex,\n            totalLxhNum = $('#lxhWrapper').children().length;\n        while (match = reg.exec(msg)) {\n            lxhIndex = match[0].slice(5, -1);\n            console.log(lxhIndex);\n            if (lxhIndex > totalLxhNum) {\n                result = result.replace(match[0], '[X]');\n            } else {\n                result = result.replace(match[0], '<img class=\"lxh\" src=\"../content/lxh/' + lxhIndex + '.gif\" />');\n            };\n        };\n        return result;\n    }\n};\n```\n```\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n        <meta name=\"description\" content=\"webchat | a simple chat application built with node.js and websocket\">\n        <meta name=\"viewport\"content=\"width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"/>    \n       <title>webchat</title>\n        <link rel=\"stylesheet\" href=\"styles/main.css\">\n        <link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\">\n        <link rel=\"icon\" href=\"favicon.ico\" type=\"image/x-icon\">\n    </head>\n    <body>\n        <div class=\"wrapper\">\n            <div class=\"banner\">\n                <div>WebChat</div>\n                <span id=\"onlineCount\"></span>\n            </div>\n            <div id=\"winChat\">\n            </div>\n            <div class=\"controls\" >\n                <div class=\"items\">\n                    <input id=\"colorStyle\" type=\"color\" placeHolder='#000' title=\"font color\" />\n                    <input id=\"lxh\" type=\"button\" value=\"lxh\" title=\"lxh\" />\n                    <label for=\"imgSend\" class=\"imgLabel\">\n                        <input type=\"button\" value=\"表情\" style=\"width: 60px;height: 30px;border: 0;margin: 0;padding: 0;\" />\n                        <input id=\"imgSend\" type=\"file\" accept=\"image/gif\" value=\"表情\"  />\n                    </label>\n                    <input id=\"clearBtn\" type=\"button\" value=\"清空\" title=\"clear screen\" />\n                </div>\n                <input type=\"text\" id=\"messageInput\" placeHolder=\"enter to send\"/>\n                <input id=\"sendBtn\" type=\"button\" value=\"发送\">\n                <div id=\"lxhWrapper\">\n                </div>\n            </div>\n        </div>\n        <div class=\"right\" id=\"right\"></div>\n        <div id=\"loginArea\">\n            <p id=\"info\">正在连接服务器...</p>\n            <div id=\"inModal\">\n                <input type=\"text\" placeHolder=\"请输入昵称\" id=\"usrName\" />\n                <input type=\"button\" value=\"进入\" id=\"loginBtn\" />\n            </div>\n        </div>\n        <script src=\"scripts/jquery-2.1.0.js\"></script>\n        <script src=\"/socket.io/socket.io.js\"></script>\n        <script src=\"scripts/webchat.js\"></script>\n    </body>\n</html>\n```\n\n```\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n        <meta name=\"description\" content=\"webchat | a simple chat application built with node.js and websocket\">\n        <meta name=\"viewport\"content=\"width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"/>    \n       <title>webchat</title>\n        <link rel=\"stylesheet\" href=\"styles/main.css\">\n        <link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\">\n        <link rel=\"icon\" href=\"favicon.ico\" type=\"image/x-icon\">\n    </head>\n    <body>\n        <div class=\"wrapper\">\n            <div class=\"banner\">\n                <div>WebChat</div>\n                <span id=\"onlineCount\"></span>\n            </div>\n            <div id=\"winChat\">\n            </div>\n            <div class=\"controls\" >\n                <div class=\"items\">\n                    <input id=\"colorStyle\" type=\"color\" placeHolder='#000' title=\"font color\" />\n                    <input id=\"lxh\" type=\"button\" value=\"lxh\" title=\"lxh\" />\n                    <label for=\"imgSend\" class=\"imgLabel\">\n                        <input type=\"button\" value=\"表情\" style=\"width: 60px;height: 30px;border: 0;margin: 0;padding: 0;\" />\n                        <input id=\"imgSend\" type=\"file\" accept=\"image/gif\" value=\"表情\"  />\n                    </label>\n                    <input id=\"clearBtn\" type=\"button\" value=\"清空\" title=\"clear screen\" />\n                </div>\n                <input type=\"text\" id=\"messageInput\" placeHolder=\"enter to send\"/>\n                <input id=\"sendBtn\" type=\"button\" value=\"发送\">\n                <div id=\"lxhWrapper\">\n                </div>\n            </div>\n        </div>\n        <div class=\"right\" id=\"right\"></div>\n        <div id=\"loginArea\">\n            <p id=\"info\">正在连接服务器...</p>\n            <div id=\"inModal\">\n                <input type=\"text\" placeHolder=\"请输入昵称\" id=\"usrName\" />\n                <input type=\"button\" value=\"进入\" id=\"loginBtn\" />\n            </div>\n        </div>\n        <script src=\"scripts/jquery-2.1.0.js\"></script>\n        <script src=\"/socket.io/socket.io.js\"></script>\n        <script src=\"scripts/webchat.js\"></script>\n    </body>\n</html>\n```","source":"_posts/基于websocket实现服务器浏览器持续通信.md","raw":"---\ntitle: 基于websocket实现服务器浏览器持续通信\ndate: 2016-12-10 21:14:18\ntags:\n  - node\n  - javascript\n---\n\n为了网络程序设计大作业，了解了http,websocket,node及其框架...\n<!--more-->\n\n### http协议\n  * HTTP是超文本传输协议，是客户端浏览器或其他程序与Web服务器之间的应用层通信协议\n * HTTP使用TCP/IP建立连接\n![](http://upload-images.jianshu.io/upload_images/3767061-36776499e489d972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/3767061-25b34aab5fc17bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n * TCP客户端和服务器通过TCP套接字接口通信\n\n![](http://upload-images.jianshu.io/upload_images/3767061-ff829f1fafae57a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### Websocket\n - Websocket是一个持久化的协议\n  http1.0的生命周期很短，一个request一个response完成后就结束\n http1.1增加了一个keep-alive，在一个http连接中可以发送多个request，接收多个response\n\n![](http://upload-images.jianshu.io/upload_images/3767061-b512a13ed3c4cd9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/3767061-92194c7aa3f952d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n这是一个 websocket的request和 response\n\n - websocket解决了http的部分难题\n  * **被动性** 服务端可以主动推送信息给客户端，不需要客户端不断请求\n  * **持久性** 只需要一次握手，整个通信建立在一次连接中，避免了中介反复解析\n\n### 基于express和socket.io构建聊天室\n\n - express\n  安装\n  ```\n npm install express -g\n```\nserver.js引用模块\n```\nvar express = require('express'),\napp = express(),\nserver = require('http').createServer(app);  //创建服务\napp.use('/', express.static(__dirname + '/www')); //调用静态文件\n```\n\n- socket.IO\n  可以接受所有与服务器相连接的客户端发送的消息，也可向客户端主动发送消息。\n  安装\n```\n npm install socket.io\n```\n引用\n```\nvar io = require('socket.io').listen(server);\nserver.listen(process.env.PORT || 3000);  //监听端口\n```\n\n- connect\n```\nio.sockets.on('connection', function(socket) {   //建立连接\n    //新用户\n    socket.on('login', function(usrName,user) {\n        if (users.indexOf(usrName) > -1) {\n            socket.emit('usrExisted');\n        } else {\n            socket.userIndex = users.length;\n            socket.usrName = usrName;\n            socket.users = users;\n            users.push(usrName);\n            date = new Date().toTimeString().substr(0, 8);\n            console.log(date+\"/\"+usrName+'加入了聊天');\n            socket.emit('loginSuccess');\n            io.sockets.emit('system', usrName, users.length, 'login');\n            io.sockets.emit('cuList', users);\n        };\n    });\n    //用户离开\n    socket.on('disconnect', function(user) {\n        if (socket.usrName != null) {\n        \tsocket.users = users;\n            users.splice(socket.userIndex, 1);\n            date = new Date().toTimeString().substr(0, 8);\n            console.log(date+\"/\"+socket.usrName+'滚蛋了');\n            socket.broadcast.emit('system', socket.usrName, users.length, 'logout');\n\t\t\tio.sockets.emit('cuList', users);\n        }\n    });\n    //用户列表\n\t//新消息\n    socket.on('postMsg', function(msg, color) {\n    \tdate = new Date().toTimeString().substr(0, 8);\n    \tconsole.log(date+\"/\"+socket.usrName+'：'+msg);\n        socket.broadcast.emit('newMsg', socket.usrName, msg, color);\n    });\n    //新图片\n    socket.on('img', function(imgData, color) {\n    \tdate = new Date().toTimeString().substr(0, 8);\n    \tconsole.log(date+\"/\"+socket.usrName+'：'+imgData);\n        socket.broadcast.emit('newImg', socket.usrName, imgData, color);\n    });\n});\n```\n- 客户端js,html,css\n```\nwindow.onload = function() {\n    var webchat = new WebChat();\n    webchat.init();\n};\nvar WebChat = function() {\n    this.socket = null;\n};\nWebChat.prototype = {\n    init: function() {\n        var that = this;\n        this.socket = io.connect();\n        //建立连接\n        this.socket.on('connect', function() {\n        \t$('#info').text('大爷儿，进来玩玩');\n        \t$('#inModal').css('display','block');\n        \t$('#usrName').focus();\n        });\n        //昵称占用\n        this.socket.on('usrExisted', function() {\n            $('#info').text('昵称已被使用，请换一个试试！');\n        });\n        //登陆成功\n        this.socket.on('loginSuccess', function() {\n        \tdocument.title ='webchat | ' + $('#usrName').val();\n        \t$('#loginArea').css('display','none');\n        \t$('#messageInput').focus();\n        });\n        //用户列表\n        this.socket.on('cuList',function(users){\n        \tvar cuList = $('#right');\n        \tvar addStr = \"\";\n        \tconsole.log(users);\n        \tusers.forEach(function(user){\n        \t\taddStr += user + '<br/>';\n        \t});\n        \tcuList.html('用户列表<br/>'+addStr);\n        })\n        //连接失败\n        this.socket.on('error', function(err) {\n            if ($('#loginArea').style.display == 'none') {\n                $('#onlineCount').text('连接失败！');\n            } else {\n                $('#info').text('连接失败！');\n            }\n        });\n        //系统通知用户加入或离开\n        this.socket.on('system', function(usrName, userCount, type) {\n            var msg = usrName + (type == 'login' ? '来了' : '滚了');\n            that._displayNewMsg('system ', msg, 'red');\n            $('#onlineCount').text(userCount + (userCount > 1 ? ' users' : ' user') + ' online');\n        });\n        //发送消息\n        this.socket.on('newMsg', function(user, msg, color) {\n            that._displayNewMsg(user, msg, color);\n        });\n        //发送图片\n        this.socket.on('newImg', function(user, img, color) {\n            that._displayImage(user, img, color);\n        });\n        \n        //底层监听事件\n        \n        //登陆按钮\n        $('#loginBtn').on('click tap', function() {\n            var usrName = $('#usrName').val();\n            if ($.trim(usrName).length != 0) {\n                that.socket.emit('login', usrName);\n                that.socket.emit('cuList', users);\n            } else {\n                $('#usrName').focus();\n            };\n        });\n        //登陆监听enter\n        $('#usrName').on('keyup', function(e) {\n            if (e.keyCode == 13) {\n                var usrName = $('#usrName').val();\n                if ($.trim(usrName).length != 0) {\n                    that.socket.emit('login', usrName);\n                    that.socket.emit('cuList', users);\n                };\n            };\n        });\n        //bind发送按钮\n        $('#sendBtn').on('click tap', function() {\n            var messageInput = $('#messageInput'),\n                msg = messageInput.val(),\n                color = $('#colorStyle').val();\n            messageInput.val(' ');\n            messageInput.focus();\n            if ($.trim(msg).length != 0) {\n                that.socket.emit('postMsg', msg, color);\n                that._displayNewMsg('me', msg, color);\n                return;\n            };\n        });\n        //bind发送\n        $('#messageInput').on('keyup', function(e) {\n            var messageInput = $('#messageInput'),\n                msg = messageInput.val(),\n                color = $('#colorStyle').val();\n            if (e.keyCode == 13 && $.trim(msg).length != 0) {\n                messageInput.val(' ');\n                that.socket.emit('postMsg', msg, color);\n                that._displayNewMsg('me', msg, color);\n            };\n        });\n        //清空\n        $('#clearBtn').on('click tap', function() {\n            $('#winChat').html(\" \");\n        });\n        //发送图片\n        $('#imgSend').on('change', function() {\n            if (this.files.length != 0) {\n                var file = this.files[0],\n                    reader = new FileReader(),\n                    color = $('#colorStyle').val();\n                if (!reader) {\n                    that._displayNewMsg('system', '辣鸡浏览器不支持上传文件', 'red');\n                    this.val(' ');\n                    return;\n                };\n                //接收图片\n                reader.onload = function(e) {\n                    that.socket.emit('img', e.target.result, color);\n                    that._displayImage('me', e.target.result, color);\n                };\n                reader.readAsDataURL(file);\n            };\n        });\n        //图片包\n        this._initialLxh();\n        //按钮\n        $('#lxh').on('click tap', function(e) {\n            var lxhwrapper = $('#lxhWrapper');\n            lxhwrapper.css('display','block');\n            e.stopPropagation();\n        });\n        //二级图片栏\n        $('body').on('click', function(e) {\n            var lxhwrapper = $('#lxhWrapper');\n            if (e.target != lxhwrapper) {\n                lxhwrapper.css('display','none');\n            };\n        });\n        $('#lxhWrapper').on('click tap', function(e) {\n            var target = e.target;\n            if (target.nodeName.toLowerCase() == 'img') {\n                var messageInput = $('#messageInput');\n                messageInput.focus();\n                messageInput.val(messageInput.val() + '[lxh:' + target.title + ']');\n            };\n        });\n    },\n    \t//发送图片\n    _initialLxh: function() {\n        var lxhContainer = $('#lxhWrapper'),\n            docFragment = document.createDocumentFragment();\n        for (var i = 100; i > 0; i--) {\n            var lxhItem = document.createElement('img');\n            lxhItem.src = '../content/lxh/' + i + '.gif';\n            lxhItem.title = i;\n            docFragment.appendChild(lxhItem);\n        };\n        lxhContainer.append(docFragment);\n    },\n    _displayNewMsg: function(user, msg, color) {\n        var container = $('#winChat'),\n            msgToDisplay = $('<p></p>'),\n            date = new Date().toTimeString().substr(0, 8),\n            msg = this._showLxh(msg);\n        msgToDisplay.css('color',color || '#000');\n        msgToDisplay.html(user + '<span class=\"timespan\">(' + date + '): </span>' + msg);\n        container.append(msgToDisplay);\n        container.scrollTop = container.scrollHeight;\n    },\n    _displayImage: function(user, imgData, color) {\n        var container = $('#winChat'),\n            msgToDisplay = $('<p></p>'),\n            date = new Date().toTimeString().substr(0, 8);\n        msgToDisplay.css('color',color || '#000');\n        msgToDisplay.html(user + '<span class=\"timespan\">(' + date + '): </span> <br/>' + '<a href=\"' + imgData + '\" target=\"_blank\"><img src=\"' + imgData + '\"/></a>');\n        container.append(msgToDisplay);\n        container.scrollTop = container.scrollHeight;\n    },\n    _showLxh: function(msg) {\n        var match, \n        \tresult = msg,\n            reg = /\\[lxh:\\d+\\]/g,\n            lxhIndex,\n            totalLxhNum = $('#lxhWrapper').children().length;\n        while (match = reg.exec(msg)) {\n            lxhIndex = match[0].slice(5, -1);\n            console.log(lxhIndex);\n            if (lxhIndex > totalLxhNum) {\n                result = result.replace(match[0], '[X]');\n            } else {\n                result = result.replace(match[0], '<img class=\"lxh\" src=\"../content/lxh/' + lxhIndex + '.gif\" />');\n            };\n        };\n        return result;\n    }\n};\n```\n```\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n        <meta name=\"description\" content=\"webchat | a simple chat application built with node.js and websocket\">\n        <meta name=\"viewport\"content=\"width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"/>    \n       <title>webchat</title>\n        <link rel=\"stylesheet\" href=\"styles/main.css\">\n        <link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\">\n        <link rel=\"icon\" href=\"favicon.ico\" type=\"image/x-icon\">\n    </head>\n    <body>\n        <div class=\"wrapper\">\n            <div class=\"banner\">\n                <div>WebChat</div>\n                <span id=\"onlineCount\"></span>\n            </div>\n            <div id=\"winChat\">\n            </div>\n            <div class=\"controls\" >\n                <div class=\"items\">\n                    <input id=\"colorStyle\" type=\"color\" placeHolder='#000' title=\"font color\" />\n                    <input id=\"lxh\" type=\"button\" value=\"lxh\" title=\"lxh\" />\n                    <label for=\"imgSend\" class=\"imgLabel\">\n                        <input type=\"button\" value=\"表情\" style=\"width: 60px;height: 30px;border: 0;margin: 0;padding: 0;\" />\n                        <input id=\"imgSend\" type=\"file\" accept=\"image/gif\" value=\"表情\"  />\n                    </label>\n                    <input id=\"clearBtn\" type=\"button\" value=\"清空\" title=\"clear screen\" />\n                </div>\n                <input type=\"text\" id=\"messageInput\" placeHolder=\"enter to send\"/>\n                <input id=\"sendBtn\" type=\"button\" value=\"发送\">\n                <div id=\"lxhWrapper\">\n                </div>\n            </div>\n        </div>\n        <div class=\"right\" id=\"right\"></div>\n        <div id=\"loginArea\">\n            <p id=\"info\">正在连接服务器...</p>\n            <div id=\"inModal\">\n                <input type=\"text\" placeHolder=\"请输入昵称\" id=\"usrName\" />\n                <input type=\"button\" value=\"进入\" id=\"loginBtn\" />\n            </div>\n        </div>\n        <script src=\"scripts/jquery-2.1.0.js\"></script>\n        <script src=\"/socket.io/socket.io.js\"></script>\n        <script src=\"scripts/webchat.js\"></script>\n    </body>\n</html>\n```\n\n```\n<!doctype html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n        <meta name=\"description\" content=\"webchat | a simple chat application built with node.js and websocket\">\n        <meta name=\"viewport\"content=\"width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"/>    \n       <title>webchat</title>\n        <link rel=\"stylesheet\" href=\"styles/main.css\">\n        <link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\">\n        <link rel=\"icon\" href=\"favicon.ico\" type=\"image/x-icon\">\n    </head>\n    <body>\n        <div class=\"wrapper\">\n            <div class=\"banner\">\n                <div>WebChat</div>\n                <span id=\"onlineCount\"></span>\n            </div>\n            <div id=\"winChat\">\n            </div>\n            <div class=\"controls\" >\n                <div class=\"items\">\n                    <input id=\"colorStyle\" type=\"color\" placeHolder='#000' title=\"font color\" />\n                    <input id=\"lxh\" type=\"button\" value=\"lxh\" title=\"lxh\" />\n                    <label for=\"imgSend\" class=\"imgLabel\">\n                        <input type=\"button\" value=\"表情\" style=\"width: 60px;height: 30px;border: 0;margin: 0;padding: 0;\" />\n                        <input id=\"imgSend\" type=\"file\" accept=\"image/gif\" value=\"表情\"  />\n                    </label>\n                    <input id=\"clearBtn\" type=\"button\" value=\"清空\" title=\"clear screen\" />\n                </div>\n                <input type=\"text\" id=\"messageInput\" placeHolder=\"enter to send\"/>\n                <input id=\"sendBtn\" type=\"button\" value=\"发送\">\n                <div id=\"lxhWrapper\">\n                </div>\n            </div>\n        </div>\n        <div class=\"right\" id=\"right\"></div>\n        <div id=\"loginArea\">\n            <p id=\"info\">正在连接服务器...</p>\n            <div id=\"inModal\">\n                <input type=\"text\" placeHolder=\"请输入昵称\" id=\"usrName\" />\n                <input type=\"button\" value=\"进入\" id=\"loginBtn\" />\n            </div>\n        </div>\n        <script src=\"scripts/jquery-2.1.0.js\"></script>\n        <script src=\"/socket.io/socket.io.js\"></script>\n        <script src=\"scripts/webchat.js\"></script>\n    </body>\n</html>\n```","slug":"基于websocket实现服务器浏览器持续通信","published":1,"updated":"2016-12-19T13:31:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl300010ttwp23frxsuk","content":"<p>为了网络程序设计大作业，了解了http,websocket,node及其框架…<br><a id=\"more\"></a></p>\n<h3 id=\"http协议\"><a href=\"#http协议\" class=\"headerlink\" title=\"http协议\"></a>http协议</h3><ul>\n<li>HTTP是超文本传输协议，是客户端浏览器或其他程序与Web服务器之间的应用层通信协议<ul>\n<li>HTTP使用TCP/IP建立连接<br><img src=\"http://upload-images.jianshu.io/upload_images/3767061-36776499e489d972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3767061-25b34aab5fc17bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<ul>\n<li>TCP客户端和服务器通过TCP套接字接口通信</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3767061-ff829f1fafae57a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"Websocket\"><a href=\"#Websocket\" class=\"headerlink\" title=\"Websocket\"></a>Websocket</h3><ul>\n<li>Websocket是一个持久化的协议<br>http1.0的生命周期很短，一个request一个response完成后就结束<br>http1.1增加了一个keep-alive，在一个http连接中可以发送多个request，接收多个response</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3767061-b512a13ed3c4cd9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3767061-92194c7aa3f952d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>这是一个 websocket的request和 response</p>\n<ul>\n<li>websocket解决了http的部分难题<ul>\n<li><strong>被动性</strong> 服务端可以主动推送信息给客户端，不需要客户端不断请求</li>\n<li><strong>持久性</strong> 只需要一次握手，整个通信建立在一次连接中，避免了中介反复解析</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基于express和socket-io构建聊天室\"><a href=\"#基于express和socket-io构建聊天室\" class=\"headerlink\" title=\"基于express和socket.io构建聊天室\"></a>基于express和socket.io构建聊天室</h3><ul>\n<li>express<br>安装<pre><code>npm install express -g\n</code></pre>server.js引用模块<pre><code>var express = require(&#39;express&#39;),\napp = express(),\nserver = require(&#39;http&#39;).createServer(app);  //创建服务\napp.use(&#39;/&#39;, express.static(__dirname + &#39;/www&#39;)); //调用静态文件\n</code></pre></li>\n</ul>\n<ul>\n<li><p>socket.IO<br>可以接受所有与服务器相连接的客户端发送的消息，也可向客户端主动发送消息。<br>安装</p>\n<pre><code>npm install socket.io\n</code></pre><p>引用</p>\n<pre><code>var io = require(&#39;socket.io&#39;).listen(server);\nserver.listen(process.env.PORT || 3000);  //监听端口\n</code></pre></li>\n<li><p>connect</p>\n<pre><code>io.sockets.on(&#39;connection&#39;, function(socket) {   //建立连接\n  //新用户\n  socket.on(&#39;login&#39;, function(usrName,user) {\n      if (users.indexOf(usrName) &gt; -1) {\n          socket.emit(&#39;usrExisted&#39;);\n      } else {\n          socket.userIndex = users.length;\n          socket.usrName = usrName;\n          socket.users = users;\n          users.push(usrName);\n          date = new Date().toTimeString().substr(0, 8);\n          console.log(date+&quot;/&quot;+usrName+&#39;加入了聊天&#39;);\n          socket.emit(&#39;loginSuccess&#39;);\n          io.sockets.emit(&#39;system&#39;, usrName, users.length, &#39;login&#39;);\n          io.sockets.emit(&#39;cuList&#39;, users);\n      };\n  });\n  //用户离开\n  socket.on(&#39;disconnect&#39;, function(user) {\n      if (socket.usrName != null) {\n          socket.users = users;\n          users.splice(socket.userIndex, 1);\n          date = new Date().toTimeString().substr(0, 8);\n          console.log(date+&quot;/&quot;+socket.usrName+&#39;滚蛋了&#39;);\n          socket.broadcast.emit(&#39;system&#39;, socket.usrName, users.length, &#39;logout&#39;);\n          io.sockets.emit(&#39;cuList&#39;, users);\n      }\n  });\n  //用户列表\n  //新消息\n  socket.on(&#39;postMsg&#39;, function(msg, color) {\n      date = new Date().toTimeString().substr(0, 8);\n      console.log(date+&quot;/&quot;+socket.usrName+&#39;：&#39;+msg);\n      socket.broadcast.emit(&#39;newMsg&#39;, socket.usrName, msg, color);\n  });\n  //新图片\n  socket.on(&#39;img&#39;, function(imgData, color) {\n      date = new Date().toTimeString().substr(0, 8);\n      console.log(date+&quot;/&quot;+socket.usrName+&#39;：&#39;+imgData);\n      socket.broadcast.emit(&#39;newImg&#39;, socket.usrName, imgData, color);\n  });\n});\n</code></pre></li>\n<li><p>客户端js,html,css</p>\n<pre><code>window.onload = function() {\n  var webchat = new WebChat();\n  webchat.init();\n};\nvar WebChat = function() {\n  this.socket = null;\n};\nWebChat.prototype = {\n  init: function() {\n      var that = this;\n      this.socket = io.connect();\n      //建立连接\n      this.socket.on(&#39;connect&#39;, function() {\n          $(&#39;#info&#39;).text(&#39;大爷儿，进来玩玩&#39;);\n          $(&#39;#inModal&#39;).css(&#39;display&#39;,&#39;block&#39;);\n          $(&#39;#usrName&#39;).focus();\n      });\n      //昵称占用\n      this.socket.on(&#39;usrExisted&#39;, function() {\n          $(&#39;#info&#39;).text(&#39;昵称已被使用，请换一个试试！&#39;);\n      });\n      //登陆成功\n      this.socket.on(&#39;loginSuccess&#39;, function() {\n          document.title =&#39;webchat | &#39; + $(&#39;#usrName&#39;).val();\n          $(&#39;#loginArea&#39;).css(&#39;display&#39;,&#39;none&#39;);\n          $(&#39;#messageInput&#39;).focus();\n      });\n      //用户列表\n      this.socket.on(&#39;cuList&#39;,function(users){\n          var cuList = $(&#39;#right&#39;);\n          var addStr = &quot;&quot;;\n          console.log(users);\n          users.forEach(function(user){\n              addStr += user + &#39;&lt;br/&gt;&#39;;\n          });\n          cuList.html(&#39;用户列表&lt;br/&gt;&#39;+addStr);\n      })\n      //连接失败\n      this.socket.on(&#39;error&#39;, function(err) {\n          if ($(&#39;#loginArea&#39;).style.display == &#39;none&#39;) {\n              $(&#39;#onlineCount&#39;).text(&#39;连接失败！&#39;);\n          } else {\n              $(&#39;#info&#39;).text(&#39;连接失败！&#39;);\n          }\n      });\n      //系统通知用户加入或离开\n      this.socket.on(&#39;system&#39;, function(usrName, userCount, type) {\n          var msg = usrName + (type == &#39;login&#39; ? &#39;来了&#39; : &#39;滚了&#39;);\n          that._displayNewMsg(&#39;system &#39;, msg, &#39;red&#39;);\n          $(&#39;#onlineCount&#39;).text(userCount + (userCount &gt; 1 ? &#39; users&#39; : &#39; user&#39;) + &#39; online&#39;);\n      });\n      //发送消息\n      this.socket.on(&#39;newMsg&#39;, function(user, msg, color) {\n          that._displayNewMsg(user, msg, color);\n      });\n      //发送图片\n      this.socket.on(&#39;newImg&#39;, function(user, img, color) {\n          that._displayImage(user, img, color);\n      });\n\n      //底层监听事件\n\n      //登陆按钮\n      $(&#39;#loginBtn&#39;).on(&#39;click tap&#39;, function() {\n          var usrName = $(&#39;#usrName&#39;).val();\n          if ($.trim(usrName).length != 0) {\n              that.socket.emit(&#39;login&#39;, usrName);\n              that.socket.emit(&#39;cuList&#39;, users);\n          } else {\n              $(&#39;#usrName&#39;).focus();\n          };\n      });\n      //登陆监听enter\n      $(&#39;#usrName&#39;).on(&#39;keyup&#39;, function(e) {\n          if (e.keyCode == 13) {\n              var usrName = $(&#39;#usrName&#39;).val();\n              if ($.trim(usrName).length != 0) {\n                  that.socket.emit(&#39;login&#39;, usrName);\n                  that.socket.emit(&#39;cuList&#39;, users);\n              };\n          };\n      });\n      //bind发送按钮\n      $(&#39;#sendBtn&#39;).on(&#39;click tap&#39;, function() {\n          var messageInput = $(&#39;#messageInput&#39;),\n              msg = messageInput.val(),\n              color = $(&#39;#colorStyle&#39;).val();\n          messageInput.val(&#39; &#39;);\n          messageInput.focus();\n          if ($.trim(msg).length != 0) {\n              that.socket.emit(&#39;postMsg&#39;, msg, color);\n              that._displayNewMsg(&#39;me&#39;, msg, color);\n              return;\n          };\n      });\n      //bind发送\n      $(&#39;#messageInput&#39;).on(&#39;keyup&#39;, function(e) {\n          var messageInput = $(&#39;#messageInput&#39;),\n              msg = messageInput.val(),\n              color = $(&#39;#colorStyle&#39;).val();\n          if (e.keyCode == 13 &amp;&amp; $.trim(msg).length != 0) {\n              messageInput.val(&#39; &#39;);\n              that.socket.emit(&#39;postMsg&#39;, msg, color);\n              that._displayNewMsg(&#39;me&#39;, msg, color);\n          };\n      });\n      //清空\n      $(&#39;#clearBtn&#39;).on(&#39;click tap&#39;, function() {\n          $(&#39;#winChat&#39;).html(&quot; &quot;);\n      });\n      //发送图片\n      $(&#39;#imgSend&#39;).on(&#39;change&#39;, function() {\n          if (this.files.length != 0) {\n              var file = this.files[0],\n                  reader = new FileReader(),\n                  color = $(&#39;#colorStyle&#39;).val();\n              if (!reader) {\n                  that._displayNewMsg(&#39;system&#39;, &#39;辣鸡浏览器不支持上传文件&#39;, &#39;red&#39;);\n                  this.val(&#39; &#39;);\n                  return;\n              };\n              //接收图片\n              reader.onload = function(e) {\n                  that.socket.emit(&#39;img&#39;, e.target.result, color);\n                  that._displayImage(&#39;me&#39;, e.target.result, color);\n              };\n              reader.readAsDataURL(file);\n          };\n      });\n      //图片包\n      this._initialLxh();\n      //按钮\n      $(&#39;#lxh&#39;).on(&#39;click tap&#39;, function(e) {\n          var lxhwrapper = $(&#39;#lxhWrapper&#39;);\n          lxhwrapper.css(&#39;display&#39;,&#39;block&#39;);\n          e.stopPropagation();\n      });\n      //二级图片栏\n      $(&#39;body&#39;).on(&#39;click&#39;, function(e) {\n          var lxhwrapper = $(&#39;#lxhWrapper&#39;);\n          if (e.target != lxhwrapper) {\n              lxhwrapper.css(&#39;display&#39;,&#39;none&#39;);\n          };\n      });\n      $(&#39;#lxhWrapper&#39;).on(&#39;click tap&#39;, function(e) {\n          var target = e.target;\n          if (target.nodeName.toLowerCase() == &#39;img&#39;) {\n              var messageInput = $(&#39;#messageInput&#39;);\n              messageInput.focus();\n              messageInput.val(messageInput.val() + &#39;[lxh:&#39; + target.title + &#39;]&#39;);\n          };\n      });\n  },\n      //发送图片\n  _initialLxh: function() {\n      var lxhContainer = $(&#39;#lxhWrapper&#39;),\n          docFragment = document.createDocumentFragment();\n      for (var i = 100; i &gt; 0; i--) {\n          var lxhItem = document.createElement(&#39;img&#39;);\n          lxhItem.src = &#39;../content/lxh/&#39; + i + &#39;.gif&#39;;\n          lxhItem.title = i;\n          docFragment.appendChild(lxhItem);\n      };\n      lxhContainer.append(docFragment);\n  },\n  _displayNewMsg: function(user, msg, color) {\n      var container = $(&#39;#winChat&#39;),\n          msgToDisplay = $(&#39;&lt;p&gt;&lt;/p&gt;&#39;),\n          date = new Date().toTimeString().substr(0, 8),\n          msg = this._showLxh(msg);\n      msgToDisplay.css(&#39;color&#39;,color || &#39;#000&#39;);\n      msgToDisplay.html(user + &#39;&lt;span class=&quot;timespan&quot;&gt;(&#39; + date + &#39;): &lt;/span&gt;&#39; + msg);\n      container.append(msgToDisplay);\n      container.scrollTop = container.scrollHeight;\n  },\n  _displayImage: function(user, imgData, color) {\n      var container = $(&#39;#winChat&#39;),\n          msgToDisplay = $(&#39;&lt;p&gt;&lt;/p&gt;&#39;),\n          date = new Date().toTimeString().substr(0, 8);\n      msgToDisplay.css(&#39;color&#39;,color || &#39;#000&#39;);\n      msgToDisplay.html(user + &#39;&lt;span class=&quot;timespan&quot;&gt;(&#39; + date + &#39;): &lt;/span&gt; &lt;br/&gt;&#39; + &#39;&lt;a href=&quot;&#39; + imgData + &#39;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;&#39; + imgData + &#39;&quot;/&gt;&lt;/a&gt;&#39;);\n      container.append(msgToDisplay);\n      container.scrollTop = container.scrollHeight;\n  },\n  _showLxh: function(msg) {\n      var match, \n          result = msg,\n          reg = /\\[lxh:\\d+\\]/g,\n          lxhIndex,\n          totalLxhNum = $(&#39;#lxhWrapper&#39;).children().length;\n      while (match = reg.exec(msg)) {\n          lxhIndex = match[0].slice(5, -1);\n          console.log(lxhIndex);\n          if (lxhIndex &gt; totalLxhNum) {\n              result = result.replace(match[0], &#39;[X]&#39;);\n          } else {\n              result = result.replace(match[0], &#39;&lt;img class=&quot;lxh&quot; src=&quot;../content/lxh/&#39; + lxhIndex + &#39;.gif&quot; /&gt;&#39;);\n          };\n      };\n      return result;\n  }\n};\n</code></pre><pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n      &lt;meta charset=&quot;utf-8&quot;&gt;\n      &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;\n      &lt;meta name=&quot;description&quot; content=&quot;webchat | a simple chat application built with node.js and websocket&quot;&gt;\n      &lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt;    \n     &lt;title&gt;webchat&lt;/title&gt;\n      &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/main.css&quot;&gt;\n      &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;\n      &lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n      &lt;div class=&quot;wrapper&quot;&gt;\n          &lt;div class=&quot;banner&quot;&gt;\n              &lt;div&gt;WebChat&lt;/div&gt;\n              &lt;span id=&quot;onlineCount&quot;&gt;&lt;/span&gt;\n          &lt;/div&gt;\n          &lt;div id=&quot;winChat&quot;&gt;\n          &lt;/div&gt;\n          &lt;div class=&quot;controls&quot; &gt;\n              &lt;div class=&quot;items&quot;&gt;\n                  &lt;input id=&quot;colorStyle&quot; type=&quot;color&quot; placeHolder=&#39;#000&#39; title=&quot;font color&quot; /&gt;\n                  &lt;input id=&quot;lxh&quot; type=&quot;button&quot; value=&quot;lxh&quot; title=&quot;lxh&quot; /&gt;\n                  &lt;label for=&quot;imgSend&quot; class=&quot;imgLabel&quot;&gt;\n                      &lt;input type=&quot;button&quot; value=&quot;表情&quot; style=&quot;width: 60px;height: 30px;border: 0;margin: 0;padding: 0;&quot; /&gt;\n                      &lt;input id=&quot;imgSend&quot; type=&quot;file&quot; accept=&quot;image/gif&quot; value=&quot;表情&quot;  /&gt;\n                  &lt;/label&gt;\n                  &lt;input id=&quot;clearBtn&quot; type=&quot;button&quot; value=&quot;清空&quot; title=&quot;clear screen&quot; /&gt;\n              &lt;/div&gt;\n              &lt;input type=&quot;text&quot; id=&quot;messageInput&quot; placeHolder=&quot;enter to send&quot;/&gt;\n              &lt;input id=&quot;sendBtn&quot; type=&quot;button&quot; value=&quot;发送&quot;&gt;\n              &lt;div id=&quot;lxhWrapper&quot;&gt;\n              &lt;/div&gt;\n          &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class=&quot;right&quot; id=&quot;right&quot;&gt;&lt;/div&gt;\n      &lt;div id=&quot;loginArea&quot;&gt;\n          &lt;p id=&quot;info&quot;&gt;正在连接服务器...&lt;/p&gt;\n          &lt;div id=&quot;inModal&quot;&gt;\n              &lt;input type=&quot;text&quot; placeHolder=&quot;请输入昵称&quot; id=&quot;usrName&quot; /&gt;\n              &lt;input type=&quot;button&quot; value=&quot;进入&quot; id=&quot;loginBtn&quot; /&gt;\n          &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;script src=&quot;scripts/jquery-2.1.0.js&quot;&gt;&lt;/script&gt;\n      &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;\n      &lt;script src=&quot;scripts/webchat.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></li>\n</ul>\n<pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;\n        &lt;meta name=&quot;description&quot; content=&quot;webchat | a simple chat application built with node.js and websocket&quot;&gt;\n        &lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt;    \n       &lt;title&gt;webchat&lt;/title&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/main.css&quot;&gt;\n        &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;\n        &lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=&quot;wrapper&quot;&gt;\n            &lt;div class=&quot;banner&quot;&gt;\n                &lt;div&gt;WebChat&lt;/div&gt;\n                &lt;span id=&quot;onlineCount&quot;&gt;&lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div id=&quot;winChat&quot;&gt;\n            &lt;/div&gt;\n            &lt;div class=&quot;controls&quot; &gt;\n                &lt;div class=&quot;items&quot;&gt;\n                    &lt;input id=&quot;colorStyle&quot; type=&quot;color&quot; placeHolder=&#39;#000&#39; title=&quot;font color&quot; /&gt;\n                    &lt;input id=&quot;lxh&quot; type=&quot;button&quot; value=&quot;lxh&quot; title=&quot;lxh&quot; /&gt;\n                    &lt;label for=&quot;imgSend&quot; class=&quot;imgLabel&quot;&gt;\n                        &lt;input type=&quot;button&quot; value=&quot;表情&quot; style=&quot;width: 60px;height: 30px;border: 0;margin: 0;padding: 0;&quot; /&gt;\n                        &lt;input id=&quot;imgSend&quot; type=&quot;file&quot; accept=&quot;image/gif&quot; value=&quot;表情&quot;  /&gt;\n                    &lt;/label&gt;\n                    &lt;input id=&quot;clearBtn&quot; type=&quot;button&quot; value=&quot;清空&quot; title=&quot;clear screen&quot; /&gt;\n                &lt;/div&gt;\n                &lt;input type=&quot;text&quot; id=&quot;messageInput&quot; placeHolder=&quot;enter to send&quot;/&gt;\n                &lt;input id=&quot;sendBtn&quot; type=&quot;button&quot; value=&quot;发送&quot;&gt;\n                &lt;div id=&quot;lxhWrapper&quot;&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot; id=&quot;right&quot;&gt;&lt;/div&gt;\n        &lt;div id=&quot;loginArea&quot;&gt;\n            &lt;p id=&quot;info&quot;&gt;正在连接服务器...&lt;/p&gt;\n            &lt;div id=&quot;inModal&quot;&gt;\n                &lt;input type=&quot;text&quot; placeHolder=&quot;请输入昵称&quot; id=&quot;usrName&quot; /&gt;\n                &lt;input type=&quot;button&quot; value=&quot;进入&quot; id=&quot;loginBtn&quot; /&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;script src=&quot;scripts/jquery-2.1.0.js&quot;&gt;&lt;/script&gt;\n        &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;\n        &lt;script src=&quot;scripts/webchat.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>","site":{"data":{}},"excerpt":"<p>为了网络程序设计大作业，了解了http,websocket,node及其框架…<br>","more":"</p>\n<h3 id=\"http协议\"><a href=\"#http协议\" class=\"headerlink\" title=\"http协议\"></a>http协议</h3><ul>\n<li>HTTP是超文本传输协议，是客户端浏览器或其他程序与Web服务器之间的应用层通信协议<ul>\n<li>HTTP使用TCP/IP建立连接<br><img src=\"http://upload-images.jianshu.io/upload_images/3767061-36776499e489d972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3767061-25b34aab5fc17bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<ul>\n<li>TCP客户端和服务器通过TCP套接字接口通信</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3767061-ff829f1fafae57a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h3 id=\"Websocket\"><a href=\"#Websocket\" class=\"headerlink\" title=\"Websocket\"></a>Websocket</h3><ul>\n<li>Websocket是一个持久化的协议<br>http1.0的生命周期很短，一个request一个response完成后就结束<br>http1.1增加了一个keep-alive，在一个http连接中可以发送多个request，接收多个response</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3767061-b512a13ed3c4cd9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/3767061-92194c7aa3f952d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br>这是一个 websocket的request和 response</p>\n<ul>\n<li>websocket解决了http的部分难题<ul>\n<li><strong>被动性</strong> 服务端可以主动推送信息给客户端，不需要客户端不断请求</li>\n<li><strong>持久性</strong> 只需要一次握手，整个通信建立在一次连接中，避免了中介反复解析</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基于express和socket-io构建聊天室\"><a href=\"#基于express和socket-io构建聊天室\" class=\"headerlink\" title=\"基于express和socket.io构建聊天室\"></a>基于express和socket.io构建聊天室</h3><ul>\n<li>express<br>安装<pre><code>npm install express -g\n</code></pre>server.js引用模块<pre><code>var express = require(&#39;express&#39;),\napp = express(),\nserver = require(&#39;http&#39;).createServer(app);  //创建服务\napp.use(&#39;/&#39;, express.static(__dirname + &#39;/www&#39;)); //调用静态文件\n</code></pre></li>\n</ul>\n<ul>\n<li><p>socket.IO<br>可以接受所有与服务器相连接的客户端发送的消息，也可向客户端主动发送消息。<br>安装</p>\n<pre><code>npm install socket.io\n</code></pre><p>引用</p>\n<pre><code>var io = require(&#39;socket.io&#39;).listen(server);\nserver.listen(process.env.PORT || 3000);  //监听端口\n</code></pre></li>\n<li><p>connect</p>\n<pre><code>io.sockets.on(&#39;connection&#39;, function(socket) {   //建立连接\n  //新用户\n  socket.on(&#39;login&#39;, function(usrName,user) {\n      if (users.indexOf(usrName) &gt; -1) {\n          socket.emit(&#39;usrExisted&#39;);\n      } else {\n          socket.userIndex = users.length;\n          socket.usrName = usrName;\n          socket.users = users;\n          users.push(usrName);\n          date = new Date().toTimeString().substr(0, 8);\n          console.log(date+&quot;/&quot;+usrName+&#39;加入了聊天&#39;);\n          socket.emit(&#39;loginSuccess&#39;);\n          io.sockets.emit(&#39;system&#39;, usrName, users.length, &#39;login&#39;);\n          io.sockets.emit(&#39;cuList&#39;, users);\n      };\n  });\n  //用户离开\n  socket.on(&#39;disconnect&#39;, function(user) {\n      if (socket.usrName != null) {\n          socket.users = users;\n          users.splice(socket.userIndex, 1);\n          date = new Date().toTimeString().substr(0, 8);\n          console.log(date+&quot;/&quot;+socket.usrName+&#39;滚蛋了&#39;);\n          socket.broadcast.emit(&#39;system&#39;, socket.usrName, users.length, &#39;logout&#39;);\n          io.sockets.emit(&#39;cuList&#39;, users);\n      }\n  });\n  //用户列表\n  //新消息\n  socket.on(&#39;postMsg&#39;, function(msg, color) {\n      date = new Date().toTimeString().substr(0, 8);\n      console.log(date+&quot;/&quot;+socket.usrName+&#39;：&#39;+msg);\n      socket.broadcast.emit(&#39;newMsg&#39;, socket.usrName, msg, color);\n  });\n  //新图片\n  socket.on(&#39;img&#39;, function(imgData, color) {\n      date = new Date().toTimeString().substr(0, 8);\n      console.log(date+&quot;/&quot;+socket.usrName+&#39;：&#39;+imgData);\n      socket.broadcast.emit(&#39;newImg&#39;, socket.usrName, imgData, color);\n  });\n});\n</code></pre></li>\n<li><p>客户端js,html,css</p>\n<pre><code>window.onload = function() {\n  var webchat = new WebChat();\n  webchat.init();\n};\nvar WebChat = function() {\n  this.socket = null;\n};\nWebChat.prototype = {\n  init: function() {\n      var that = this;\n      this.socket = io.connect();\n      //建立连接\n      this.socket.on(&#39;connect&#39;, function() {\n          $(&#39;#info&#39;).text(&#39;大爷儿，进来玩玩&#39;);\n          $(&#39;#inModal&#39;).css(&#39;display&#39;,&#39;block&#39;);\n          $(&#39;#usrName&#39;).focus();\n      });\n      //昵称占用\n      this.socket.on(&#39;usrExisted&#39;, function() {\n          $(&#39;#info&#39;).text(&#39;昵称已被使用，请换一个试试！&#39;);\n      });\n      //登陆成功\n      this.socket.on(&#39;loginSuccess&#39;, function() {\n          document.title =&#39;webchat | &#39; + $(&#39;#usrName&#39;).val();\n          $(&#39;#loginArea&#39;).css(&#39;display&#39;,&#39;none&#39;);\n          $(&#39;#messageInput&#39;).focus();\n      });\n      //用户列表\n      this.socket.on(&#39;cuList&#39;,function(users){\n          var cuList = $(&#39;#right&#39;);\n          var addStr = &quot;&quot;;\n          console.log(users);\n          users.forEach(function(user){\n              addStr += user + &#39;&lt;br/&gt;&#39;;\n          });\n          cuList.html(&#39;用户列表&lt;br/&gt;&#39;+addStr);\n      })\n      //连接失败\n      this.socket.on(&#39;error&#39;, function(err) {\n          if ($(&#39;#loginArea&#39;).style.display == &#39;none&#39;) {\n              $(&#39;#onlineCount&#39;).text(&#39;连接失败！&#39;);\n          } else {\n              $(&#39;#info&#39;).text(&#39;连接失败！&#39;);\n          }\n      });\n      //系统通知用户加入或离开\n      this.socket.on(&#39;system&#39;, function(usrName, userCount, type) {\n          var msg = usrName + (type == &#39;login&#39; ? &#39;来了&#39; : &#39;滚了&#39;);\n          that._displayNewMsg(&#39;system &#39;, msg, &#39;red&#39;);\n          $(&#39;#onlineCount&#39;).text(userCount + (userCount &gt; 1 ? &#39; users&#39; : &#39; user&#39;) + &#39; online&#39;);\n      });\n      //发送消息\n      this.socket.on(&#39;newMsg&#39;, function(user, msg, color) {\n          that._displayNewMsg(user, msg, color);\n      });\n      //发送图片\n      this.socket.on(&#39;newImg&#39;, function(user, img, color) {\n          that._displayImage(user, img, color);\n      });\n\n      //底层监听事件\n\n      //登陆按钮\n      $(&#39;#loginBtn&#39;).on(&#39;click tap&#39;, function() {\n          var usrName = $(&#39;#usrName&#39;).val();\n          if ($.trim(usrName).length != 0) {\n              that.socket.emit(&#39;login&#39;, usrName);\n              that.socket.emit(&#39;cuList&#39;, users);\n          } else {\n              $(&#39;#usrName&#39;).focus();\n          };\n      });\n      //登陆监听enter\n      $(&#39;#usrName&#39;).on(&#39;keyup&#39;, function(e) {\n          if (e.keyCode == 13) {\n              var usrName = $(&#39;#usrName&#39;).val();\n              if ($.trim(usrName).length != 0) {\n                  that.socket.emit(&#39;login&#39;, usrName);\n                  that.socket.emit(&#39;cuList&#39;, users);\n              };\n          };\n      });\n      //bind发送按钮\n      $(&#39;#sendBtn&#39;).on(&#39;click tap&#39;, function() {\n          var messageInput = $(&#39;#messageInput&#39;),\n              msg = messageInput.val(),\n              color = $(&#39;#colorStyle&#39;).val();\n          messageInput.val(&#39; &#39;);\n          messageInput.focus();\n          if ($.trim(msg).length != 0) {\n              that.socket.emit(&#39;postMsg&#39;, msg, color);\n              that._displayNewMsg(&#39;me&#39;, msg, color);\n              return;\n          };\n      });\n      //bind发送\n      $(&#39;#messageInput&#39;).on(&#39;keyup&#39;, function(e) {\n          var messageInput = $(&#39;#messageInput&#39;),\n              msg = messageInput.val(),\n              color = $(&#39;#colorStyle&#39;).val();\n          if (e.keyCode == 13 &amp;&amp; $.trim(msg).length != 0) {\n              messageInput.val(&#39; &#39;);\n              that.socket.emit(&#39;postMsg&#39;, msg, color);\n              that._displayNewMsg(&#39;me&#39;, msg, color);\n          };\n      });\n      //清空\n      $(&#39;#clearBtn&#39;).on(&#39;click tap&#39;, function() {\n          $(&#39;#winChat&#39;).html(&quot; &quot;);\n      });\n      //发送图片\n      $(&#39;#imgSend&#39;).on(&#39;change&#39;, function() {\n          if (this.files.length != 0) {\n              var file = this.files[0],\n                  reader = new FileReader(),\n                  color = $(&#39;#colorStyle&#39;).val();\n              if (!reader) {\n                  that._displayNewMsg(&#39;system&#39;, &#39;辣鸡浏览器不支持上传文件&#39;, &#39;red&#39;);\n                  this.val(&#39; &#39;);\n                  return;\n              };\n              //接收图片\n              reader.onload = function(e) {\n                  that.socket.emit(&#39;img&#39;, e.target.result, color);\n                  that._displayImage(&#39;me&#39;, e.target.result, color);\n              };\n              reader.readAsDataURL(file);\n          };\n      });\n      //图片包\n      this._initialLxh();\n      //按钮\n      $(&#39;#lxh&#39;).on(&#39;click tap&#39;, function(e) {\n          var lxhwrapper = $(&#39;#lxhWrapper&#39;);\n          lxhwrapper.css(&#39;display&#39;,&#39;block&#39;);\n          e.stopPropagation();\n      });\n      //二级图片栏\n      $(&#39;body&#39;).on(&#39;click&#39;, function(e) {\n          var lxhwrapper = $(&#39;#lxhWrapper&#39;);\n          if (e.target != lxhwrapper) {\n              lxhwrapper.css(&#39;display&#39;,&#39;none&#39;);\n          };\n      });\n      $(&#39;#lxhWrapper&#39;).on(&#39;click tap&#39;, function(e) {\n          var target = e.target;\n          if (target.nodeName.toLowerCase() == &#39;img&#39;) {\n              var messageInput = $(&#39;#messageInput&#39;);\n              messageInput.focus();\n              messageInput.val(messageInput.val() + &#39;[lxh:&#39; + target.title + &#39;]&#39;);\n          };\n      });\n  },\n      //发送图片\n  _initialLxh: function() {\n      var lxhContainer = $(&#39;#lxhWrapper&#39;),\n          docFragment = document.createDocumentFragment();\n      for (var i = 100; i &gt; 0; i--) {\n          var lxhItem = document.createElement(&#39;img&#39;);\n          lxhItem.src = &#39;../content/lxh/&#39; + i + &#39;.gif&#39;;\n          lxhItem.title = i;\n          docFragment.appendChild(lxhItem);\n      };\n      lxhContainer.append(docFragment);\n  },\n  _displayNewMsg: function(user, msg, color) {\n      var container = $(&#39;#winChat&#39;),\n          msgToDisplay = $(&#39;&lt;p&gt;&lt;/p&gt;&#39;),\n          date = new Date().toTimeString().substr(0, 8),\n          msg = this._showLxh(msg);\n      msgToDisplay.css(&#39;color&#39;,color || &#39;#000&#39;);\n      msgToDisplay.html(user + &#39;&lt;span class=&quot;timespan&quot;&gt;(&#39; + date + &#39;): &lt;/span&gt;&#39; + msg);\n      container.append(msgToDisplay);\n      container.scrollTop = container.scrollHeight;\n  },\n  _displayImage: function(user, imgData, color) {\n      var container = $(&#39;#winChat&#39;),\n          msgToDisplay = $(&#39;&lt;p&gt;&lt;/p&gt;&#39;),\n          date = new Date().toTimeString().substr(0, 8);\n      msgToDisplay.css(&#39;color&#39;,color || &#39;#000&#39;);\n      msgToDisplay.html(user + &#39;&lt;span class=&quot;timespan&quot;&gt;(&#39; + date + &#39;): &lt;/span&gt; &lt;br/&gt;&#39; + &#39;&lt;a href=&quot;&#39; + imgData + &#39;&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;&#39; + imgData + &#39;&quot;/&gt;&lt;/a&gt;&#39;);\n      container.append(msgToDisplay);\n      container.scrollTop = container.scrollHeight;\n  },\n  _showLxh: function(msg) {\n      var match, \n          result = msg,\n          reg = /\\[lxh:\\d+\\]/g,\n          lxhIndex,\n          totalLxhNum = $(&#39;#lxhWrapper&#39;).children().length;\n      while (match = reg.exec(msg)) {\n          lxhIndex = match[0].slice(5, -1);\n          console.log(lxhIndex);\n          if (lxhIndex &gt; totalLxhNum) {\n              result = result.replace(match[0], &#39;[X]&#39;);\n          } else {\n              result = result.replace(match[0], &#39;&lt;img class=&quot;lxh&quot; src=&quot;../content/lxh/&#39; + lxhIndex + &#39;.gif&quot; /&gt;&#39;);\n          };\n      };\n      return result;\n  }\n};\n</code></pre><pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n      &lt;meta charset=&quot;utf-8&quot;&gt;\n      &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;\n      &lt;meta name=&quot;description&quot; content=&quot;webchat | a simple chat application built with node.js and websocket&quot;&gt;\n      &lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt;    \n     &lt;title&gt;webchat&lt;/title&gt;\n      &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/main.css&quot;&gt;\n      &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;\n      &lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n      &lt;div class=&quot;wrapper&quot;&gt;\n          &lt;div class=&quot;banner&quot;&gt;\n              &lt;div&gt;WebChat&lt;/div&gt;\n              &lt;span id=&quot;onlineCount&quot;&gt;&lt;/span&gt;\n          &lt;/div&gt;\n          &lt;div id=&quot;winChat&quot;&gt;\n          &lt;/div&gt;\n          &lt;div class=&quot;controls&quot; &gt;\n              &lt;div class=&quot;items&quot;&gt;\n                  &lt;input id=&quot;colorStyle&quot; type=&quot;color&quot; placeHolder=&#39;#000&#39; title=&quot;font color&quot; /&gt;\n                  &lt;input id=&quot;lxh&quot; type=&quot;button&quot; value=&quot;lxh&quot; title=&quot;lxh&quot; /&gt;\n                  &lt;label for=&quot;imgSend&quot; class=&quot;imgLabel&quot;&gt;\n                      &lt;input type=&quot;button&quot; value=&quot;表情&quot; style=&quot;width: 60px;height: 30px;border: 0;margin: 0;padding: 0;&quot; /&gt;\n                      &lt;input id=&quot;imgSend&quot; type=&quot;file&quot; accept=&quot;image/gif&quot; value=&quot;表情&quot;  /&gt;\n                  &lt;/label&gt;\n                  &lt;input id=&quot;clearBtn&quot; type=&quot;button&quot; value=&quot;清空&quot; title=&quot;clear screen&quot; /&gt;\n              &lt;/div&gt;\n              &lt;input type=&quot;text&quot; id=&quot;messageInput&quot; placeHolder=&quot;enter to send&quot;/&gt;\n              &lt;input id=&quot;sendBtn&quot; type=&quot;button&quot; value=&quot;发送&quot;&gt;\n              &lt;div id=&quot;lxhWrapper&quot;&gt;\n              &lt;/div&gt;\n          &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class=&quot;right&quot; id=&quot;right&quot;&gt;&lt;/div&gt;\n      &lt;div id=&quot;loginArea&quot;&gt;\n          &lt;p id=&quot;info&quot;&gt;正在连接服务器...&lt;/p&gt;\n          &lt;div id=&quot;inModal&quot;&gt;\n              &lt;input type=&quot;text&quot; placeHolder=&quot;请输入昵称&quot; id=&quot;usrName&quot; /&gt;\n              &lt;input type=&quot;button&quot; value=&quot;进入&quot; id=&quot;loginBtn&quot; /&gt;\n          &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;script src=&quot;scripts/jquery-2.1.0.js&quot;&gt;&lt;/script&gt;\n      &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;\n      &lt;script src=&quot;scripts/webchat.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></li>\n</ul>\n<pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;\n        &lt;meta name=&quot;description&quot; content=&quot;webchat | a simple chat application built with node.js and websocket&quot;&gt;\n        &lt;meta name=&quot;viewport&quot;content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt;    \n       &lt;title&gt;webchat&lt;/title&gt;\n        &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/main.css&quot;&gt;\n        &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;\n        &lt;link rel=&quot;icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div class=&quot;wrapper&quot;&gt;\n            &lt;div class=&quot;banner&quot;&gt;\n                &lt;div&gt;WebChat&lt;/div&gt;\n                &lt;span id=&quot;onlineCount&quot;&gt;&lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div id=&quot;winChat&quot;&gt;\n            &lt;/div&gt;\n            &lt;div class=&quot;controls&quot; &gt;\n                &lt;div class=&quot;items&quot;&gt;\n                    &lt;input id=&quot;colorStyle&quot; type=&quot;color&quot; placeHolder=&#39;#000&#39; title=&quot;font color&quot; /&gt;\n                    &lt;input id=&quot;lxh&quot; type=&quot;button&quot; value=&quot;lxh&quot; title=&quot;lxh&quot; /&gt;\n                    &lt;label for=&quot;imgSend&quot; class=&quot;imgLabel&quot;&gt;\n                        &lt;input type=&quot;button&quot; value=&quot;表情&quot; style=&quot;width: 60px;height: 30px;border: 0;margin: 0;padding: 0;&quot; /&gt;\n                        &lt;input id=&quot;imgSend&quot; type=&quot;file&quot; accept=&quot;image/gif&quot; value=&quot;表情&quot;  /&gt;\n                    &lt;/label&gt;\n                    &lt;input id=&quot;clearBtn&quot; type=&quot;button&quot; value=&quot;清空&quot; title=&quot;clear screen&quot; /&gt;\n                &lt;/div&gt;\n                &lt;input type=&quot;text&quot; id=&quot;messageInput&quot; placeHolder=&quot;enter to send&quot;/&gt;\n                &lt;input id=&quot;sendBtn&quot; type=&quot;button&quot; value=&quot;发送&quot;&gt;\n                &lt;div id=&quot;lxhWrapper&quot;&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;right&quot; id=&quot;right&quot;&gt;&lt;/div&gt;\n        &lt;div id=&quot;loginArea&quot;&gt;\n            &lt;p id=&quot;info&quot;&gt;正在连接服务器...&lt;/p&gt;\n            &lt;div id=&quot;inModal&quot;&gt;\n                &lt;input type=&quot;text&quot; placeHolder=&quot;请输入昵称&quot; id=&quot;usrName&quot; /&gt;\n                &lt;input type=&quot;button&quot; value=&quot;进入&quot; id=&quot;loginBtn&quot; /&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;script src=&quot;scripts/jquery-2.1.0.js&quot;&gt;&lt;/script&gt;\n        &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;\n        &lt;script src=&quot;scripts/webchat.js&quot;&gt;&lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"layout":"[layout]","title":"第一篇博客","date":"2016-11-20T16:01:09.000Z","type":"tags","_content":"折腾了一天了，本不应该耗这么久，然而win10的node总是要闹点小脾气。。\n\n<!--more-->\n","source":"_posts/第一篇博客.md","raw":"layout: '[layout]'\ntitle: 第一篇博客\ndate: 2016-11-21 00:01:09\ntype: \"tags\"\ntags:\n  - Xunfeng\n  - 黑天很黑\n---\n折腾了一天了，本不应该耗这么久，然而win10的node总是要闹点小脾气。。\n\n<!--more-->\n","slug":"第一篇博客","published":1,"updated":"2016-11-21T16:05:12.000Z","comments":1,"photos":[],"link":"","_id":"cjakphl320013ttwpw2bisqqm","content":"<p>折腾了一天了，本不应该耗这么久，然而win10的node总是要闹点小脾气。。</p>\n<a id=\"more\"></a>\n","site":{"data":{}},"excerpt":"<p>折腾了一天了，本不应该耗这么久，然而win10的node总是要闹点小脾气。。</p>","more":""},{"title":"记录第一次搭建hexo","date":"2016-11-22T06:57:37.000Z","type":"hexo","_content":"即使扒了很多大佬的搭建教程，还是踩了很多坑，所以打算记录下来自己的搭建过程。本文主要介绍win10下hexo3.1.1搭建，并发布到GitHub上。\n\n<!--more-->\n\n## 环境搭建\n &ensp;安装nodejs（必须）\n- 作用：用来生成静态页面的\n- 方法：到[node.js](http://nodejs.cn/)官网下载并安装。我是用的是win10下v6.9.1版本。\n\n &ensp;安装git（必须）\n- 作用：把本地的hexo内容提交到github上去。\n- 方法：进入git官方下载即可，速度较慢。\n\n &ensp;申请GitHub账号（必须）\n- 作用：是用来做博客的远程创库、域名、服务器之类的。\n- 方法：到[github](https://github.com/)官网自行注册，如果想深入学习请看[pro git](http://iissnan.com/progit/)教程\n\n\n## 安装并搭建hexo\n &ensp;安装hexo\n- 进入git或cmd执行以下命令\n\n\n```\nnpm install -g hexo\n```\n\n- hexo必备插件，建议一起安装\n\n```\n$ npm install hexo-generator-index --save #索引生成器\n$ npm install hexo-generator-archive --save #归档生成器\n$ npm install hexo-generator-category --save #分类生成器\n$ npm install hexo-generator-tag --save #标签生成器\n$ npm install hexo-server --save #本地服务\n$ npm install hexo-deployer-git --save #hexo通过git发布（必装）\n$ npm install hexo-renderer-marked@0.2.7--save #渲染器\n$ npm install hexo-renderer-stylus@0.3.0 --save #渲染器\n```\n\n- 安装过程中不知道为毛我多了两个蜜汁报错，但到最后也没太大影响\n\n```\nnpm WARN deprecated swig@1.4.2: This package is no longer maintained\n```\n```\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevent@^1.0.0(node_modules\\hexo\\node_modules|chokidar\\node_mdules\\fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.0.15: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"win32\",\"arch\":\"x64\"})\n```\n\n- 初始化\n 选择本地磁盘某个位置创建本地hexo文件夹，进入后右键 git bash\n\n```\n$ hexo init\n```\n\n- 生成静态页面\n\n```\n$ hexo p\n```\n\n- 本地服务\n必须安装 hexo server，否则无用\n\n```\nhexo s\n```\n\n至此本地hexo已建立成功，测试网址：[http://localhost:4000](http://localhost:4000/)\n\n## 配置GitHub\n- 建立Repository\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】\n\n现在我们需要编辑_config.yml文件：\n翻到最下面，改成我这样子的\n```\ndeploy: \n      type: git  //有的版本是github也是个小坑，注意\n      repo: https://github.com/xunfeng911/xunfeng911.github.com.git // 换成你本人的\n      branch: master\n```\n\n然后保存后执行命令：\n\n```\nhexo d\n```\n注意yml格式文件冒号后面必须加一个空格\n执行完毕后访问your_user_name.github.io\n即可看到部署在github上的默认博客,第一次发布可能会有10分钟的延迟。\n\n到这里，一个全新的hexo博客就建成了。\n\n\n\n## 附录\n\n- 常用命令：\n\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help # 查看帮助\nhexo version #查看Hexo的版本\n```\n- 简写\n\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n## 参考资料\n\n[卢睿韬学长的自留地](https://xdlrt.github.io/2016/02/16/2016-02-16/)\n[潘柏信,搭建个人博客](http://baixin.io/2015/08/HEXO搭建个人博客/)","source":"_posts/记录第一次搭建hexo.md","raw":"---\ntitle: 记录第一次搭建hexo\ndate: 2016-11-22 14:57:37\ntype: \"hexo\"\ntags:\n  - 搭建hexo\n  - git\n---\n即使扒了很多大佬的搭建教程，还是踩了很多坑，所以打算记录下来自己的搭建过程。本文主要介绍win10下hexo3.1.1搭建，并发布到GitHub上。\n\n<!--more-->\n\n## 环境搭建\n &ensp;安装nodejs（必须）\n- 作用：用来生成静态页面的\n- 方法：到[node.js](http://nodejs.cn/)官网下载并安装。我是用的是win10下v6.9.1版本。\n\n &ensp;安装git（必须）\n- 作用：把本地的hexo内容提交到github上去。\n- 方法：进入git官方下载即可，速度较慢。\n\n &ensp;申请GitHub账号（必须）\n- 作用：是用来做博客的远程创库、域名、服务器之类的。\n- 方法：到[github](https://github.com/)官网自行注册，如果想深入学习请看[pro git](http://iissnan.com/progit/)教程\n\n\n## 安装并搭建hexo\n &ensp;安装hexo\n- 进入git或cmd执行以下命令\n\n\n```\nnpm install -g hexo\n```\n\n- hexo必备插件，建议一起安装\n\n```\n$ npm install hexo-generator-index --save #索引生成器\n$ npm install hexo-generator-archive --save #归档生成器\n$ npm install hexo-generator-category --save #分类生成器\n$ npm install hexo-generator-tag --save #标签生成器\n$ npm install hexo-server --save #本地服务\n$ npm install hexo-deployer-git --save #hexo通过git发布（必装）\n$ npm install hexo-renderer-marked@0.2.7--save #渲染器\n$ npm install hexo-renderer-stylus@0.3.0 --save #渲染器\n```\n\n- 安装过程中不知道为毛我多了两个蜜汁报错，但到最后也没太大影响\n\n```\nnpm WARN deprecated swig@1.4.2: This package is no longer maintained\n```\n```\nnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevent@^1.0.0(node_modules\\hexo\\node_modules|chokidar\\node_mdules\\fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.0.15: wanted {\"os\":\"darwin\",\"arch\":\"any\"} (current: {\"os\":\"win32\",\"arch\":\"x64\"})\n```\n\n- 初始化\n 选择本地磁盘某个位置创建本地hexo文件夹，进入后右键 git bash\n\n```\n$ hexo init\n```\n\n- 生成静态页面\n\n```\n$ hexo p\n```\n\n- 本地服务\n必须安装 hexo server，否则无用\n\n```\nhexo s\n```\n\n至此本地hexo已建立成功，测试网址：[http://localhost:4000](http://localhost:4000/)\n\n## 配置GitHub\n- 建立Repository\n建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】\n\n现在我们需要编辑_config.yml文件：\n翻到最下面，改成我这样子的\n```\ndeploy: \n      type: git  //有的版本是github也是个小坑，注意\n      repo: https://github.com/xunfeng911/xunfeng911.github.com.git // 换成你本人的\n      branch: master\n```\n\n然后保存后执行命令：\n\n```\nhexo d\n```\n注意yml格式文件冒号后面必须加一个空格\n执行完毕后访问your_user_name.github.io\n即可看到部署在github上的默认博客,第一次发布可能会有10分钟的延迟。\n\n到这里，一个全新的hexo博客就建成了。\n\n\n\n## 附录\n\n- 常用命令：\n\n```\nhexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help # 查看帮助\nhexo version #查看Hexo的版本\n```\n- 简写\n\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n## 参考资料\n\n[卢睿韬学长的自留地](https://xdlrt.github.io/2016/02/16/2016-02-16/)\n[潘柏信,搭建个人博客](http://baixin.io/2015/08/HEXO搭建个人博客/)","slug":"记录第一次搭建hexo","published":1,"updated":"2017-10-15T02:54:29.791Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjakphl340015ttwpcd9o87fs","content":"<p>即使扒了很多大佬的搭建教程，还是踩了很多坑，所以打算记录下来自己的搭建过程。本文主要介绍win10下hexo3.1.1搭建，并发布到GitHub上。</p>\n<a id=\"more\"></a>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p> &ensp;安装nodejs（必须）</p>\n<ul>\n<li>作用：用来生成静态页面的</li>\n<li><p>方法：到<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"external\">node.js</a>官网下载并安装。我是用的是win10下v6.9.1版本。</p>\n<p>&ensp;安装git（必须）</p>\n</li>\n<li>作用：把本地的hexo内容提交到github上去。</li>\n<li><p>方法：进入git官方下载即可，速度较慢。</p>\n<p>&ensp;申请GitHub账号（必须）</p>\n</li>\n<li>作用：是用来做博客的远程创库、域名、服务器之类的。</li>\n<li>方法：到<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">github</a>官网自行注册，如果想深入学习请看<a href=\"http://iissnan.com/progit/\" target=\"_blank\" rel=\"external\">pro git</a>教程</li>\n</ul>\n<h2 id=\"安装并搭建hexo\"><a href=\"#安装并搭建hexo\" class=\"headerlink\" title=\"安装并搭建hexo\"></a>安装并搭建hexo</h2><p> &ensp;安装hexo</p>\n<ul>\n<li>进入git或cmd执行以下命令</li>\n</ul>\n<pre><code>npm install -g hexo\n</code></pre><ul>\n<li>hexo必备插件，建议一起安装</li>\n</ul>\n<pre><code>$ npm install hexo-generator-index --save #索引生成器\n$ npm install hexo-generator-archive --save #归档生成器\n$ npm install hexo-generator-category --save #分类生成器\n$ npm install hexo-generator-tag --save #标签生成器\n$ npm install hexo-server --save #本地服务\n$ npm install hexo-deployer-git --save #hexo通过git发布（必装）\n$ npm install hexo-renderer-marked@0.2.7--save #渲染器\n$ npm install hexo-renderer-stylus@0.3.0 --save #渲染器\n</code></pre><ul>\n<li>安装过程中不知道为毛我多了两个蜜汁报错，但到最后也没太大影响</li>\n</ul>\n<pre><code>npm WARN deprecated swig@1.4.2: This package is no longer maintained\n</code></pre><pre><code>npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevent@^1.0.0(node_modules\\hexo\\node_modules|chokidar\\node_mdules\\fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.0.15: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})\n</code></pre><ul>\n<li>初始化<br>选择本地磁盘某个位置创建本地hexo文件夹，进入后右键 git bash</li>\n</ul>\n<pre><code>$ hexo init\n</code></pre><ul>\n<li>生成静态页面</li>\n</ul>\n<pre><code>$ hexo p\n</code></pre><ul>\n<li>本地服务<br>必须安装 hexo server，否则无用</li>\n</ul>\n<pre><code>hexo s\n</code></pre><p>至此本地hexo已建立成功，测试网址：<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000</a></p>\n<h2 id=\"配置GitHub\"><a href=\"#配置GitHub\" class=\"headerlink\" title=\"配置GitHub\"></a>配置GitHub</h2><ul>\n<li>建立Repository<br>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】</li>\n</ul>\n<p>现在我们需要编辑_config.yml文件：<br>翻到最下面，改成我这样子的</p>\n<pre><code>deploy: \n      type: git  //有的版本是github也是个小坑，注意\n      repo: https://github.com/xunfeng911/xunfeng911.github.com.git // 换成你本人的\n      branch: master\n</code></pre><p>然后保存后执行命令：</p>\n<pre><code>hexo d\n</code></pre><p>注意yml格式文件冒号后面必须加一个空格<br>执行完毕后访问your_user_name.github.io<br>即可看到部署在github上的默认博客,第一次发布可能会有10分钟的延迟。</p>\n<p>到这里，一个全新的hexo博客就建成了。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><ul>\n<li>常用命令：</li>\n</ul>\n<pre><code>hexo new &quot;postName&quot; #新建文章\nhexo new page &quot;pageName&quot; #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help # 查看帮助\nhexo version #查看Hexo的版本\n</code></pre><ul>\n<li>简写</li>\n</ul>\n<pre><code>hexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n</code></pre><h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://xdlrt.github.io/2016/02/16/2016-02-16/\" target=\"_blank\" rel=\"external\">卢睿韬学长的自留地</a><br><a href=\"http://baixin.io/2015/08/HEXO搭建个人博客/\" target=\"_blank\" rel=\"external\">潘柏信,搭建个人博客</a></p>\n","site":{"data":{}},"excerpt":"<p>即使扒了很多大佬的搭建教程，还是踩了很多坑，所以打算记录下来自己的搭建过程。本文主要介绍win10下hexo3.1.1搭建，并发布到GitHub上。</p>","more":"<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p> &ensp;安装nodejs（必须）</p>\n<ul>\n<li>作用：用来生成静态页面的</li>\n<li><p>方法：到<a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"external\">node.js</a>官网下载并安装。我是用的是win10下v6.9.1版本。</p>\n<p>&ensp;安装git（必须）</p>\n</li>\n<li>作用：把本地的hexo内容提交到github上去。</li>\n<li><p>方法：进入git官方下载即可，速度较慢。</p>\n<p>&ensp;申请GitHub账号（必须）</p>\n</li>\n<li>作用：是用来做博客的远程创库、域名、服务器之类的。</li>\n<li>方法：到<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">github</a>官网自行注册，如果想深入学习请看<a href=\"http://iissnan.com/progit/\" target=\"_blank\" rel=\"external\">pro git</a>教程</li>\n</ul>\n<h2 id=\"安装并搭建hexo\"><a href=\"#安装并搭建hexo\" class=\"headerlink\" title=\"安装并搭建hexo\"></a>安装并搭建hexo</h2><p> &ensp;安装hexo</p>\n<ul>\n<li>进入git或cmd执行以下命令</li>\n</ul>\n<pre><code>npm install -g hexo\n</code></pre><ul>\n<li>hexo必备插件，建议一起安装</li>\n</ul>\n<pre><code>$ npm install hexo-generator-index --save #索引生成器\n$ npm install hexo-generator-archive --save #归档生成器\n$ npm install hexo-generator-category --save #分类生成器\n$ npm install hexo-generator-tag --save #标签生成器\n$ npm install hexo-server --save #本地服务\n$ npm install hexo-deployer-git --save #hexo通过git发布（必装）\n$ npm install hexo-renderer-marked@0.2.7--save #渲染器\n$ npm install hexo-renderer-stylus@0.3.0 --save #渲染器\n</code></pre><ul>\n<li>安装过程中不知道为毛我多了两个蜜汁报错，但到最后也没太大影响</li>\n</ul>\n<pre><code>npm WARN deprecated swig@1.4.2: This package is no longer maintained\n</code></pre><pre><code>npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevent@^1.0.0(node_modules\\hexo\\node_modules|chokidar\\node_mdules\\fsevents):\nnpm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.0.15: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})\n</code></pre><ul>\n<li>初始化<br>选择本地磁盘某个位置创建本地hexo文件夹，进入后右键 git bash</li>\n</ul>\n<pre><code>$ hexo init\n</code></pre><ul>\n<li>生成静态页面</li>\n</ul>\n<pre><code>$ hexo p\n</code></pre><ul>\n<li>本地服务<br>必须安装 hexo server，否则无用</li>\n</ul>\n<pre><code>hexo s\n</code></pre><p>至此本地hexo已建立成功，测试网址：<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"external\">http://localhost:4000</a></p>\n<h2 id=\"配置GitHub\"><a href=\"#配置GitHub\" class=\"headerlink\" title=\"配置GitHub\"></a>配置GitHub</h2><ul>\n<li>建立Repository<br>建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】</li>\n</ul>\n<p>现在我们需要编辑_config.yml文件：<br>翻到最下面，改成我这样子的</p>\n<pre><code>deploy: \n      type: git  //有的版本是github也是个小坑，注意\n      repo: https://github.com/xunfeng911/xunfeng911.github.com.git // 换成你本人的\n      branch: master\n</code></pre><p>然后保存后执行命令：</p>\n<pre><code>hexo d\n</code></pre><p>注意yml格式文件冒号后面必须加一个空格<br>执行完毕后访问your_user_name.github.io<br>即可看到部署在github上的默认博客,第一次发布可能会有10分钟的延迟。</p>\n<p>到这里，一个全新的hexo博客就建成了。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><ul>\n<li>常用命令：</li>\n</ul>\n<pre><code>hexo new &quot;postName&quot; #新建文章\nhexo new page &quot;pageName&quot; #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）\nhexo deploy #将.deploy目录部署到GitHub\nhexo help # 查看帮助\nhexo version #查看Hexo的版本\n</code></pre><ul>\n<li>简写</li>\n</ul>\n<pre><code>hexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n</code></pre><h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://xdlrt.github.io/2016/02/16/2016-02-16/\" target=\"_blank\" rel=\"external\">卢睿韬学长的自留地</a><br><a href=\"http://baixin.io/2015/08/HEXO搭建个人博客/\" target=\"_blank\" rel=\"external\">潘柏信,搭建个人博客</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjakphl1h0000ttwpn8k7cis0","tag_id":"cjakphl1r0004ttwp4ufrvj0d","_id":"cjakphl24000attwp5k91uvtz"},{"post_id":"cjakphl27000cttwps3w1mr3c","tag_id":"cjakphl220009ttwpnaf9hxen","_id":"cjakphl2h000fttwppxpk39we"},{"post_id":"cjakphl1n0002ttwppn2f81c7","tag_id":"cjakphl220009ttwpnaf9hxen","_id":"cjakphl2q000mttwpbe13shux"},{"post_id":"cjakphl1n0002ttwppn2f81c7","tag_id":"cjakphl2d000dttwpdmr2xbcr","_id":"cjakphl2r000ottwp0icx0ipy"},{"post_id":"cjakphl1n0002ttwppn2f81c7","tag_id":"cjakphl2j000httwpjkchewke","_id":"cjakphl2t000rttwpperp1i0j"},{"post_id":"cjakphl1y0007ttwpfbchxii0","tag_id":"cjakphl2p000kttwp8dl1mv5t","_id":"cjakphl30000zttwprdpa3qvj"},{"post_id":"cjakphl1y0007ttwpfbchxii0","tag_id":"cjakphl2s000qttwp1okh2unw","_id":"cjakphl310011ttwps9nngmbt"},{"post_id":"cjakphl1y0007ttwpfbchxii0","tag_id":"cjakphl2v000uttwpwdnorxfk","_id":"cjakphl330014ttwplpbzl3px"},{"post_id":"cjakphl2e000ettwpvfk9edrx","tag_id":"cjakphl1r0004ttwp4ufrvj0d","_id":"cjakphl360016ttwps2m80lfa"},{"post_id":"cjakphl2e000ettwpvfk9edrx","tag_id":"cjakphl2y000xttwp1chcnjca","_id":"cjakphl380018ttwpalt9uics"},{"post_id":"cjakphl2h000gttwp1y45fup1","tag_id":"cjakphl320012ttwpc1dugvon","_id":"cjakphl390019ttwpxjeoj0dw"},{"post_id":"cjakphl2p000lttwptan34f3v","tag_id":"cjakphl370017ttwprhwoom08","_id":"cjakphl3a001bttwp245o5os0"},{"post_id":"cjakphl2t000sttwpi44admn4","tag_id":"cjakphl3a001attwp2rx6sjwa","_id":"cjakphl3b001dttwpmpu31lbc"},{"post_id":"cjakphl2t000sttwpi44admn4","tag_id":"cjakphl220009ttwpnaf9hxen","_id":"cjakphl3b001ettwp2nmal8ee"},{"post_id":"cjakphl2x000wttwpch23v54s","tag_id":"cjakphl220009ttwpnaf9hxen","_id":"cjakphl3e001httwp2yuqu7b1"},{"post_id":"cjakphl2x000wttwpch23v54s","tag_id":"cjakphl3a001cttwpbspchxtx","_id":"cjakphl3f001ittwpkwoa3b4u"},{"post_id":"cjakphl2x000wttwpch23v54s","tag_id":"cjakphl3c001fttwphjpr3can","_id":"cjakphl3h001kttwpilaifg9l"},{"post_id":"cjakphl2z000yttwpvlta5v4r","tag_id":"cjakphl3e001gttwpzd0q79oq","_id":"cjakphl3i001lttwpgijbkkyc"},{"post_id":"cjakphl300010ttwp23frxsuk","tag_id":"cjakphl3a001cttwpbspchxtx","_id":"cjakphl3l001nttwp4lug8nyn"},{"post_id":"cjakphl300010ttwp23frxsuk","tag_id":"cjakphl220009ttwpnaf9hxen","_id":"cjakphl3o001ottwpme65tee5"},{"post_id":"cjakphl320013ttwpw2bisqqm","tag_id":"cjakphl3j001mttwpo5hjqj49","_id":"cjakphl3q001rttwpr1rvbng8"},{"post_id":"cjakphl320013ttwpw2bisqqm","tag_id":"cjakphl3o001pttwpy49ccuep","_id":"cjakphl3q001sttwp0889s1wn"},{"post_id":"cjakphl340015ttwpcd9o87fs","tag_id":"cjakphl3p001qttwpz8kmbury","_id":"cjakphl3t001uttwp8yw5jy6w"},{"post_id":"cjakphl340015ttwpcd9o87fs","tag_id":"cjakphl3q001tttwpbq02dswy","_id":"cjakphl3t001vttwpokpeivr0"}],"Tag":[{"name":"JavaScript","_id":"cjakphl1r0004ttwp4ufrvj0d"},{"name":"javascript","_id":"cjakphl220009ttwpnaf9hxen"},{"name":"ES6","_id":"cjakphl2d000dttwpdmr2xbcr"},{"name":"ES5","_id":"cjakphl2j000httwpjkchewke"},{"name":"Redux","_id":"cjakphl2p000kttwp8dl1mv5t"},{"name":"Vuex","_id":"cjakphl2s000qttwp1okh2unw"},{"name":"MobX","_id":"cjakphl2v000uttwpwdnorxfk"},{"name":"Angular4","_id":"cjakphl2y000xttwp1chcnjca"},{"name":"mongodb","_id":"cjakphl320012ttwpc1dugvon"},{"name":"Angular","_id":"cjakphl370017ttwprhwoom08"},{"name":"react","_id":"cjakphl3a001attwp2rx6sjwa"},{"name":"node","_id":"cjakphl3a001cttwpbspchxtx"},{"name":"koa2","_id":"cjakphl3c001fttwphjpr3can"},{"name":"javaScript","_id":"cjakphl3e001gttwpzd0q79oq"},{"name":"Xunfeng","_id":"cjakphl3j001mttwpo5hjqj49"},{"name":"黑天很黑","_id":"cjakphl3o001pttwpy49ccuep"},{"name":"搭建hexo","_id":"cjakphl3p001qttwpz8kmbury"},{"name":"git","_id":"cjakphl3q001tttwpbq02dswy"}]}}